/**
 * Module: Require
 * Summary:
 *   Provide installation on demand.
 * Authors:
 *   Martin Vidner <mvidner@suse.cz>
 *
 * $Id$
 *
 * This module is intended to replace the include file require.ycp,
 * but that one still extsts for compatibility.
 * If you change something here, check if also the other file needs changing.
 */

{
    module "Require";
    textdomain "packager";

    include "ui/common_messages.ycp";
    import "Wizard";	// some modules call us without any dialog open
    import "Mode";

    // The constructor has a popup and calls Pkg::SourceStartCache
    // which is time consuming and annoying if not needed. (#20486)
    // So we import it inside the functions.
    //import "PackageCallbacks";

    // --- some internal bookkeeping to simplify the external interface ---

    /**
     * Has Pkg::TargetInit run?
     */
    boolean target_initialized = false;

    /**
     * Has Pkg::SourceStartCache run?
     */
    boolean source_initialized = false;

    /**
     * Ensure that Pkg:: calls work.
     * This may become superfluous.
     */
    define void EnsureTargetInit () ``{
	import "PackageCallbacks";
	target_initialized = target_initialized || Pkg::TargetInit ("/", false);
    }

    /**
     * Ensure that Pkg:: calls working with the installation sources work
     */
    define void EnsureSourceInit () ``{
	if (!source_initialized)
	{
	    import "PackageCallbacks";		// trigger constructor
	    // popup when initializing the package manager
	    UI::OpenDialog(`opt(`decorated ),`Label(_("Reading package information; One moment please...")));
	    list sources = Pkg::SourceStartCache (true);
	    UI::CloseDialog();
	    if (size (sources) > 0)
	    {
		source_initialized = true;
	    }
	    else
	    {
		include "ui/common_popups.ycp";
		// error popup, no packages sources
		// FIXME: translation
		UI::ErrorPopup (_("No package source defined."));
	    }
	}
    }

    // --- Public interface, from low-level functions to high-level ones ---

    /**
     * Is a package available for installation?
     * @param	package package name, without version or .rpm suffix
     * @return true/false
     */
    global define boolean IsPackageAvailable (string package) ``{
	EnsureSourceInit ();
	return Pkg::IsAvailable (package);
    }

    /**
     * <small>This is not a real function, just a docs placeholder</small>
     * <p>
     * Most functions have two public variants: Foo and FooTarget. In
     * normal mode they behave the same and act on the currently
     * running system. In autoyast mode (Mode::config), FooTarget acts
     * on the autoyast package list only and Foo acts both on the
     * running system and the autoyast package list.
     *
     *<pre>
     *              |Normal AI
     * -------------+----------
     * Foo          |Pkg    AI, Pkg
     * FooTarget    |Pkg    AI
     *</pre>
     * Implementation: Foo and FooTarget call (private) FooPkg and FooAI
     * according to the above table.
     * <p>
     * We need to access AutoinstSoftware, which will not be typcally
     * installed.  So we import it only in FooAI which are called if
     * Mode::config.
     */
    global define void FooTarget () ``{
	y2internal ("Do not call");
    }

    // ---------- IsPackageInstalled* ----------

    /**
     * Obsolete!
     * If required, use AreAllPackagesInstalled,
     * if conflicting, use IsAnyPackageInstalled.
     * @deprecated AreAllPackagesInstalled or IsAnyPackageInstalled
     */
    global define boolean IsPackageInstalled (string package) ``{
	y2warning (1, "IsPackageInstalled is obsolete");
	return AreAllPackagesInstalled ([package]);
    }

    /**
     * Is a package installed?
     * In normal mode, works on the current system.
     * In autoyast mode, works on the target system.
     * @see FooTarget
     */
    global define boolean IsPackageInstalledTarget (string package) ``{
	return Mode::config?
	    IsPackageInstalledAI (package):
	    IsPackageInstalledPkg (package);
    }

    /**
     * Is a package installed?
     * Works on the current system.
     * @see FooTarget
     */
    define boolean IsPackageInstalledPkg (string package) ``{
	// This is a most commonly called function and so it's
	// important that it's fast, especially in the common
	// case, where all dependencies are satisfied.
	// Unfortunately, initializing Pkg reads the RPM database...
	// so we must avoid it.
	return 0 == SCR::Execute (.target.bash, "rpm -q " + package);
	// return Pkg::IsProvided (package);
    }

    /**
     * Is a package installed?
     * Works on the target system.
     * @see FooTarget
     */
    define boolean IsPackageInstalledAI (string package) ``{
	import "AutoinstSoftware";
	return contains (AutoinstSoftware::packages, package);
    }

    // ---------- IsAnyPackageInstalled* ----------
    /**
     * Is any of these packages installed?
     * Use for conflicting packages that you want deleted.
     * In both normal and autoyast modes, works on the current system.
     * In autoyast mode, also works on the target system.
     * @see FooTarget
     * @param packages list of packages
     * @return true/false
     */
    global define boolean IsAnyPackageInstalled (list(string) packages) ``{
	boolean result = false;
	if (Mode::config)
	{
	    result = result || IsAnyPackageInstalledAI (packages);
	}
	result = result || IsAnyPackageInstalledPkg (packages);
	return result;
    }

    /**
     * Is any of these packages installed?
     * Use for conflicting packages that you want deleted.
     * In normal mode, works on the current system.
     * In autoyast mode, works on the target system.
     * @see FooTarget
     * @param packages list of packages
     * @return true/false
     */
    global define boolean IsAnyPackageInstalledTarget (list(string) packages) ``{
	return Mode::config?
	    IsAnyPackageInstalledAI (packages):
	    IsAnyPackageInstalledPkg (packages);
    }

    /**
     * Is any of these packages installed?
     * Works on the current system.
     * @see FooTarget
     * @param packages list of packages
     * @return true/false
     */
    define boolean IsAnyPackageInstalledPkg (list(string) packages) ``{
	string which = find(`p, packages, ``{ return IsPackageInstalledPkg (p); });
	return which != nil;
    }

    /**
     * Is any of these packages installed?
     * Works on the target system.
     * @see FooTarget
     * @param packages list of packages
     * @return true/false
     */
    define boolean IsAnyPackageInstalledAI (list(string) packages) ``{
	string which = find(`p, packages, ``{ return IsPackageInstalledAI (p); });
	return which != nil;
    }

    // ---------- AreAllPackagesInstalled* ----------
    /**
     * Are all of these packages installed?
     * Use for required packages that you want installed.
     * In both normal and autoyast modes, works on the current system.
     * In autoyast mode, also works on the target system.
     * @see FooTarget
     * @param packages list of packages
     * @return true/false
     */
    global define boolean AreAllPackagesInstalled (list(string) packages) ``{
	boolean result = true;
	if (Mode::config)
	{
	    result = result && AreAllPackagesInstalledAI (packages);
	}
	result = result && AreAllPackagesInstalledPkg (packages);
	return result;
    }

    /**
     * Are all of these packages installed?
     * Use for required packages that you want installed.
     * In normal mode, works on the current system.
     * In autoyast mode, works on the target system.
     * @see FooTarget
     * @param packages list of packages
     * @return true/false
     */
    global define boolean AreAllPackagesInstalledTarget (list(string) packages) ``{
	return Mode::config?
	    AreAllPackagesInstalledAI (packages):
	    AreAllPackagesInstalledPkg (packages);
    }

    /**
     * Are all of these packages installed?
     * Works on the current system.
     * @see FooTarget
     * @param packages list of packages
     * @return true/false
     */
    define boolean AreAllPackagesInstalledPkg (list(string) packages) ``{
	string which = find(`p, packages, ``{ return ! IsPackageInstalledPkg (p); });
	return which == nil;
    }

    /**
     * Are all of these packages installed?
     * Works on the target system.
     * @see FooTarget
     * @param packages list of packages
     * @return true/false
     */
    define boolean AreAllPackagesInstalledAI (list(string) packages) ``{
	string which = find(`p, packages, ``{ return ! IsPackageInstalledAI (p); });
	return which == nil;
    }

    // ---------- DoInstallAndRemove* ----------

    /**
     * Install required packages and remove conflicting packages.
     * In both normal and autoyast modes, works on the current system.
     * In autoyast mode, also works on the target system.
     * @see FooTarget
     * @param toinstall packages to install
     * @param toremove pacakges to remove
     * @return success?
     */
    global define boolean DoInstallAndRemove (list(string) toinstall, list(string) toremove) ``{
	boolean ok = true;
	if (Mode::config)
	{
	    ok = DoInstallAndRemoveAI (toinstall, toremove) && ok;
	}
	ok = DoInstallAndRemovePkg (toinstall, toremove) && ok;
	return ok;
    }

    /**
     * Install required packages and remove conflicting packages.
     * In normal mode, works on the current system.
     * In autoyast mode, works on the target system.
     * @see FooTarget
     * @param toinstall packages to install
     * @param toremove pacakges to remove
     * @return success?
     */
    global define boolean DoInstallAndRemoveTarget (list(string) toinstall, list(string) toremove) ``{
	boolean ok = true;
	if (Mode::config)
	{
	    ok = DoInstallAndRemoveAI (toinstall, toremove) && ok;
	}
	else
	{
	    ok = DoInstallAndRemovePkg (toinstall, toremove) && ok;
	}
	return ok;
    }

    /**
     * Install required packages and remove conflicting packages.
     * Works on the current system.
     * @see FooTarget
     * @param toinstall packages to install
     * @param toremove pacakges to remove
     * @return success?
     */
    define boolean DoInstallAndRemovePkg (list(string) toinstall, list(string) toremove) ``{
	y2debug ("toinstall: %1, toremove: %2", toinstall, toremove);
	EnsureSourceInit ();
	EnsureTargetInit ();
	boolean ok = true;
	foreach (string p, toinstall, ``{
	    ok = ok && Pkg::PkgInstall (p);
	});
	foreach (string p, toremove, ``{
	    ok = ok && Pkg::PkgDelete (p);
	});
	ok = ok && Pkg::PkgSolve ();
	if (ok)
	{
	    //[int successful, list failed, list remaining, list srcremaining]
	    list result = Pkg::PkgCommit (0);
	    y2debug ("PkgCommit: %1", result);
	    ok = result[1]:[] == [];
	    foreach (string remaining, result[2]:[], ``{
		ok = ok && !contains (toinstall, remaining);
	    });

	    // Only run SuSEconfig if any packages were installed?
	    // No, deleted packages are not covered by this.
	    if (true || result[0]:-1 > 0)
	    {
		Wizard::CreateDialog ();
		// inst_suseconfig returns `auto or `next
		// (update mode or Args(2) is true) => no error checking
		WFM::CallModule ("inst_suseconfig", [false, false]);
		Wizard::CloseDialog ();
	    }
	}
	return ok;
    }

    /**
     * Install required packages and remove conflicting packages.
     * Works on the target system.
     * @see FooTarget
     * @param toinstall packages to install
     * @param toremove pacakges to remove
     * @return success?
     */
    define boolean DoInstallAndRemoveAI (list(string) toinstall, list(string) toremove) ``{
	import "AutoinstSoftware";
	AutoinstSoftware::AddModulePackages (toinstall);
	AutoinstSoftware::RemoveModulePackages (toremove);
    }

    // ---------- RequireAndConflict* ----------

    /**
     * Ensure that all required packages are installed and no
     * conflicting packages are installed.
     * In both normal and autoyast modes, works on the current system.
     * In autoyast mode, also works on the target system.
     * If the current system is affected, the user is presented an
     * explanation and asked to confirm the changes.
     * For the target system, nothing is displayed.
     * @see FooTarget
     * @param require Required packages
     * @param conflict Conflicting packages
     * @param help Explanation (rich text). %1 and %2 represent a comma separated list of packages to be installed/removed
     * @return installation successful?
     */
    global define boolean RequireAndConflict (list(string) require, list(string) conflict, string help) ``{
	return RequireAndConflictButtons (
	    require, conflict, help,
	    ContinueButtonLabel (), CancelButtonLabel ());
    }

    /**
     * Ensure that all required packages are installed and no
     * conflicting packages are installed.
     * In normal mode, works on the current system
     * and the user is presented an explanation and asked to confirm
     * the changes.
     * In autoyast mode, works on the target system
     * and nothing is displayed.
     * @see FooTarget
     * @param require Required packages
     * @param conflict Conflicting packages
     * @param help Explanation (rich text). %1 and %2 represent a comma separated list of packages to be installed/removed
     * @return installation successful?
     */
    global define boolean RequireAndConflictTarget (list(string) require, list(string) conflict, string help) ``{
	return RequireAndConflictTargetButtons (
	    require, conflict, help,
	    ContinueButtonLabel (), CancelButtonLabel ());
    }

    /**
     * Like RequireAndConflict but you can specify button texts
     * in place of the default Continue and Cancel
     * @see RequireAndConflict
     * @param continue_button Text which is going to be on the left-hand button
     * @param cancel_button Text which is going to be on the right-hand button
     * @return installation successful?
     */
    global define boolean RequireAndConflictButtons (
	list(string) require, list(string) conflict, string help,
	string continue_button, string cancel_button ) ``{

	boolean ok = true;
	if (Mode::config)
	{
	    ok = RequireAndConflictAI (require, conflict) && ok;
	}
	ok = RequireAndConflictPkg (require, conflict, help,
				    continue_button, cancel_button) && ok;
	return ok;
    }

    /**
     * Like RequireAndConflictTarget but you can specify button texts
     * in place of the default Continue and Cancel
     * @see RequireAndConflictTarget
     * @param continue_button Text which is going to be on the left-hand button
     * @param cancel_button Text which is going to be on the right-hand button
     * @return installation successful?
     */
    global define boolean RequireAndConflictTargetButtons (
	list(string) require, list(string) conflict, string help,
	string continue_button, string cancel_button ) ``{

	boolean ok = true;
	if (Mode::config)
	{
	    ok = RequireAndConflictAI (require, conflict) && ok;
	}
	else
	{
	    ok = RequireAndConflictPkg (require, conflict, help,
					continue_button, cancel_button) && ok;
	}
	return ok;
    }

    /**
     * Ensure that all required packages are installed and no
     * conflicting packages are installed.
     * Works on the current system
     * and the user is presented an
     * explanation and asked to confirm the changes.
     * @see FooTarget
     * @param require Required packages
     * @param conflict Conflicting packages
     * @param help Explanation (rich text). %1 and %2 represent a comma separated list of packages to be installed/removed
     * @return installation successful?
     */
    define boolean RequireAndConflictPkg (
	list(string) require, list(string) conflict, string help,
	string continue_button, string cancel_button ) ``{

	list(string) toinstall = filter (`p, require, ``(!IsPackageInstalledPkg (p)));
	list(string) toremove = filter (`p, conflict, ``(IsPackageInstalledPkg (p)));
	if (toinstall == [] && toremove == [])
	{
	    return true;
	}
	string message = sformat (help,
				  mergestring (toinstall, ", "),
				  mergestring (toremove, ", ")
				  );
	term d = `VBox (
	    `HSpacing (40),
	    `RichText (message),
	    `HBox (
		`PushButton (`id (`continue), `opt (`default), continue_button),
		`PushButton (`id (`cancel), cancel_button)
		)
	    );
	UI::OpenDialog (d);
	any ui = UI::UserInput ();
	UI::CloseDialog ();
	if (ui == `continue)
	{
	    return DoInstallAndRemovePkg (toinstall, toremove);
	}
	return false;
    }

    /**
     * Ensure that all required packages are installed and no
     * conflicting packages are installed.
     * Works on the target system
     * and nothing is displayed.
     * @see FooTarget
     * @param require Required packages
     * @param conflict Conflicting packages
     * @param help Explanation (rich text). %1 and %2 represent a comma separated list of packages to be installed/removed
     * @return installation successful?
     */
    define boolean RequireAndConflictAI ( list(string) require,
					  list(string) conflict)
    ``{

	list(string) toinstall = filter (`p, require, ``(!IsPackageInstalledAI (p)));
	list(string) toremove = filter (`p, conflict, ``(IsPackageInstalledAI (p)));
	if (toinstall == [] && toremove == [])
	{
	    return true;
	}
	else
	{
	    return DoInstallAndRemoveAI (toinstall, toremove);
	}
    }
}
