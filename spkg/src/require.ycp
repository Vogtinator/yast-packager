/**
 * Module:
 *   sw_single
 *
 * Summary:
 *   Provide installation on demand.
 *
 * Authors:
 *   Martin Vidner <mvidner@suse.cz>
 *
 * $Id$
 */

{
    textdomain "packager";

    include "ui/common_messages.ycp";


    /**
     * This will be local when converted to a Module::
     * Has Pkg::TargetInit run?
     */
    global boolean pkg_initialized = false;

    /**
     * This will be local when converted to a Module::
     * Ensure that Pkg:: calls work.
     * This may become superfluous.
     */
    global define void EnsureTargetInit () ``{
	pkg_initialized = pkg_initialized || Pkg::TargetInit ("/", false);
    }

    /**
     * Is a package available for installation?
     * @param	package package name, without version or .rpm suffix
     * @return true/false
     */
    global define boolean IsPackageAvailable (string package) ``{
	EnsureTargetInit ();
	// will it work yet?
	return Pkg::IsAvailable (package);

	/*
	 * This was a hack for 8.0:
	 * This is a bit kludgy, since querying .package would take up
	 * a large amount of resources.
	 */
	string cmd = "/usr/bin/grep -q '^RpmName:[ \t]*%1$' %2";
	string pkd = "/var/adm/current_package_descr/suse/setup/descr/common.pkd";
	return SCR::Execute (.target.bash, sformat (cmd, package, pkd)) == 0;
    }

    /**
     * Is this package installed?
     * @param package a bare package name
     * @return true/false
     */
    global define boolean IsPackageInstalled (string package) ``{
	// too much overhead
	// return Pkg::IsProvided (package);
	return SCR::Execute (.target.bash, "/bin/rpm -q " + package) == 0;
    }

    /**
     * Is any of these packages installed?
     * @param packages list of packages
     * @return true/false
     */

    global define boolean IsAnyPackageInstalled (list(string) packages) ``{
	string which = find(`p, packages, ``{
	    return IsPackageInstalled (p);
	});
	return which != nil;
    }

    /**
     * Are all of of these packages installed?
     * @param packages list of packages
     * @return true/false
     */
    global define boolean AreAllPackagesInstalled (list(string) packages) ``{
	string which = find(`p, packages, ``{
	    return ! IsPackageInstalled (p);
	});
	return which == nil;
    }

    /**
     * Install required packages and remove conflicting packages.
     * @param toinstall packages to install
     * @param toremove pacakges to remove
     * @return success?
     */
    global define DoInstallAndRemove (list(string) toinstall, list(string) toremove) ``{
	// TODO: it is going to change
	EnsureTargetInit ();
	boolean ok = true;
	ok = ok && Pkg::DoProvide (toinstall) == $[];
	ok = ok && Pkg::DoRemove (toremove) == $[];
	return ok;
    }

    /**
     * Install and remove packages.
     * The user is presented an explanation and asked to confirm the
     * changes. Then sw_single is called to do the job.
     * @param require Required packages
     * @param conflict Conflicting packages
     * @param help Explanation (rich text). %1 and %2 represent a comma separated list of packages to be installed/removed
     * @param continue_button Text which is going to be on the left-hand button (continue)
     * @param cancel_button Text which is going to be on the right-hand button (cancel)
     * @return boolean installation successful
     */
    global define InstallAndRemoveButtons ( list(string) require,
					    list(string) conflict,
					    string help,
					    string continue_button, string cancel_button ) ``{
	list(string) toinstall = filter (`p, require, ``(!IsPackageInstalled (p)));
	list(string) toremove = filter (`p, conflict, ``(IsPackageInstalled (p)));
	string message = sformat (help,
				  mergestring (toinstall, ", "),
				  mergestring (toremove, ", ")
				  );
	term d = `VBox (
	    `HSpacing (40),
	    `RichText (message),
	    `HBox (
		`PushButton (`id (`continue), `opt (`default), continue_button),
		`PushButton (`id (`cancel), cancel_button)
		)
	    );
	UI::OpenDialog (d);
	any ui = UI::UserInput ();
	UI::CloseDialog ();
	if (ui == `continue)
	{
	    return DoInstallAndRemove (toinstall, toremove);
	}
	return false;
    }

    /**
     * Install and remove packages.
     * The user is presented an explanation and asked to confirm the
     * changes. Then sw_single is called to do the job.
     * @param require Required packages
     * @param conflict Conflicting packages
     * @param help Explanation (rich text). %1 and %2 represent a comma separated list of packages to be installed/removed
     * @return boolean installation successful
     */
    global define InstallAndRemove (list(string) require, list(string) conflict, string help) ``{
	return InstallAndRemoveButtons ( require,
					 conflict,
					 help,
					 ContinueButtonLabel (), CancelButtonLabel () );
    }

    /**
     * Ensure that all required packages are installed and no
     * conflicting packages are installed. If it is not the case, the
     * user is presented an explanation and asked to confirm the
     * changes. Then sw_single is called to do the job.
     * @param require Required packages
     * @param conflict Conflicting packages
     * @param help Explanation (rich text). %1 and %2 represent a comma separated list of packages to be installed/removed
     * @param continue_button Text which is going to be on the left-hand button (continue)
     * @param cancel_button Text which is going to be on the right-hand button (cancel)
     * @return boolean installation successful
     */
    global define RequireAndConflictButtons ( list(string) require,
					      list(string) conflict,
					      string help,
					      string continue_button, string cancel_button ) ``{
	if (AreAllPackagesInstalled (require) &&  !IsAnyPackageInstalled (conflict))
	{
	    return true;
	}
	else
	{
	    return InstallAndRemoveButtons (require, conflict, help, continue_button, cancel_button);
	}
    }

    /**
     * Ensure that all required packages are installed and no
     * conflicting packages are installed. If it is not the case, the
     * user is presented an explanation and asked to confirm the
     * changes. Then sw_single is called to do the job.
     * @param require Required packages
     * @param conflict Conflicting packages
     * @param help Explanation (rich text). %1 and %2 represent a comma separated list of packages to be installed/removed
     * @return boolean installation successful
     */
    global define RequireAndConflict (list(string) require, list(string) conflict, string help) ``{
	return RequireAndConflictButtons( require,
					  conflict,
					  help,
					  ContinueButtonLabel (), CancelButtonLabel ());
    }
}
