/* 
 * Purpose:
 *	contains dialog loop for workflows:
 *	"Install/Remove software" 	called with argument "beginner", i.e. skip inst_source if possible
 *	"Choose source of installation" without argument 	-> workflow starts with inst_source
 *
 * $Id$
 */

{
  textdomain "sw_single";
  include "package_utils.ycp";

  include "ui/wizard_dialog.ycp";
  include "ui/common_popups.ycp";
  include "ui/common_functions.ycp";

  UI(`CreateWizardDialog());

  map user_settings = $[];

  string architecture = SCR(`Read(.probe.architecture));
  user_settings = add (user_settings, "architecture", architecture );
  
  string targetroot = SCR(`Read(.target.root));
  user_settings = add (user_settings, "targetroot",
		       targetroot );  // It is from an installed system

  boolean arch_i386	= (architecture == "i386");
  boolean arch_sparc32	= (architecture == "sparc");
  boolean arch_sparc64	= (architecture == "sparc64");
  boolean arch_sparc	= (arch_sparc32 || arch_sparc64);
  boolean arch_ppc	= (architecture == "ppc");
  boolean arch_alpha	= (architecture == "axp");
  boolean arch_s390	= (architecture == "s390");
  boolean arch_ia64	= (architecture == "ia64");

  string msg_beginner = "";
  string msg_expert = "";
  
  string msg_str11 =   UI(_("<p>Launch this module to install additional packages or
remove installed ones.
To install commercial software, launch this module and select
set 'pay' from list of package sets.
</p>
"));

  string msg_str12 = UI(_("<p>Please insert <b>CD 1</b> for CD installation.</p>"));

  string msg_str13 = UI(_("<p>Launch this module if you want to choose the
source of installation. It is possible to install packages from CD,
via the network or from harddisk.</p>
<p>You can specify the source media and install
packages with this module.
</p>

") );
  
  string msg_str21 = UI(_("<P>You need to be logged in as <i>root</i> in order to
do this.</P>"));


  msg_beginner = msg_str11 + msg_str12 + msg_str21;
  msg_expert = msg_str13 + msg_str21;
  

  define fileFound( string pathname ) ``{

        string fileCommand = "test -f " + pathname;
	return ( SCR(`Execute(.target.bash, fileCommand)) == 0 );
  };
  
  string language = UI( `GetLanguage() );

  string default_language = "en";

  map lang2yast1 = ReadY2("lang2yast1.ycp");

  string  long_language	= lookup(lang2yast1, language, "english");
  
  user_settings = add( user_settings, "language", language );
  user_settings = add( user_settings, "continue_mode", false );
  user_settings = add( user_settings, "post_install", true );

  // check test_mode
  integer arg_n = size(Args()) - 1;
  boolean test_mode = false;
  
  while (arg_n >= 0) {
      if (Args(arg_n) == .test) {
	  test_mode = true;
      }            
      arg_n = arg_n - 1;
  }
  user_settings = add( user_settings, "test_mode", test_mode );
  y2debug("SW_SINGLE: Testmode %1", test_mode );

  //
  // Get informations for initialisation of PKGINFO server
  //

  list partition = [];

  // get information about diskspace ( used/free space on every partition )
  partition = SCR( `Read(.run.df ) );
 
  // filter out headline and other invalid entries 
  partition = filter( `part, partition, ``( substring ( lookup( part, "name" ), 0, 1 ) == "/" ) );

  // pkginfo expects names of partitions without "/" in front ( exception: "/" itself ) 
  list part_input = [];
  
  foreach( `part, partition, ``{
      map part_info = $[];
      if ( lookup( part, "name" ) != "/" )
      {
	  part_info = add( part_info, "name", substring( lookup( part, "name" ), 1 ) );
      }
      else
      {
	  part_info = add( part_info, "name",  lookup( part, "name" ) );
      }
      part_info = add( part_info, "used",  tointeger(lookup( part, "used" )) );
      part_info = add( part_info, "free",  tointeger(lookup( part, "free" )) );

      part_input = add( part_input, part_info );
  });
  y2debug( "SW_SINGLE: partition input: %1", part_input ); 
   
  
  /*
   * main dialog loop
   */
  
  list dialog = [
		 `inst_source( true, true ),
		 `inst_sw_single( ),
		 `inst_rpmcopy( false, false ),
		 `inst_suseconfig( false, false )
  ];

  integer id = 0;
  any result = `next;

  boolean skip_source = false;
  
  // if sw_single is called with argument "beginner" or with a package list or package name
  // -> skip inst_source (if possible)
  
  if ( size( Args() ) > 0 && Args(0) != .test )
  {
      string postfix =  substring( Args(0), size(Args(0))-4 );
      y2debug("SW_SINGLE: POSTFIX: %1", postfix );

      if ( postfix == ".rpm" )
      {
	  if ( fileFound( Args(0) ) )
	  {
	      // prepare for inst_rpmcopy !!!
	      map installMap = $[];
	      installMap = add(installMap, "bootmode", "Harddisk" );
	      user_settings = add(user_settings, "installMap", installMap );

	      CallFunction( `inst_rpmcopy( false, false, Args(0) ));
	      // package is installed without paying attention to SuSE dependencies
	      // don't call SuSEConfig -> dialog loop ends
	      id = size(dialog) + 1;
	  }
	  else
	  {
	      string message = sformat (UI(_("Package %1 not found.")), Args(0) );
	      UI(`DisplayMessage(message));  
	      return `cancel;
	  }  
      }
      else
      {
	  boolean go_on = ChangeCD( 1, true);
	  
	  if ( !go_on )
	  {
	      any ret = UI(`ContinueCancel(_("No access to source media used on previous installation.
Continue with choosing new installation source?"), _("&Yes"), _("&No")));

	      if ( ret )		// choose new installation source
	      {
		  skip_source = false;
		  id = 0;
	      }
	      else			// exit the installation dialog
	      {
		  UI(`CloseDialog() );
		  return `cancel;
	      }
	  }
	  else			// mount ok on previos media -> skip inst_source
	  {
	      skip_source = true;
	      id = id + 1;
	  }
      }
  }

  if ( !test_mode )
  {
      // removing old logging
      SCR(`Execute (.target.bash, "/bin/rm /var/log/y2logRPM*"));
  }
  
  while ((id >= 0) && (id < size (dialog))) {

      if ( symbolof (select( dialog, id )) == `inst_sw_single )
      {
	  any retval = nil;

	  // mount CD 1 BEFORE initializing pkginfo-Server (needed to get commom.pkd)
	  boolean go_on = ChangeCD( 1, true); 
	  if ( !go_on )
	  {
	      // quit dialog (CD 1 cannot be skipped)
	      UI( `CloseDialog() );      
	      return `cancel;
	  }

	  boolean version_ok = false;
	  string instSource = GetInstSource(1);
	  string infopath =  instSource + "setup/descr";
	  string dudir = instSource + "setup/du/du.dir";

	
	  UI(`OpenDialog(`opt(`decorated ),`Label(_("Reading package information; One moment please..."))));
	  
	  retval = PKGINFO (`setEnvironment( $["packageinfopath":infopath, "common.pkd":"common.pkd",
					      "language":long_language,  "dudir":dudir,
					      "partition":part_input, "rootpath":"/",
					      "yastpath":"/var/lib/YaST",
					      "update":true,
					      "memoptimized":true,
					      "forceInit":true]		// force initialisation

					     ));
	  y2debug( "SW_SINGLE: Return  PKGINFO(`setEnvironment() %1", retval );	

	  UI(`CloseDialog());

	  map version_map = PKGINFO (`compareSuSEVersions() );
	  
	  if ( lookup( version_map, "installedGreater", false ) )
	  {
	      if ( IsRemountable() )
	      {
		  SCR(`Execute(.target.bash, "/bin/umount /var/adm/mount") );
	      }
	      // Popup informs the user that he/she wants to install an older versions
	      string msg1 = UI(_("The version of SuSE distribution on source media
must NOT be older than the installed one.\n"));

	      string versions = sformat( UI(_("Installed version: %1\n")),
					 lookup( version_map, "installedVersion","" )) +
		                sformat( UI(_("Version on source media: %1\n\n")),
					 lookup( version_map, "updateVersion","" ));
	      y2debug( "SW_SINGLE: %1", versions );
	      
	      string msg2 = UI(_("Please insert current CD or specify path of current sources."));
	      
	      UI(`DisplayMessage(msg1 + versions + msg2));

	      // continue with inst_source
	      id = 0;
	      continue;
	  }

          // There could be a list of packages (defined in an ascii-file) or a package name
	  
	  if ( size(Args() ) > 0 && Args(0) != "beginner" && Args(0) != .test )
	  {
	      string pathname = Args(0);
	      map installMap = $[];
	      
	      if ( !fileFound(pathname) )
	      {
		  list installList = [];
		  installList = add ( installList, pathname );
		  installMap = add(installMap,"install", installList);

		  string message = sformat(UI(_("File %1 not found.")), Args(0) );
//		  UI(`DisplayMessage(message));  
//		  return `cancel;
	      }
	      else
	      {
		  y2milestone("Reading file %1", pathname );
		  installMap = Read ( pathname );
	      }
	      y2milestone("installMap: %1", installMap );
      

	      if ( installMap == nil || size ( installMap ) == 0 )
	      {
		  string message = UI(_("Error while reading configuration-file."));
		  UI(`DisplayMessage(message));
		  return `cancel;
	      }
	      else
	      {
		  list installList = lookup ( installMap, "install", [] );
		  list deleteList = lookup ( installMap, "delete", [] );
		  boolean userInput = lookup ( installMap, "userInput", false );

		  y2milestone("installList: %1", installList );
		  y2milestone("deleteList: %1", deleteList );
		  y2milestone("userInput: %1", userInput );

	  
		  foreach( `package, installList, ``{
		      any r = PKGINFO( `selectInstall( package ));
		      y2debug( "PKGINFO selectInstall: %1", package );
		  } );           

		  foreach( `package, deleteList, ``{
		      any r = PKGINFO( `selectDelete( package ) );
		      y2debug( "PKGINFO selectDelete: %1", package );
		  } );
	       
		  // Checking dependecies
		  map pac_depends = PKGINFO(`getDependencies());
	   
		  list(map) or_depends = lookup( pac_depends, "OR" );
		  y2debug( "OR Dependencies: %1", or_depends );
		  list(map) xor_depends = lookup( pac_depends, "XOR" );
		  y2debug( "XOR Dependencies: %1", xor_depends );

		  if ( userInput == true )
		  {
		      result = CallFunction( `inst_sw_single( `post_install,
							      `not_only_checked,
							      part_input ) );
		  }
		  else
		  {
		      if ( or_depends != [] || xor_depends != [] )
		      {
			  // There is an unresolved dependency -> call
			  // single-package-selection to solve it.
			  result = CallFunction( `inst_sw_single( `post_install,
								  `only_check,
								  part_input) );
		      }
		      else
		      {
			  // install anyway
			  result = `ok;
		      }
		  }
	      }
	  }
	  else
	  {
	      // Calling inst_sw_single
	      result = CallFunction( `inst_sw_single( `post_install,
						      `not_only_checked,
						      part_input ) );

	  }
      }
      else
      {
	  result = CallFunction( select(dialog, id) );
      }
      y2debug( "RESULT: %1", select(dialog, id), result );

      if (result == `cancel || result == `abort)
      {
	  // dialog loop ends
	  id = size( dialog ) +1; 
      }
      else if (result == `auto)
      {
	  // inst_suseconfig returns `auto -> last module, dialog loop ends
	  id = id + 1;			
      }
      else if (result == `next )		
      {
	  id = id + 1;
      }
      else if (result == `ok )	// inst_sw_single returns `ok
      {
	  // setting user_setting.install_info for packages which have to be installed
	  list install_info =  PKGINFO ( `getInstallSet() );
	  // y2debug( "Writing install_info: %1", install_info );
	  user_settings = add ( user_settings , "install_info", install_info );

	  list delete_info =  PKGINFO ( `getDeleteSet() );
	  // y2debug( "Writing delete_info: %1", delete_info );
	  user_settings = add ( user_settings , "delete_info", delete_info );

	  y2debug( "SW_SINGLE: Usersettings: %1", user_settings );

	  if ( install_info != [] || delete_info != [] )
	  {
	      id = id + 1;  
	  }
	  else
	  {
	      y2debug( "Nothing selected" );
	      // dialog loop ends
	      id = id+3;
	  }
      }
      else if (result == `back)
      {
	  id = id - 1;
      }
      else if (result == `cancel_single)
      {
	  if ( !skip_source )
	  {
	      id = id - 1; 
	  }
	  else
	  {
	      id = id - 2;
	  }
      }
      
  }

  UI(`CloseDialog());
  
  // umount CD (safety reasons)
  SCR(`Execute(.target.bash, "/bin/umount /var/adm/mount") );
  
  return `next;
}
