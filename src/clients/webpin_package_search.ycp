/**
 * File:	webpin_package_search.ycp
 * Package:	YaST packager - Client using Webpin XML API
 * Authors:	Katarina Machalkova <kmachalkova@suse.cz>
 *		Lukas Ocilka <locilka@suse.cz>
 *
 * $Id:$
 *
 * This client provides UI for searching for packages
 * via Webpin XML.
 * See http://en.opensuse.org/Package_Search/Design for the API.
 */


{
  textdomain "packager";

  import "Label";
  import "Popup";
  import "Progress";
  import "Sequencer";
  import "WebpinPackageSearch";
  import "Wizard";
  import "Directory";
  import "Report";

  list <map> search_results = [];
  map <string, integer> index = $[];

  boolean AbortDialog() {
      return Popup::YesNo( _("All changes will be lost. Really exit?"));
  }

  boolean Abort() {
    any ret = UI::PollInput();

    if (ret == `abort)
	return AbortDialog();
    else
	return false;
  }
  
  string SearchExpression() {
	string ret = (string) UI::QueryWidget(`id("search_text"), `Value);

	if (ret == "") {
	     Popup::Message(_("Search expression must not be empty!")); 
	     UI::SetFocus(`id("search_text"));
	}
	return ret;
  }

  map <string, boolean> SearchParameters() {
    list p = (list) UI::QueryWidget(`id("search_in"), `SelectedItems);

    map <string, boolean> ret = listmap ( string key, [ "name", "description", "contents" ], {
	    return $[ key : contains (p, key)];
	});
    //y2internal("%1", ret);
    return ret;
  }

  void CreatePackageDescription( ) {
    string checksum = (string) UI::QueryWidget(`id("results"), `CurrentItem );
    map citem = search_results [ index[checksum]: 0 ]: $[];
    string ret = "";

    if ( citem != $[] ) {
        string descr = sformat(_("<b>Repository URL:</b> %1<br>"), citem["repoURL"]:"");
        string version = sformat(_("<b>Version:</b> %1<br>"), citem["version"]:"");

	string archs = sformat(_("<b>Architecture:</b> %1<br>"), mergestring( citem["archs"]:[],","));
	ret = "<p>" + descr + version + archs + "</p>";
    }
    else
	ret = _("<p><b>No packages matching entered criteria were found</b></p>");

     UI::ChangeWidget(`id("description"),`Value, ret);
  }

  list CreatePackageList( list < map > results ) {
    list pkg_items = [];
    integer i = 0;

   foreach ( map  it, results, {
// Webpin seems to return "ppc" arch even for some i386 packages (e.g., "joe")
	// doesn't match the architecture
//	if (! WebpinPackageSearch::MatchesCurrentArchitecture (it["archs"]:["noarch"])) {
//	    y2milestone ("Doesn't match the current arch: %1", it);
//	    return;
//	}

	pkg_items = add( pkg_items, `item(`id(it["checksum"]:""),it["name"]:"" + " - " + it["summary"]:"" ));
	index = add( index, it["checksum"]:"", i);
	i = i+1; 
    });
    return pkg_items;
  } 

  list <map> FilterOutSelectedPackages() {
	list <string>  p = ( list <string> ) UI::QueryWidget(`id("results"), `SelectedItems);
	list < map > result = [];

	foreach ( string s, p, {
	    result = add(result, search_results[ index[s]:0 ]:$[]);
	});

    	y2internal("%1", result);
	return result;
  }

  symbol ReadDialog() {
    list <string> steps = [
	_("Check Network Configuration"),
	_("Initialize Package Manager")
    ];

    list <string> actions = [
	_("Checking Network Configuration ..."),
	_("Initializing Package Manager ... ")
    ];

    Progress::New(
	_("Reading Package Search Setup..."),
	" ",
	size(steps),
	steps,
	actions,
	_("<p>Please wait while packager is initializing...</p>")
     );

     Progress::NextStage();
     if (Abort()) return `abort;
     sleep(100);

     Progress::NextStage();
     if (Abort()) return `abort;
     sleep(100);

     Progress::Finish();
     return `next;
  }

  symbol MainDialog() {
    Wizard::SetContents (
            // TRANSLATORS: dialog caption
            _("Package Search"),
            `VBox (
                `HBox (
                    `VBox(
			`MinWidth(20, `InputField (`id ("search_text"), `opt (`hstretch), "Search &Expression")),
                    // TRANSLATORS: push button
                        `Left(`PushButton (`id ("search"),  _("&Search"))),
                        `VStretch()
		    ),
		    `MultiSelectionBox(
		        `id("search_in"),
		       _("Search &In"),
		       [
			`item( `id("name"),_("Name"), true ),
			`item( `id("description"), _("Description"), true ),
			`item( `id("contents"), _("Contents"))
			]
		     )//,
                ),
				//`RadioButtonGroup(
		//    `id(`rb),
		//    `VBox(
		//        `Left(`Label( _("Search Repositories"))),
		//        `Frame( "",
		//	    `VBox(
		//                `Left(`RadioButton(`id("current_product"),_("Current product") ) ),
		//                `Left(`RadioButton(`id("factory"),_("Factory") ) ),
		//                `VStretch()
		//	    )
		//         )
		//    )
		//)
	    //)
		//),
                `VWeight (
                    2,
                    `MultiSelectionBox(
                        `id ("results"), `opt (`notify, `hstretch),
                        // TRANSLATORS: multi-selection box
                        _("&Found Packages"), []
                    )
                ),
		//`HBox(
		    `Left( `Label( _("Package Description")) ),
		    //`HStretch(),
		    //`CheckBox(_("Keep Package Repositories Subscribed"), true)
		//),
		`VWeight(
		    1,
		    `RichText(`id("description"), "")
		)
	    ),
	    _("<p><big><b>Package Search</b></big><br>
This YaST module enables you to use the functionality of <i>Webpin package search</i>.
It searches within all known openSUSE build-service and openSUSE community repositories.</p>") +

_("<p><big><b>Security</b></big><br>
The software found is often not part of the distribution itself and the level of trust
depends on yourself. We do not take any responsibility for installing
such software.</p>
"),
	    //We don't need back button
	    false,
	    true
    );

    Wizard::SetTitleIcon ("yast-software");
    Wizard::SetAbortButton (`cancel, Label::CancelButton());

    UI::SetFocus(`id("search_text"));

    any dialog_ret = nil;
    while (true) {
	dialog_ret = UI::UserInput();
	if (dialog_ret == `next){
	    string temporary_xml = Directory::tmpdir + "/one_click_install_temporary_file.xml";

	    list <map> selected_packages = FilterOutSelectedPackages();

	    if (selected_packages == nil || size (selected_packages) == 0) {
		Report::Message (_("Select some packages to install."));
		UI::SetFocus(`id("results"));
		continue;
	    }

	    WebpinPackageSearch::PrepareOneClickInstallDescription (selected_packages, temporary_xml);

	    any oci = WFM::CallFunction ("OneClickInstallUI", [temporary_xml]);
	    y2milestone ("OneClickInstallUI returned: %1", oci);
	    break;
	}
	else if (dialog_ret == "search") {
	    string search_expr = SearchExpression();

	    if (search_expr != "") {
		map <string, boolean> search_params =  SearchParameters();
		Popup::ShowFeedback("", _("Searching for packages..."));
	        search_results =
		    WebpinPackageSearch::SearchForPackages(
	                search_expr,
	                nil,
	                search_params
	        );
		Popup::ClearFeedback();
		list items = CreatePackageList( search_results );

		if (search_results != nil) {
		    UI::ChangeWidget(`id("results"), `Items, items);
		    UI::SetFocus(`id("results"));
		}
		else
		    UI::SetFocus(`id("search_text"));

		CreatePackageDescription();
	    }
	    //else
		continue;
	}
	else if (dialog_ret == "results") {
	    CreatePackageDescription();
	}
	else if (dialog_ret == `abort || dialog_ret == `cancel) {
	    if (AbortDialog()) {
		dialog_ret = `abort;
		y2milestone ("Aborting...");
		break;
	    }
	}
	else {
	    y2error ("Unknown ret: %1", dialog_ret);
	}
    }
    return (symbol) dialog_ret;

  }
  
  symbol MainSequence () {
        map aliases = $[
            "read"      : ``( ReadDialog() ),
            "main"   : ``( MainDialog() ),
//	    "write"   : ``(WriteDialog())
        ];

        map sequence = $[
            "ws_start"  : "read",
            "read"      : $[
                `next   : "main",
                `abort  : `abort,
            ],
            "main"   : $[
                `abort  : `abort,
		`next	: `next
            ],
//	    "write" : $[
//		`abort : `abort,
//		`next  : `next
//	    ],
        ];

	any seq_ret = Sequencer::Run( aliases, sequence );

	return (symbol) seq_ret;
  }


  Wizard::CreateDialog();

  symbol client_ret = MainSequence();

  Wizard::CloseDialog();

  return client_ret;

}
