/**
 * Module: 		inst_source.ycp
 *
 * Author:		Cornelius Schumacher <cschum@suse.de>
 *
 * Purpose:
 * Adding, removing and prioritizing of repositories for packagemanager.
 *
 * $Id$
 *
 */

{
    textdomain "packager";

    import "Confirm";
    import "Mode";
    import "Installation";
    import "PackageCallbacksInit";
    import "PackageLock";
    import "PackageSystem";
    import "Report";
    import "Stage";
    // SourceManager overlaps quite a bit with inst_source,
    // so far we only use it for ZMD sync, TODO refactor better
    import "SourceManager";
    import "SuSEFirewall";
    import "Wizard";

    import "Label";
    import "Popup";
    import "AddOnProduct";
    import "Sequencer";
    import "CommandLine";
    // constructor of Product is needed in order to initialize the product
    // macro. Takes a lot of time because whole package manager target
    // is initialized
    import "Product";

    include "packager/inst_source_dialogs.ycp";

    integer numSources = 0;

    list<map<string,any> > sourceStatesIn = [];
    list<map<string,any> > sourceStatesOut = [];
    list<integer> sourcesToDelete = [];

    // Do not sync the changes to ZENworks even if rug is present
    // This is handy for repairing an already out-of-sync situation
    boolean have_rug = nil;
    boolean norug = nil;

    // constant Plaindir
    const string plaindir_type = "Plaindir"; 

    boolean download_meta = true;

    /**
        Create a table item from a map as returned by the InstSrcManager agent.
        @param source The map describing the source as returned form the agent.
        @return An item suitable for addition to a Table.
    */
    define term createItem( integer index, map source ) ``{
        integer id = source[ "SrcId" ]:0;
        map generalData = Pkg::SourceGeneralData( id );
	y2milestone("generalData(%1): %2", id, generalData);

	string alias = haskey(sourceStatesOut[index]:$[], "name") ?
	    sourceStatesOut[index,"name"]:"" :
	    // unkown name (alias) of the source
	    generalData[ "alias" ]:generalData[ "type" ]: _("Unknown Name");

        term item = `item(
			  `id( index ),
			  // corresponds to the "Enable/Disable" button
			  source[ "enabled" ]:true ? UI::Glyph (`CheckMark) : "",
//			  source["autorefresh"]:true ? _("On") : _("Off"),
			  // translators: unknown name for a given source
			  alias
//			  generalData[ "url" ]:""
			  );
        return item;
    }

    map<string,any> getSourceInfo (integer index, map source) {
        integer id = source[ "SrcId" ]:0;
        map generalData = Pkg::SourceGeneralData( id );
	y2milestone("generalData(%1): %2", id, generalData);

	string alias = haskey(sourceStatesOut[index]:$[], "name") ?
	    sourceStatesOut[index,"name"]:"" :
	    // unkown name (alias) of the source
	    generalData[ "alias" ]:generalData[ "type" ]: _("Unknown Name");

	map<string,any> out = $[
	    "enabled" : source["enabled"]:true,
	    "autorefresh" : source["autorefresh"]:true,
	    "name" : alias,
	    "url" : generalData[ "url" ]:"",
	    "type" : generalData["type"]:"",
	];
        return out;

    }

    /**
     * Fill sources table with entries from the InstSrcManager agent.
     */
    define void fillTable() ``{
	y2milestone ("Filling repository table");
        list items = [];

        numSources = size( sourceStatesOut );

        integer i = 0;
        while ( i < numSources ) {
            items = add( items, createItem( i, sourceStatesOut[ i ]:$[] ) );
            i = i + 1;
        }

        UI::ChangeWidget( `id( `table ), `Items, items );
    }

    void fillRepoInfo(integer index, map source) {
	map<string,any> info = getSourceInfo (index, source);
	UI::ReplaceWidget (`id (`repo_rp), `VBox (
	    // heading - in case repo name not found
	    `Left (`Heading (info["name"]:_("Unknown repository name"))),
	    // label, %1 is URL
	    `Left (`Label (sformat (_("URL: %1"),
		// label to be used instead of URL if not found
		info["url"]:_("Unknown")))),
	    // label, %1 is repo category (eg. YUM)
	    `Left (`Label (sformat (_("Category: %1"),
		// label to be used instead of repo category if not known
		info["type"]:_("Unknown"))))
	));
	UI::ChangeWidget (`id (`enable), `Value, info["enabled"]:true);
	UI::ChangeWidget (`id (`autorefresh), `Value, info["autorefresh"]:true);
    }

    void fillCurrentRepoInfo () {
	integer selected = (integer)UI::QueryWidget (`id (`table), `CurrentItem);
	if (selected == nil)
	    return;
	map data = sourceStatesOut[selected]:$[];
	fillRepoInfo (selected, data);
    }

    boolean LicenseAccepted (integer id) {
	Wizard::CreateDialog ();
	boolean ret = AddOnProduct::AcceptedLicenseAndInfoFile (id);
	UI::CloseDialog ();
	return ret;
    }

    define symbol createSource( string url, boolean download, string preffered_name ) ``{
	y2milestone("createSource: %1", url);

        if ( url != "" )
        {
	    // for Plaindir repository we have to use SourceCreateType() binding
	    boolean plaindir = false;
	    map parsed = URL::Parse(url);
	    string scheme = parsed["scheme"]:"";

	    if (scheme == "pkg")
	    {
		parsed["scheme"] = "dir";
		url = URL::Build(parsed);
		plaindir = true;
	    }

	    // check if SMB/CIFS share can be mounted
	    if (scheme == "smb" && SCR::Read(.target.size, "/sbin/mount.cifs") < 0)
	    {
		y2milestone("SMB/CIFS share cannot be mounted, installing missing 'cifs-mount' package...");
		// install cifs-mount package
		PackageSystem::CheckAndInstallPackages(["cifs-mount"]);
	    }

	    list<list<string> > new_repos = Pkg::RepositoryScan(url);
	    y2internal("new_repos: %1", new_repos);

	    // add at least one product if the scan result is empty (no product info available)
	    if (size(new_repos) == 0)
	    {
		string url_path = URL::Parse(url)["path"]:"";
		list<string> p_elems = splitstring(url_path, "/");
		const string fallback = _("Repository");

		if (size(p_elems) > 1)
		{
		    url_path = p_elems[size(p_elems) - 1]:fallback;

		    if (url_path == nil || url_path == "" )
		    {
			url_path = p_elems[size(p_elems) - 2]:fallback;

			if (url_path == nil || url_path == "" )
			{
			    url_path = fallback;
			}
		    }
		}

		new_repos = [ [ url_path, "/" ] ];
	    }

            list<integer> newSources = [];
	    boolean auto_refresh = true;

	    // disable autorefresh for ISO images
	    const string iso_prefix = "iso:";
	    if (substring(url, 0, size(iso_prefix)) == iso_prefix)
	    {
		y2milestone("ISO image detected, disabling autorefresh (%1)", url);
		auto_refresh = false;
	    }

	    // CD or DVD repository?
	    boolean cd_scheme = contains(["cd", "dvd"], tolower(URL::Parse(url)["scheme"]:""));
	    if (cd_scheme)
	    {
		y2milestone("CD/DVD repository detected, disabling autorefresh (%1)", url);
		auto_refresh = false;
	    }

	    boolean enter_again = false;

	    foreach(list<string> repo, new_repos,
		{
		    if (enter_again)
			continue;

		    string name = repo[0]:"";
		    if (preffered_name != nil && preffered_name != "")
			name = preffered_name;
		    string prod_dir = repo[1]:"/";

		    // probe repository type (do not probe plaindir repo)
		    string repo_type = (plaindir) ? plaindir_type : Pkg::RepositoryProbe(url, prod_dir);

		    y2milestone("Repository type (%1,%2): %3", url, prod_dir, repo_type);

		    // the probing has failed
		    if (repo_type == nil || repo_type == "NONE")
		    {
			if (scheme == "dir")
			{
			    if (! Popup::AnyQuestion (
				Popup::NoHeadline (),
				// continue-back popup
    _("There is no product information available at the given location.
If you expected to address a product, return back and enter
the correct location.
To make rpm packages located at the specified location available
in the packages selection, continue."),
				Label::ContinueButton (),
				Label::BackButton (),
				`focus_no))
			    {
				enter_again = true;
				continue;
			    }

			    repo_type = plaindir_type;
			    y2warning("Probing has failed, using Plaindir repository type.");
			}
			else
			{
			    continue;
			}
		    }

		    string alias = name;
		    // replace " " -> "_" (avoid spaces in .repo file name)
		    alias = mergestring(splitstring(alias, " "), "_");
		    string alias_orig = alias;

		    // all current aliases
		    list<string> aliases = maplist(integer i, Pkg::SourceGetCurrent(false),
			{
			    map info = Pkg::SourceGeneralData(i);
			    return info["alias"]:"";
			}
		    );

		    // repository alias must be unique
		    // if it already exists add "_<number>" suffix to it
		    integer idx = 1;
		    while (contains(aliases, alias))
		    {
			alias = sformat("%1_%2", alias_orig, idx);
			idx = idx + 1;
		    }

		    // map with repository parameters: $[ "enabled" : boolean,
		    // "autorefresh" : boolean, "name" : string, "alias" : string,
		    // "base_urls" : list<string>, "prod_dir" : string, "type" : string ]
		    map<string,any> repo_prop = $[];

		    repo_prop["enabled"] = true;
		    repo_prop["autorefresh"] = auto_refresh;
		    repo_prop["name"] = name;
		    repo_prop["prod_dir"] = repo[1]:"/";
		    repo_prop["alias"] = alias;
		    repo_prop["base_urls"] = [ url ];
		    repo_prop["type"] = repo_type;

		    integer new_repo_id = Pkg::RepositoryAdd(repo_prop);
		    y2milestone("Added repository: %1: %2", new_repo_id, repo_prop);

		    newSources = add(newSources, new_repo_id);

		    if (cd_scheme)
		    {
			// for CD/DVD repo download the metadata immediately,
			// the medium is in the drive right now, it can be changed later
			// and accidentaly added a different repository
			y2milestone("Adding a CD or DVD repository, refreshing now...");
			Pkg::SourceRefreshNow(new_repo_id);
		    }
		}
	    );

	    // broken repository or wrong URL - enter the URL again
	    if (enter_again)
		return `again;

            if ( size( newSources ) == 0  )
            {
		// popup message part 1
                string _msg1 = sformat( _("Unable to create repository
from URL '%1'."), url );
		// popup message part 2
                string _msg2 = _("Try again?");

                boolean tryagain = Popup::YesNo( _msg1 + "\n" + Pkg::LastError() + "\n" + _msg2 );
                if ( tryagain ) return `again;
                else return `cancel;
            }
            else
            {
                foreach( integer id, newSources, ``{
		  if (! LicenseAccepted (id))
		  {
		    Pkg::SourceDelete (id);
		  }
		  else
		  {
		    map src_data = Pkg::SourceGeneralData (id);
		    y2milestone("Addded repository: %1", src_data);

                    map<string, any> sourceState = $[ "SrcId": id, "enabled": src_data["enabled"]:true, "autorefresh" : src_data["autorefresh"]:true, "name" : src_data["name"]:"", "do_refresh" : download ];
                    sourceStatesOut = add( sourceStatesOut, sourceState );
		  }
                } );
                return `ok;
            }
        }
    }


    /**
     * Find which repositories have to be added or deleted to ZENworks.
     * #182992: formerly we did not consider the enabled attribute.
     * But ZENworks cannot completely disable a repository (unsubscribing a
     * repository merely decreases its priority) so we consider a disabled repository
     * like a deleted one.
     * @param statesOld sourceStates{In or Out}
     * @param statesNew sourceStates{In or Out}
     * @return the list of SrcId's that are enabled in statesNew
     *  but are not enabled in statesOld
     */
    list<integer> newSources (list<map<string,any> > statesOld,
			      list<map<string,any> > statesNew) {
	y2milestone ("From %1 To %2", statesOld, statesNew);
	list<integer> ret = [];
	map<integer, boolean> seen = listmap (
	    map<string, any> src, statesOld,
	    ``( $[(src["SrcId"]:-1) : (src["enabled"]:true) ] ));
	foreach (map<string, any> src, statesNew, {
	    integer newid = src["SrcId"]:-1;
	    boolean newena = src["enabled"]:true;
	    if (newena && ! seen[newid]:false)
		ret = add (ret, newid);
	});
	y2milestone ("Difference %1", ret);
	return ret;
    }

    define void deleteSource( integer index ) ``{
	integer srcid = sourceStatesOut[index, "SrcId"]:-1;

	if( srcid != -1)
		sourcesToDelete = add( sourcesToDelete, srcid );

        sourceStatesOut = remove( sourceStatesOut, index );
    }

    boolean Write() {
	y2internal("New config: %1", sourceStatesOut);
 	boolean success = Pkg::SourceEditSet( sourceStatesOut );

	// we must sync before the repositories are deleted from zypp
	// otherwise we will not get their details
	list<integer> added   = newSources (sourceStatesIn, sourceStatesOut);
	list<integer> deleted = newSources (sourceStatesOut, sourceStatesIn);
	boolean have_rug = !norug && (integer)SCR::Read (.target.size, "/usr/bin/rug") >= 0;
	boolean any_changed = added != [] || deleted != []; // #217697
	if (success && have_rug && any_changed) {
	    UI::OpenDialog (
		`VBox (
		    `Label (SourceManager::SyncLabel ()),
		    `PushButton (`id (`abort), Label::AbortButton ())
		    ));
	    boolean syncok = SourceManager::SyncAddedAndDeleted (added, deleted);
	    UI::CloseDialog ();
	    if (!syncok)
	    {
		// yes/no popup
		if (!Popup::YesNo (_("Repository synchronization with ZMD failed.
Save changes anyway?")))
		    success	= false;

	    }
	}
	else {
	    y2milestone ("No rug or ZMD sync disabled - not syncing: success: %1, have_rug: %2, any_changed: %3", success, have_rug, any_changed);
	}

	foreach( integer id, sourcesToDelete, ``{
	    success = success && Pkg::SourceDelete(id);
	});


	foreach(map<string,any> src_state, sourceStatesOut,
	    {
		if (src_state["do_refresh"]:false)
		{
		    integer srcid = src_state["SrcId"]:-1;
		    y2milestone("Downloading metadata for source %1", srcid);

		    Pkg::SourceRefreshNow(srcid);
		}
	    }
	);

	// store in the persistent libzypp storage
	success = success && Pkg::SourceSaveAll(); // #176013

	return success;
   }


symbol SummaryDialog () {
    y2milestone ("Running Summary dialog");
    list items = [];

    // push button - change URL of the selected repository
    string replaceButtonLabel = _("&Replace...");
    // push button - refresh the selected repository now
    string refreshButtonLabel = _("Re&fresh Now");
    // push button - disable/enable the selected repository
    string enableButtonLabel = _("Status &On or Off");
    // push button - disable/enable automatic refresh of the selected repository
    string refreshOnOffButtonLabel = _("Refre&sh On or Off");
    // push button - set name of the selected repository
    string setAliasButtonLabel = _("Set &Name...");

    SourceManager::ReadSyncFlag();
    boolean sync_zmd = SourceManager::GetSyncFlag();
    if (sync_zmd == nil)
    {
	sync_zmd = true;
    }

    term contents =
        `VBox(
	      `HBox(
		    `Table(`id(`table),`opt(`notify, `immediate),
				// table header
			    `header( _("Enabled"),
				// table header
//				_("Refresh"),
				// table header
				_("Name")),
				// table header
//				_("URL") ),
			    items ),
		    `HSpacing()
		),
		`HBox (
		    `HSpacing(0.35),
		    `Frame ("", `HBox (`HSpacing (1), `VBox (
			`ReplacePoint (`id (`repo_rp), `VBox (
			    `Left (`Heading ("Repo Name")),
			    `Left (`Label ("URL:")),
			    `Left (`Label ("Category:"))
			)),
			`VSpacing (0.4),
			// label
			`Left (`Label (_("Properties"))),
			// check box
			`Left (`CheckBox (`id (`enable), `opt (`notify), _("Enabled"))),
			// check box
			`Left (`CheckBox (`id (`autorefresh), `opt (`notify), _("Automatically Refresh"))),
			`VSpacing (0.4),
			(have_rug) ?
			    `Left (`CheckBox (`id (`zmdsync),
				// Checkbox label
				_("Synchronize Changes with &ZENworks"),
				!norug && sync_zmd))
			    : `Empty()
		    ))),
		    `HSpacing (1.35)
		),
		`VSpacing(0.3),
	      `HBox(
		    `PushButton (`id (`add), `opt(`key_F3),
			Label::AddButton ()),
		    `PushButton(`id(`replace), `opt(`key_F4),
			Label::EditButton ()),
		    `PushButton (`id(`delete), `opt(`key_F5),
			Label::DeleteButton ()),
		    `HStretch (),
/*
		    // menu button label
		    `MenuButton (`id(`menu_button), `opt(`key_F6), _("Repository Settings"), [
//			`item(`id(`enable), enableButtonLabel),
//			`item(`id(`refresh_on_off), refreshOnOffButtonLabel),
			`item(`id(`refresh), refreshButtonLabel ),
			`item(`id(`set_alias), setAliasButtonLabel)
		    ])
*/
		    `PushButton (`id (`refresh), refreshButtonLabel )
		),
                `VSpacing( 0.5 )
        );

    // dialog caption
    string title = _("Configured Software Repositories");
//    string title = _("Media Containing the Software Repository");

    // help
    string help_text = _("<p>
In this dialog, manage configured software repositories.</p>");

    help_text = help_text + _("<p>
<b>Adding a New Repository</b><br>
To add a new repository, use <b>Add</b> and specify the software repository.
</p>");

    // help, continued
    help_text = help_text + _("<p>
To install packages from <b>CD</b>,
have the CD set or the DVD available.
</p>
");

    // help, continued
    help_text = help_text + _("<p>
The CDs can be copied to <b>hard disk</b>
and then used as a repository.
Insert the path name where the first
CD is located, for example, /data1/<b>CD1</b>.
Only the base path is required if all CDs are copied
into one directory.
</p>
");


    // help, continued
    help_text = help_text + _("<p>
<b>Modifying a Repository Status</b>
To change a repository location, use <b>Edit</b>. To remove a repository, use
<b>Delete</b>. To enable or disable the repository or to change the refresh status at initialization time, select the repository in the table and use the check boxes below.
</p>
");

    if (have_rug)
    {
	// help, continued
	help_text = help_text + _("<p>
<b>Synchronize Changes with ZENworks</b> will call <tt>rug</tt>
to also perform the changes in that package management system.</p>
");
    }

    Wizard::SetNextButton(`next, Label::FinishButton() );
    Wizard::SetContents(title, contents, help_text, false, true);
    Wizard::HideBackButton();

    fillTable();
    fillCurrentRepoInfo();

    symbol input = nil;

    integer current = -1;

    string url = "";

    boolean exit = false;

    repeat {

	if ( current >= 0 ) {
	    UI::ChangeWidget( `id( `table ), `CurrentItem, current );
	    fillCurrentRepoInfo ();
	}

	map event = UI::WaitForEvent();
	input	= event["ID"]:`nothing;
	y2debug( "Input: %1", input );
	if (input == `table && event["EventReason"]:"" == "Activated")
	    input	= `enable;

	symbol createResult = `again;

	if (input == `add)
	{
	    return `add;
	}
	if ( input == `next )
        {
	    if (have_rug)
	    {
		norug = ! (boolean) UI::QueryWidget (`id (`zmdsync), `Value);

		// write ZMD status if the widget is enabled
		if ((boolean)UI::QueryWidget(`id(`zmdsync), `Enabled))
		{
		    SourceManager::SetSyncFlag(!norug);
		    SourceManager::WriteSyncFlag();
		}
	    }

	  // store the new state
          boolean success = Write();
          if ( !success ) {
		// popup message part 1
                string _msg1 = _("Unable to save changes to the repository
configuration.");
                string details = Pkg::LastError();
		// popup message part 2 followed by other info
                string _msg2 = details != "" ? (_("Details:") + "\n" + details)
		    : "";
		// popup message part 3
                _msg2 = _msg2 + "\n" + _("Try again?");

                boolean tryagain = Popup::YesNo( _msg1 + "\n" + _msg2 );
                if ( !tryagain ) exit = true;
          } else {
            exit = true;
          }
        }
	// Wizard::UserInput returns `back instead of `cancel when window is closed by WM
        else if (input == `abort || input == `back)
        {
	    // no change, do not confirm exit
	    if (sourceStatesOut == sourceStatesIn)
	    {
		exit = true;
	    }
	    else
	    {
		// popup headline
		string headline = _("Abort Repository Configuration");
		// popup message
		string msg = _("Abort the repository configuration?
All changes will be lost.");
		if ( Popup::YesNoHeadline( headline, msg ) )
		{
		    exit = true;
		}
	    }
        }
        else
        {
            current = (integer) UI::QueryWidget( `id( `table ), `CurrentItem );

            y2debug( "Current item: %1", current );

            map<string, any> sourceState = sourceStatesOut[ current ]:$[];
            integer id = sourceState[ "SrcId" ]:-1;

            if ( id < 0) {
              y2internal("Unable to determine repository id, broken repository?");
              continue;
            }

            if ( input == `replace )
            {
                map generalData = Pkg::SourceGeneralData( id );
                string url = generalData[ "url" ]:"";
		string old_url = url;
		boolean auto_refresh = sourceState["autorefresh"]:true;
		boolean plaindir = generalData["type"]:"YaST" == plaindir_type;

		SourceDialogs::SetRepoName (sourceState["name"]:"");

                do {
		    // change schema if the repository type is plaindir
		    // to show the right popup dialog
		    if (plaindir)
		    {
			map parsed = URL::Parse(url);
			parsed["scheme"] = "pkg";
			url = URL::Build(parsed);
		    }
                    url = editUrl( url );

                    if ( size( url ) == 0 ) break;
		    if (url != old_url)
		    {
		      y2milestone ("URL changed, recreating the source");
		      // copy the refresh flag
                      createResult = createSource( url, sourceState["do_refresh"]:false, SourceDialogs::GetRepoName ());
                      if ( createResult == `ok ) {
			deleteSource( current );
			fillTable();
			fillCurrentRepoInfo();
                      }
		    }
		    else
		    {
			y2milestone ("URL is the same, not recreating the source");
			sourceState["name"] = SourceDialogs::GetRepoName ();
			sourceStatesOut[ current ] = sourceState;
			fillTable();
			fillCurrentRepoInfo();
			createResult = `ok;
		    }

                } while ( createResult == `again );
            }
	    else if ( input == `refresh )
            {
		Pkg::SourceRefreshNow (id);
		fillTable ();
		fillCurrentRepoInfo();
            }
            else if ( input == `delete )
            {
		// yes-no popup
                if ( Popup::YesNo( _("Delete the selected repository from the list?") ) )
                {
		     deleteSource( current );
                    fillTable();
		    fillCurrentRepoInfo();
                }
            }
            else if (input == `enable)
            {
                boolean state = sourceState[ "enabled" ]:true;
                state = !state;
		// corresponds to the "Enable/Disable" button
                string newstate = ( state ? UI::Glyph (`CheckMark) : "");
                UI::ChangeWidget( `id( `table ), `Item( current, 0 ), newstate );
                sourceState[ "enabled" ] = state;
                sourceStatesOut[ current ] = sourceState;
            }
            else if ( input == `autorefresh)
            {
		integer source_id = sourceState["SrcId"]:0;
		map src_data = Pkg::SourceGeneralData (source_id);
		string type = src_data["type"]:"UnitedLinux";
                boolean state = sourceState[ "autorefresh" ]:true;

		if (type == "PlainDir" && ! state)
		{
		    // popup message
		    Popup::Message (_("For the selected repository, refresh
cannot be set."));
		}
		else
		{
		    state = !state;
		}
		// corresponds to the "Enable/Disable" button
//                string newstate = ( state ? _("On") : _("Off") );
//                UI::ChangeWidget( `id( `table ), `Item( current, 1 ), newstate );
                sourceState["autorefresh"] = state;
                sourceStatesOut[ current ] = sourceState;
            }
/* moved to source edit dialog
	    else if (input == `set_alias)
	    {
		string src_alias = sourceState["name"]:"";

		y2internal("Current alias: %1", src_alias);

		UI::OpenDialog(
		    `MarginBox(0.4, 0.2,
			`VBox(
			    `HSpacing(40),
			    // label - text entry
			    `TextEntry(`id(`alias), `opt(`hstretch), _("Name of the Repository"), src_alias),
			    `HBox(
				`PushButton(`id(`ok), `opt(`default, `key_F10), Label::OKButton()),
				`HSpacing(1),
				`PushButton(`id(`cancel), `opt(`key_F9), Label::CancelButton())
			    )
			)
		    )
		);

		symbol ret = nil;

		do
		{
		    ret = (symbol)UI::UserInput();
		    src_alias = (string)UI::QueryWidget(`id(`alias), `Value);

		    if (ret == `ok && (src_alias == nil || src_alias == ""))
		    {
			// error popup
			Report::Error(_("The name of the repository cannot be empty."));
			ret = `again;
		    }
		}
		while (ret != `ok && ret != `cancel && ret != `close);


		UI::CloseDialog();

		if (ret == `ok)
		{
		    y2internal("New alias: %1", src_alias);

		    // refresh value in the table
		    UI::ChangeWidget( `id( `table ), `Item( current, 2 ), src_alias );

		    // remember the alias
		    sourceState["name"] = src_alias;
		    sourceStatesOut[ current ] = sourceState;
		}
	    }
*/
        }

    } until ( exit );

    y2debug( "Return: %1", input );

    return input;
}

symbol StoreSource () {
    string url = SourceDialogs::GetURL ();
    string name = SourceDialogs::GetRepoName ();

    // special case, bugzilla #238680
    if (url == "slp://")
    {
	string required_package = "yast2-slp";
	boolean installed_before = PackageSystem::Installed (required_package);

	if (! Mode::installation () && ! installed_before) {
	    // Tries to Check and Install packages
	    if (
		! PackageSystem::CheckAndInstallPackagesInteractive ([required_package]) ||
		! PackageSystem::Installed (required_package)
	    ) {
		Report::Error (sformat (
		    // popup error message, %1 is the package name
		    _("Cannot search for SLP repositories
without having %1 package installed"),
		    required_package
		));
		y2warning ("Not searching for SLP repositories");
		return `back;
	    // New .slp agent has been added
	    // FIXME: lazy loading of agents will make this obsolete
	    } else {
		SCR::RegisterAgent(.slp, `ag_slp(`SlpAgent()));
	    }
	}

	string service = (string) WFM::call("select_slp_source");

	if (service == nil) {
	    y2milestone("No SLP service selected, returning back...");
	    return `back;
	}
	else
	{
	    url = service;
	}
    }

    if (createSource(url, download_meta, name) == `again)
	return `back;
    return `next;
}

symbol TypeDialog()
{
    SourceDialogs::SetDownloadOption(true);
    map<string,any> td = SourceDialogs::TypeDialogDownloadOpt();

    symbol ret = td["ui"]:`next;
    download_meta = td["download"]:true;
    return ret;
}

symbol EditDialog()
{
    symbol ret = SourceDialogs::EditDialog ();
    return ret;
}

// main function - start the workflow
symbol StartInstSource()
{
    have_rug = (integer)SCR::Read (.target.size, "/usr/bin/rug") >= 0;
    norug = !have_rug || (size(WFM::Args()) > 0 && WFM::Args(0) == "norug");

    Wizard::CreateDialog();
    Wizard::SetDesktopIcon("sw_source");
    // dialog caption
    Wizard::SetContents(_("Initializing..."), `Empty (), "", false, true);

   // check whether running as root
   if (! Confirm::MustBeRoot () || ! PackageLock::Check ())
   {
	UI::CloseDialog ();
	return `abort;
   }

    PackageCallbacksInit::InitPackageCallbacks ();

    boolean restore = Pkg::SourceRestore();
    if( ! restore )
    {
	boolean cont = Popup::AnyQuestionRichText(
	    Label::ErrorMsg(),
	    // Error popup
	    _("<p>There were errors while restoring the repository configuration.</p>\n") + "<p>" + Pkg::LastError() + "</p>",
	    50, 15,
	    Label::ContinueButton(), Label::CancelButton(), `focus_no
	);

	// really continue?
	if (!cont) {
	    return `abort;
	}
    }

    sourceStatesIn = Pkg::SourceEditGet();
    y2milestone( "Found repositories: %1", sourceStatesIn);
    sourceStatesOut = sourceStatesIn;

    map<string,any> aliases = $[
	"summary" : ``(SummaryDialog ()),
	"type" : ``(TypeDialog()),
	"edit" : ``(EditDialog ()),
	"store" : ``(StoreSource ())
    ];

    map sequence = $[
	"ws_start" : "summary",
	"summary" : $[
	    `add : "type",
	    `edit : "edit",
	    `abort : `abort,
	    `next : `next,
	],
	"type" : $[
	    `next : "edit",
	    `finish : "store",
	    `abort : `abort,
	],
	"edit" : $[
	    `next : "store",
	    `abort : `abort,
	],
	"store" : $[
	    `next : "summary",
	    `abort : `abort,
	],
    ];

    y2milestone ("Starting repository sequence");
    symbol ret = Sequencer::Run (aliases, sequence);

    UI::CloseDialog ();
    return ret;
}

map cmdline_description = $[
    "id"	: "inst_source",
    /* Command line help text for the repository module, %1 is "zypper" */
    "help"	: sformat(_("Installation Repositories - this module doesn't support the command line interface, use '%1' instead."), "zypper"),
    "guihandler"        : StartInstSource,
];

return CommandLine::Run(cmdline_description);

} // EOF
