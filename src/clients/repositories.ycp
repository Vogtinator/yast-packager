/**
 * Module: 		repositories.ycp
 *
 * Author:		Cornelius Schumacher <cschum@suse.de>
 *			Ladislav Slezak <lslezak@suse.cz>
 *
 * Purpose:
 * Adding, removing and prioritizing of repositories for packagemanager.
 *
 * $Id$
 *
 */

{
    textdomain "packager";

    import "Confirm";
    import "Mode";
    import "Installation";
    import "PackageCallbacksInit";
    import "PackageLock";
    import "PackageSystem";
    import "Report";
    // SourceManager overlaps quite a bit with inst_source,
    // so far we only use it for ZMD sync, TODO refactor better
    import "SourceManager";
    import "Wizard";

    import "Label";
    import "Popup";
    import "AddOnProduct";
    import "Sequencer";
    import "CommandLine";
    import "Progress";
    import "Directory";
    import "URL";

    include "packager/inst_source_dialogs.ycp";
    include "packager/key_manager_dialogs.ycp";

    boolean full_mode = false;

    boolean textmode = UI::GetDisplayInfo()["TextMode"]:false;

    integer numSources = 0;

    list<map<string,any> > sourceStatesIn = [];
    list<map<string,any> > sourceStatesOut = [];
    list<integer> sourcesToDelete = [];

    // Do not sync the changes to ZENworks even if rug is present
    // This is handy for repairing an already out-of-sync situation
    boolean have_rug = nil;
    boolean norug = nil;

    // constant Plaindir
    const string plaindir_type = "Plaindir"; 

    boolean download_meta = true;

    void RemoveDeletedAddNewRepos () {
	list<map<string,any> > ret = [];

	list <integer> current_sources = Pkg::SourceGetCurrent (false);
	list <integer> known_repos = [];
	list <integer> deleted_repos = [];

	// sources deleted during this script run
	foreach (map<string,any> one_source, sourceStatesIn, {
	    integer src_id = tointeger (one_source["SrcId"]:nil);
	    if (src_id != nil) deleted_repos = add (deleted_repos, src_id);
	});

	// sources is a copy of sourceStatesOut
	foreach (map<string,any> one_source, sourceStatesOut, {
	    integer src_id = tointeger (one_source["SrcId"]:nil);

	    if (contains (current_sources, src_id)) {
		if (src_id != nil) known_repos = add (known_repos, src_id);
		ret = add (ret, one_source);
	    } else {
		y2milestone ("Source %1 has been removed already", one_source);
	    }
	});

	foreach (integer one_srcid, current_sources, {
	    // already known repository
	    if (contains (known_repos, one_srcid)) return;
	    // already deleted repository
	    if (contains (deleted_repos, one_srcid)) return;

	    // repository has been added recently (by some external functionality
	    // that doesn't use these internal variables)
	    map <string,any> generalData = Pkg::SourceGeneralData (one_srcid);
	    generalData["enabled"] = true;
	    generalData["SrcId"] = one_srcid;
	    y2milestone ("New repository found: %1", generalData);
	    ret = add (ret, generalData);
	});

	sourceStatesOut = ret;
    }

    /**
        Create a table item from a map as returned by the InstSrcManager agent.
        @param source The map describing the source as returned form the agent.
        @return An item suitable for addition to a Table.
    */
    define term createItem( integer index, map source ) ``{
        integer id = source[ "SrcId" ]:0;
        map generalData = Pkg::SourceGeneralData( id );
	y2milestone("generalData(%1): %2", id, generalData);

	string alias = haskey(sourceStatesOut[index]:$[], "name") ?
	    sourceStatesOut[index,"name"]:"" :
	    // unkown name (alias) of the source
	    generalData[ "alias" ]:generalData[ "type" ]: _("Unknown Name");

        term item = `item(
			  `id( index ),
			  // corresponds to the "Enable/Disable" button
			  source[ "enabled" ]:true ? UI::Glyph (`CheckMark) : "",
			  // translators: unknown name for a given source
			  alias,
			  generalData[ "url" ]:""
			  );
        return item;
    }

    map<string,any> getSourceInfo (integer index, map source) {
        integer id = source[ "SrcId" ]:0;
        map generalData = Pkg::SourceGeneralData( id );
	y2milestone("generalData(%1): %2", id, generalData);

	string alias = haskey(sourceStatesOut[index]:$[], "name") ?
	    sourceStatesOut[index,"name"]:"" :
	    // unkown name (alias) of the source
	    generalData[ "alias" ]:generalData[ "type" ]: _("Unknown Name");

	map<string,any> out = $[
	    "enabled" : source["enabled"]:true,
	    "autorefresh" : source["autorefresh"]:true,
	    "name" : alias,
	    "url" : generalData[ "url" ]:"",
	    "type" : generalData["type"]:"",
	];
        return out;

    }

    /**
     * Fill sources table with entries from the InstSrcManager agent.
     */
    define void fillTable() ``{
	y2milestone ("Filling repository table");
        list items = [];

	// because Online Repositories / Community Repositories don't use
	// these internal data maps
	RemoveDeletedAddNewRepos();

        numSources = size( sourceStatesOut );

        integer i = 0;
        while ( i < numSources ) {
            items = add( items, createItem( i, sourceStatesOut[ i ]:$[] ) );
            i = i + 1;
        }

        UI::ChangeWidget( `id( `table ), `Items, items );
    }

    string repoInfoRichText(string name, string raw_url, string category)
    {
	string schema  = tolower(URL::Parse(raw_url)["scheme"]:"");
	string icon_tag = "<IMG SRC=\"" + Directory::icondir + "/22x22/apps/"
	    + ((schema == "cd" || schema == "dvd" || schema == "iso") ? "yast-cd_update.png" : "yast-http-server.png")
	    + "\">&nbsp;&nbsp;&nbsp;";

	if (raw_url == "")
	{
	    raw_url = _("Unknown");
	}

	string url  = sformat (_("URL: %1"), raw_url);

	return sformat("<P>%1<B><BIG>%2</BIG></B></P><P>%3</P><P>%4</P>", icon_tag, name, url, category);
    }

    term repoInfoTerm(string name, string url, string category)
    {
	return textmode ?
	`VBox (
	     `Left(`Heading(`id(`name), `opt(`hstretch), name)),
	     `Left(`Label(`id(`url), `opt(`hstretch), url)),
	     `Left(`Label(`id(`category), `opt(`hstretch), category ))
	     )
	:
	`VSquash(`RichText(`id(`repo_info), ""));
    }

    void fillRepoInfo(integer index, map source) {
	map<string,any> info = getSourceInfo (index, source);

	// heading - in case repo name not found
	string name = info["name"]:_("Unknown repository name");

	// label to be used instead of URL if not found
	string url  = sformat (_("URL: %1"), info["url"]:_("Unknown") );

	// label, %1 is repo category (eg. YUM)
	string category = sformat (_("Category: %1"), info["type"]:_("Unknown"));

	if (textmode)
	{
	    UI::ChangeWidget(`id(`name), `Label, name);
	    UI::ChangeWidget(`id(`url), `Label, url);
	    UI::ChangeWidget(`id(`category), `Label, category);
	}
	else
	{
	    UI::ChangeWidget(`id(`repo_info), `Value, repoInfoRichText(name, info["url"]:"", category));
	}

	UI::ChangeWidget (`id (`enable), `Value, info["enabled"]:true);
	UI::ChangeWidget (`id (`autorefresh), `Value, info["autorefresh"]:true);
    }

    void fillCurrentRepoInfo () {
	integer selected = (integer)UI::QueryWidget (`id (`table), `CurrentItem);
	if (selected == nil)
	    return;
	map data = sourceStatesOut[selected]:$[];
	fillRepoInfo (selected, data);
    }

    boolean LicenseAccepted (integer id) {
	Wizard::CreateDialog ();
	boolean ret = AddOnProduct::AcceptedLicenseAndInfoFile (id);
	UI::CloseDialog ();
	return ret;
    }

    define symbol createSource( string url, boolean plaindir, boolean download, string preffered_name ) ``{
	y2milestone("createSource: %1, plaindir: %2, download: %3, name: %4", url, plaindir, download, preffered_name);

        if ( url != "" )
        {
	    // for Plaindir repository we have to use SourceCreateType() binding
	    map parsed = URL::Parse(url);
	    string scheme = parsed["scheme"]:"";

	    if (plaindir == true)
	    {
		y2milestone("Using PlainDir repository type");
	    }

	    // check if SMB/CIFS share can be mounted
	    if (scheme == "smb" && SCR::Read(.target.size, "/sbin/mount.cifs") < 0)
	    {
		y2milestone("SMB/CIFS share cannot be mounted, installing missing 'cifs-mount' package...");
		// install cifs-mount package
		PackageSystem::CheckAndInstallPackages(["cifs-mount"]);
	    }

	    list<list<string> > new_repos = Pkg::RepositoryScan(url);
	    y2internal("new_repos: %1", new_repos);

	    // add at least one product if the scan result is empty (no product info available)
	    if (size(new_repos) == 0)
	    {
		string url_path = URL::Parse(url)["path"]:"";
		list<string> p_elems = splitstring(url_path, "/");
		const string fallback = _("Repository");

		if (size(p_elems) > 1)
		{
		    url_path = p_elems[size(p_elems) - 1]:fallback;

		    if (url_path == nil || url_path == "" )
		    {
			url_path = p_elems[size(p_elems) - 2]:fallback;

			if (url_path == nil || url_path == "" )
			{
			    url_path = fallback;
			}
		    }
		}

		new_repos = [ [ url_path, "/" ] ];
	    }

            list<integer> newSources = [];
	    boolean auto_refresh = true;

	    // disable autorefresh for ISO images
	    const string iso_prefix = "iso:";
	    if (substring(url, 0, size(iso_prefix)) == iso_prefix)
	    {
		y2milestone("ISO image detected, disabling autorefresh (%1)", url);
		auto_refresh = false;
	    }

	    // CD or DVD repository?
	    boolean cd_scheme = contains(["cd", "dvd"], tolower(URL::Parse(url)["scheme"]:""));
	    if (cd_scheme)
	    {
		y2milestone("CD/DVD repository detected, disabling autorefresh (%1)", url);
		auto_refresh = false;
	    }

	    boolean enter_again = false;

	    foreach(list<string> repo, new_repos,
		{
		    if (enter_again)
			continue;

		    string name = repo[0]:"";
		    if (preffered_name != nil && preffered_name != "")
			name = preffered_name;
		    string prod_dir = repo[1]:"/";

		    // probe repository type (do not probe plaindir repo)
		    string repo_type = (plaindir) ? plaindir_type : Pkg::RepositoryProbe(url, prod_dir);

		    y2milestone("Repository type (%1,%2): %3", url, prod_dir, repo_type);

		    // the probing has failed
		    if (repo_type == nil || repo_type == "NONE")
		    {
			if (scheme == "dir")
			{
			    if (! Popup::AnyQuestion (
				Popup::NoHeadline (),
				// continue-back popup
    _("There is no product information available at the given location.
If you expected to address a product, return back and enter
the correct location.
To make rpm packages located at the specified location available
in the packages selection, continue."),
				Label::ContinueButton (),
				Label::BackButton (),
				`focus_no))
			    {
				enter_again = true;
				continue;
			    }

			    repo_type = plaindir_type;
			    y2warning("Probing has failed, using Plaindir repository type.");
			}
			else
			{
			    continue;
			}
		    }

		    string alias = name;
		    // replace " " -> "_" (avoid spaces in .repo file name)
		    alias = mergestring(splitstring(alias, " "), "_");
		    string alias_orig = alias;

		    // all current aliases
		    list<string> aliases = maplist(integer i, Pkg::SourceGetCurrent(false),
			{
			    map info = Pkg::SourceGeneralData(i);
			    return info["alias"]:"";
			}
		    );

		    // repository alias must be unique
		    // if it already exists add "_<number>" suffix to it
		    integer idx = 1;
		    while (contains(aliases, alias))
		    {
			alias = sformat("%1_%2", alias_orig, idx);
			idx = idx + 1;
		    }

		    // map with repository parameters: $[ "enabled" : boolean,
		    // "autorefresh" : boolean, "name" : string, "alias" : string,
		    // "base_urls" : list<string>, "prod_dir" : string, "type" : string ]
		    map<string,any> repo_prop = $[];

		    repo_prop["enabled"] = true;
		    repo_prop["autorefresh"] = auto_refresh;
		    repo_prop["name"] = name;
		    repo_prop["prod_dir"] = repo[1]:"/";
		    repo_prop["alias"] = alias;
		    repo_prop["base_urls"] = [ url ];
		    repo_prop["type"] = repo_type;

		    integer new_repo_id = Pkg::RepositoryAdd(repo_prop);
		    y2milestone("Added repository: %1: %2", new_repo_id, repo_prop);

		    newSources = add(newSources, new_repo_id);

		    if (cd_scheme)
		    {
			// for CD/DVD repo download the metadata immediately,
			// the medium is in the drive right now, it can be changed later
			// and accidentaly added a different repository
			y2milestone("Adding a CD or DVD repository, refreshing now...");
			Pkg::SourceRefreshNow(new_repo_id);
		    }
		}
	    );

	    // broken repository or wrong URL - enter the URL again
	    if (enter_again)
	    {
		Pkg::SourceReleaseAll();
		return `again;
	    }

            if ( size( newSources ) == 0  )
            {
		// popup message part 1
                string _msg1 = sformat( _("Unable to create repository
from URL '%1'."), url );
		// popup message part 2
                string _msg2 = _("Try again?");

                boolean tryagain = Popup::YesNo( _msg1 + "\n" + Pkg::LastError() + "\n" + _msg2 );
                if ( tryagain ) return `again;
                else return `cancel;
            }
            else
            {
                foreach( integer id, newSources, ``{
		  if (! LicenseAccepted (id))
		  {
		    Pkg::SourceDelete (id);
		  }
		  else
		  {
		    map src_data = Pkg::SourceGeneralData (id);
		    y2milestone("Addded repository: %1", src_data);

                    map<string, any> sourceState = $[ "SrcId": id, "enabled": src_data["enabled"]:true, "autorefresh" : src_data["autorefresh"]:true, "name" : src_data["name"]:"", "do_refresh" : download ];
                    sourceStatesOut = add( sourceStatesOut, sourceState );
		  }
                } );

		// relese (unmount) the medium
		Pkg::SourceReleaseAll();

                return `ok;
            }
        }
    }


    /**
     * Find which repositories have to be added or deleted to ZENworks.
     * #182992: formerly we did not consider the enabled attribute.
     * But ZENworks cannot completely disable a repository (unsubscribing a
     * repository merely decreases its priority) so we consider a disabled repository
     * like a deleted one.
     * @param statesOld sourceStates{In or Out}
     * @param statesNew sourceStates{In or Out}
     * @return the list of SrcId's that are enabled in statesNew
     *  but are not enabled in statesOld
     */
    list<integer> newSources (list<map<string,any> > statesOld,
			      list<map<string,any> > statesNew) {
	y2milestone ("From %1 To %2", statesOld, statesNew);
	list<integer> ret = [];
	map<integer, boolean> seen = listmap (
	    map<string, any> src, statesOld,
	    ``( $[(src["SrcId"]:-1) : (src["enabled"]:true) ] ));
	foreach (map<string, any> src, statesNew, {
	    integer newid = src["SrcId"]:-1;
	    boolean newena = src["enabled"]:true;
	    if (newena && ! seen[newid]:false)
		ret = add (ret, newid);
	});
	y2milestone ("Difference %1", ret);
	return ret;
    }

    define void deleteSource( integer index ) ``{
	integer srcid = sourceStatesOut[index, "SrcId"]:-1;

	if (srcid != -1) {
	    sourcesToDelete = add (sourcesToDelete, srcid);
	    SourceManager::just_removed_sources = add (SourceManager::just_removed_sources, srcid);
	}

        sourceStatesOut = remove( sourceStatesOut, index );
    }

    boolean Write() {
	y2internal("New config: %1", sourceStatesOut);
 	boolean success = Pkg::SourceEditSet( sourceStatesOut );

	// we must sync before the repositories are deleted from zypp
	// otherwise we will not get their details
	list<integer> added   = newSources (sourceStatesIn, sourceStatesOut);
	list<integer> deleted = newSources (sourceStatesOut, sourceStatesIn);
	boolean have_rug = !norug && (integer)SCR::Read (.target.size, "/usr/bin/rug") >= 0;
	boolean any_changed = added != [] || deleted != []; // #217697
	if (success && have_rug && any_changed) {
	    UI::OpenDialog (
		`VBox (
		    `Label (SourceManager::SyncLabel ()),
		    `PushButton (`id (`abort), Label::AbortButton ())
		    ));
	    boolean syncok = SourceManager::SyncAddedAndDeleted (added, deleted);
	    UI::CloseDialog ();
	    if (!syncok)
	    {
		// yes/no popup
		if (!Popup::YesNo (_("Repository synchronization with ZMD failed.
Save changes anyway?")))
		    success	= false;

	    }
	}
	else {
	    y2milestone ("No rug or ZMD sync disabled - not syncing: success: %1, have_rug: %2, any_changed: %3", success, have_rug, any_changed);
	}

	foreach( integer id, sourcesToDelete, ``{
	    success = success && Pkg::SourceDelete(id);
	});

	foreach(map<string,any> src_state, sourceStatesOut,
	    {
		if (src_state["do_refresh"]:false)
		{
		    integer srcid = src_state["SrcId"]:-1;
		    y2milestone("Downloading metadata for source %1", srcid);

		    success = success && Pkg::SourceRefreshNow(srcid);
		}
	    }
	);

	success = success && KeyManager::Write();

	// store in the persistent libzypp storage
	success = success && Pkg::SourceSaveAll(); // #176013

	return success;
   }


symbol SummaryDialog () {
    y2milestone ("Running Summary dialog");
    list items = [];

    // push button - change URL of the selected repository
    string replaceButtonLabel = _("&Replace...");
    // push button - refresh the selected repository now
    string refreshButtonLabel = _("Re&fresh Now");
    // push button - disable/enable the selected repository
    string enableButtonLabel = _("Status &On or Off");
    // push button - disable/enable automatic refresh of the selected repository
    string refreshOnOffButtonLabel = _("Refre&sh On or Off");
    // push button - set name of the selected repository
    string setAliasButtonLabel = _("Set &Name...");

    SourceManager::ReadSyncFlag();
    boolean sync_zmd = SourceManager::GetSyncFlag();
    if (sync_zmd == nil)
    {
	sync_zmd = true;
    }

    term contents =
        `VBox(
	      `HBox(
		    `Table(`id(`table),`opt(`notify, `immediate),
				// table header
			    `header( _("Enabled"),
				// table header
				_("Name"),
				// table header
				_("URL") ),
			    items ),
		    `HSpacing()
		),
		`HBox (
		       `HSpacing(0.35),
		       `HWeight (1, `Frame ("",
			       `HBox (
				      `HSpacing (1),
				      `HWeight( 1, `VBox (
					     repoInfoTerm("", "", ""),
					     // label
					     `Left (`Label (_("Properties"))),
					     // check box
					     `Left (`CheckBox (`id (`enable), `opt (`notify), _("&Enabled"))),
					     // check box
					     `Left (`CheckBox (`id (`autorefresh), `opt (`notify), _("Automatically &Refresh"))),
					     `VSpacing (0.4),
					     (have_rug) ?
					     `Left (`CheckBox (`id (`zmdsync),
							       // Checkbox label
							       _("Synchronize Changes with &ZENworks"),
							       !norug && sync_zmd))
					     : `Empty()
					     )),
				      `HSpacing (0.4)
				      )
			       )),
		       `HSpacing (1.35)
		       ),
	      `VSpacing(0.3),
	      `HBox(
		    `PushButton (`id (`add), `opt(`key_F3),
			Label::AddButton ()),
		    `PushButton(`id(`replace), `opt(`key_F4),
			Label::EditButton ()),
		    `PushButton (`id(`delete), `opt(`key_F5),
			Label::DeleteButton ()),
		    `HStretch (),
		    `PushButton (`id (`key_mgr), _("&GPG Keys...")),
		    // menu button label
		    `MenuButton (`id(`menu_button), `opt(`key_F6), _("Refresh"), [
			`item(`id(`refresh), refreshButtonLabel ),
			// menu button label
			`item(`id(`autorefresh_all), _("Refresh All Autor&efreshed")),
			// menu button label
			`item(`id(`refresh_enabled), _("Refresh All &Enabled"))
		    ])
		),
                `VSpacing( 0.5 )
        );

    // dialog caption
    string title = _("Configured Software Repositories");
//    string title = _("Media Containing the Software Repository");

    // help
    string help_text = _("<p>
In this dialog, manage configured software repositories.</p>");

    help_text = help_text + _("<p>
<b>Adding a New Repository</b><br>
To add a new repository, use <b>Add</b> and specify the software repository.
</p>");

    // help, continued
    help_text = help_text + _("<p>
To install packages from <b>CD</b>,
have the CD set or the DVD available.
</p>
");

    // help, continued
    help_text = help_text + _("<p>
The CDs can be copied to <b>hard disk</b>
and then used as a repository.
Insert the path name where the first
CD is located, for example, /data1/<b>CD1</b>.
Only the base path is required if all CDs are copied
into one directory.
</p>
");


    // help, continued
    help_text = help_text + _("<p>
<b>Modifying a Repository Status</b>
To change a repository location, use <b>Edit</b>. To remove a repository, use
<b>Delete</b>. To enable or disable the repository or to change the refresh status at initialization time, select the repository in the table and use the check boxes below.
</p>
");

    if (have_rug)
    {
	// help, continued
	help_text = help_text + _("<p>
<b>Synchronize Changes with ZENworks</b> will call <tt>rug</tt>
to also perform the changes in that package management system.</p>
");
    }

    if (full_mode)
    {
	Wizard::SetNextButton(`next, Label::OKButton() );
    }
    else
    {
	Wizard::SetNextButton(`next, Label::FinishButton() );
    }

    Wizard::SetContents(title, contents, help_text, false, true);
    Wizard::DisableBackButton();

    fillTable();
    fillCurrentRepoInfo();

    symbol input = nil;

    integer current = -1;

    string url = "";

    boolean exit = false;

    repeat {

	if ( current >= 0 ) {
	    UI::ChangeWidget( `id( `table ), `CurrentItem, current );
	    fillCurrentRepoInfo ();
	}

	map event = UI::WaitForEvent();
	input	= event["ID"]:`nothing;
	y2debug( "Input: %1", input );
	if (input == `table && event["EventReason"]:"" == "Activated")
	    input	= `enable;

	symbol createResult = `again;

	if (input == `add)
	{
	    return `add;
	}
	if ( input == `next )
        {
	    if (have_rug)
	    {
		norug = ! (boolean) UI::QueryWidget (`id (`zmdsync), `Value);

		// write ZMD status if the widget is enabled
		if ((boolean)UI::QueryWidget(`id(`zmdsync), `Enabled))
		{
		    SourceManager::SetSyncFlag(!norug);
		    SourceManager::WriteSyncFlag();
		}
	    }

	  // store the new state
          boolean success = Write();
          if ( !success ) {
		// popup message part 1
                string _msg1 = _("Unable to save changes to the repository
configuration.");
                string details = Pkg::LastError();
		// popup message part 2 followed by other info
                string _msg2 = details != "" ? (_("Details:") + "\n" + details)
		    : "";
		// popup message part 3
                _msg2 = _msg2 + "\n" + _("Try again?");

                boolean tryagain = Popup::YesNo( _msg1 + "\n" + _msg2 );
                if ( !tryagain ) exit = true;
          } else {
            exit = true;
          }
        }
	// Wizard::UserInput returns `back instead of `cancel when window is closed by WM
        else if (input == `abort || input == `cancel)
        {
	    // handle cancel as abort
	    input = `abort;

	    // no change, do not confirm exit
	    if (sourceStatesOut == sourceStatesIn)
	    {
		exit = true;
	    }
	    else
	    {
		// popup headline
		string headline = _("Abort Repository Configuration");
		// popup message
		string msg = _("Abort the repository configuration?
All changes will be lost.");
		if ( Popup::YesNoHeadline( headline, msg ) )
		{
		    exit = true;
		}
	    }
        }
	else if (input == `key_mgr)
	{
	    exit = true;
	    //return `key_mgr;
	    // start the GPG key manager
	    //RunGPGKeyMgmt();
	}
        else
        {
            current = (integer) UI::QueryWidget( `id( `table ), `CurrentItem );

            y2debug( "Current item: %1", current );

            map<string, any> sourceState = sourceStatesOut[ current ]:$[];
            integer id = sourceState[ "SrcId" ]:-1;

            if ( id < 0) {
              y2internal("Unable to determine repository id, broken repository?");
              continue;
            }

            if ( input == `replace )
            {
                map generalData = Pkg::SourceGeneralData( id );
                string url = generalData[ "url" ]:"";
		string old_url = url;
		boolean auto_refresh = sourceState["autorefresh"]:true;
		boolean plaindir = generalData["type"]:"YaST" == plaindir_type;

		SourceDialogs::SetRepoName (sourceState["name"]:"");

                do {
		    url = SourceDialogs::EditPopupType(url, plaindir);

                    if ( size( url ) == 0 ) break;
		    if (url != old_url || plaindir != SourceDialogs::IsPlainDir())
		    {
		      y2milestone ("URL or plaindir flag changed, recreating the source");
		      // copy the refresh flag
                      createResult = createSource( url, SourceDialogs::IsPlainDir(), sourceState["do_refresh"]:false, SourceDialogs::GetRepoName ());
                      if ( createResult == `ok ) {
			deleteSource( current );
			fillTable();
			fillCurrentRepoInfo();
                      }
		    }
		    else
		    {
			y2milestone ("URL is the same, not recreating the source");
			sourceState["name"] = SourceDialogs::GetRepoName ();
			sourceStatesOut[ current ] = sourceState;
			fillTable();
			fillCurrentRepoInfo();
			createResult = `ok;
		    }

                } while ( createResult == `again );
            }
	    else if ( input == `refresh )
            {
		Pkg::SourceRefreshNow (id);

		if (full_mode && sourceState["enabled"]:false)
		{
		    // force loading of the resolvables
		    Pkg::SourceSetEnabled(id, false);
		    Pkg::SourceSetEnabled(id, true);
		}
            }
	    else if ( input == `autorefresh_all || input == `refresh_enabled)
            {
		y2milestone("Refreshing all %1 repositories...", input == `refresh_enabled ? "enabled" : "autorefreshed");

		boolean refresh_autorefresh_only = input == `autorefresh_all;
		integer to_refresh = 0;

		foreach(map<string,any> src_state, sourceStatesOut,
		    {
			if (src_state["enabled"]:false && (!refresh_autorefresh_only || src_state["autorefresh"]:false))
			{
			    string url = Pkg::SourceGeneralData(src_state["SrcId"]:-1)["url"]:"";
			    string schema = tolower(substring(url, 0, 3));

			    if (schema != "cd:" && schema != "dvd")
			    {
				to_refresh = to_refresh + 1;
			    }
			}
		    }
		);

		y2milestone("%1 repositories will be refreshed", to_refresh);

		if (to_refresh > 0)
		{
		    Wizard::CreateDialog ();
		    Progress::New("Refreshing Repositories", "", to_refresh + 1, [ "Refresh Repositories" ], [], "TODO HELP");

		    foreach(map<string,any> src_state, sourceStatesOut,
			{
			    if (src_state["enabled"]:false && (!refresh_autorefresh_only || src_state["autorefresh"]:false))
			    {
				integer srcid = src_state["SrcId"]:-1;
				string name = src_state["name"]:"";

				string url = Pkg::SourceGeneralData(src_state["SrcId"]:-1)["url"]:"";
				string schema = tolower(substring(url, 0, 3));

				if (schema != "cd:" && schema != "dvd")
				{
				    y2milestone("Autorefreshing repository %1 (%2)", srcid, name);

				    // progress bar label
				    Progress::Title(sformat(_("Refreshing Repository %1..."), name));

				    Pkg::SourceRefreshNow(srcid);

				    if (full_mode && src_state["enabled"]:false)
				    {
					// force loading of the resolvables
					Pkg::SourceSetEnabled(srcid, false);
					Pkg::SourceSetEnabled(srcid, true);
				    }

				    Progress::NextStep();
				}
				else
				{
				    y2milestone("Skipping a CD/DVD repository %1 (%2)", srcid, name);
				}
			    }
			}
		    );

		    Progress::Finish();
		    Wizard::CloseDialog();
		}
            }
            else if ( input == `delete )
            {
		// yes-no popup
                if ( Popup::YesNo( _("Delete the selected repository from the list?") ) )
                {
		     deleteSource( current );
                    fillTable();
		    fillCurrentRepoInfo();
                }
            }
            else if (input == `enable)
            {
                boolean state = sourceState[ "enabled" ]:true;
                state = !state;
		// corresponds to the "Enable/Disable" button
                string newstate = ( state ? UI::Glyph (`CheckMark) : "");
                UI::ChangeWidget( `id( `table ), `Item( current, 0 ), newstate );
                sourceState[ "enabled" ] = state;
                sourceStatesOut[ current ] = sourceState;

		if (full_mode)
		{
		    Pkg::SourceSetEnabled(sourceState["SrcId"]:-1, state);
		}
            }
            else if ( input == `autorefresh)
            {
		integer source_id = sourceState["SrcId"]:0;
		map src_data = Pkg::SourceGeneralData (source_id);
		string type = src_data["type"]:"UnitedLinux";
                boolean state = sourceState[ "autorefresh" ]:true;

		if (type == "PlainDir" && ! state)
		{
		    // popup message
		    Popup::Message (_("For the selected repository, refresh
cannot be set."));
		}
		else
		{
		    state = !state;
		}
                sourceState["autorefresh"] = state;
                sourceStatesOut[ current ] = sourceState;
            }
        }

    } until ( exit );

    y2debug( "Return: %1", input );

    return input;
}

symbol StoreSource () {
    string url = SourceDialogs::GetURL ();
    string name = SourceDialogs::GetRepoName ();
    boolean plaindir = SourceDialogs::IsPlainDir();

    // special case, bugzilla #238680
    if (url == "slp://")
    {
	string required_package = "yast2-slp";
	boolean installed_before = PackageSystem::Installed (required_package);

	if (! Mode::installation () && ! installed_before) {
	    // Tries to Check and Install packages
	    if (
		! PackageSystem::CheckAndInstallPackagesInteractive ([required_package]) ||
		! PackageSystem::Installed (required_package)
	    ) {
		Report::Error (sformat (
		    // popup error message, %1 is the package name
		    _("Cannot search for SLP repositories
without having %1 package installed"),
		    required_package
		));
		y2warning ("Not searching for SLP repositories");
		return `back;
	    // New .slp agent has been added
	    // FIXME: lazy loading of agents will make this obsolete
	    } else {
		SCR::RegisterAgent(.slp, `ag_slp(`SlpAgent()));
	    }
	}

	string service = (string) WFM::call("select_slp_source");

	if (service == nil) {
	    y2milestone("No SLP service selected, returning back...");
	    return `back;
	}
	else
	{
	    url = service;
	}
    }
    else if (url == "commrepos://")
    {
	any commrepos = WFM::call ("inst_productsources", [$["skip_already_used_repos":true]]);
	y2milestone ("Community Repositories returned: %1", commrepos);

	return `next;
    }

    if (createSource(url, plaindir, download_meta, name) == `again)
	return `back;
    return `next;
}

symbol TypeDialog()
{
    SourceDialogs::SetDownloadOption(true);
    map<string,any> td = SourceDialogs::TypeDialogDownloadOpt();

    symbol ret = td["ui"]:`next;
    download_meta = td["download"]:true;
    return ret;
}

symbol EditDialog()
{
    symbol ret = SourceDialogs::EditDialog ();
    return ret;
}

// main function - start the workflow
symbol StartInstSource()
{
    have_rug = (integer)SCR::Read (.target.size, "/usr/bin/rug") >= 0;
    norug = !have_rug || (size(WFM::Args()) > 0 && WFM::Args(0) == "norug");

    Wizard::CreateDialog();
    Wizard::SetDesktopIcon("sw_source");
    // dialog caption
    Wizard::SetContents(_("Initializing..."), `Empty (), "", false, true);

   // check whether running as root
   if (! Confirm::MustBeRoot () || ! PackageLock::Check ())
   {
	UI::CloseDialog ();
	return `abort;
   }

    PackageCallbacksInit::InitPackageCallbacks ();

    boolean restore = Pkg::SourceRestore();
    if( ! restore )
    {
	boolean cont = Popup::AnyQuestionRichText(
	    Label::ErrorMsg(),
	    // Error popup
	    _("<p>There were errors while restoring the repository configuration.</p>\n") + "<p>" + Pkg::LastError() + "</p>",
	    50, 15,
	    Label::ContinueButton(), Label::CancelButton(), `focus_no
	);

	// really continue?
	if (!cont) {
	    return `abort;
	}
    }

    // read known GPG keys
    KeyManager::Read();

    sourceStatesIn = Pkg::SourceEditGet();
    y2milestone( "Found repositories: %1", sourceStatesIn);
    sourceStatesOut = sourceStatesIn;

    map<string,any> aliases = $[
	"summary" : ``(SummaryDialog ()),
	"type" : ``(TypeDialog()),
	"edit" : ``(EditDialog ()),
	"store" : ``(StoreSource ()),
	"keymgr" : [``(RunGPGKeyMgmt(false)), true]
    ];

    map sequence = $[
	"ws_start" : "summary",
	"summary" : $[
	    `add : "type",
	    `edit : "edit",
	    `key_mgr : "keymgr",
	    `abort : `abort,
	    `next : `next,
	],
	"keymgr" : $[
	    `next : "summary",
	    `abort : "summary"
	],
	"type" : $[
	    `next : "edit",
	    `finish : "store",
	    `abort : `abort,
	],
	"edit" : $[
	    `next : "store",
	    `abort : `abort,
	],
	"store" : $[
	    `next : "summary",
	    `abort : `abort,
	],
    ];

    y2milestone ("Starting repository sequence");
    symbol ret = Sequencer::Run (aliases, sequence);

    UI::CloseDialog ();
    return ret;
}

map cmdline_description = $[
    "id"	: "inst_source",
    /* Command line help text for the repository module, %1 is "zypper" */
    "help"	: sformat(_("Installation Repositories - this module doesn't support the command line interface, use '%1' instead."), "zypper"),
    "guihandler"        : StartInstSource,
];

if (WFM::Args() == [ `sw_single_mode ])
{
    y2internal("Started from sw_single, switching the mode");

    full_mode = true;
    boolean progress_state = Progress::set(false);
    any ret = StartInstSource();

    // load objects from the new repositories
    Pkg::SourceLoad();
    Progress::set(progress_state);

    return ret;
}
else
{
    y2milestone("Initializing the target...");
    Pkg::TargetInit("/", true);
}

return CommandLine::Run(cmdline_description);

} // EOF
