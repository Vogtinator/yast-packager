/**
 * Module: 		inst_source.ycp
 *
 * Author:		Cornelius Schumacher <cschum@suse.de>
 *
 * Purpose:
 * Adding, removing and prioritizing of repositories for packagemanager.
 *
 * $Id$
 *
 */

{
    textdomain "packager";

    import "Confirm";
    import "Mode";
    import "Installation";
    import "PackageCallbacksInit";
    import "PackageLock";
    import "PackageSystem";
    import "Report";
    import "Stage";
    // SourceManager overlaps quite a bit with inst_source,
    // so far we only use it for ZMD sync, TODO refactor better
    import "SourceManager";
    import "SuSEFirewall";
    import "Wizard";

    import "Label";
    import "Popup";
    import "AddOnProduct";
    import "Sequencer";
    import "CommandLine";
    // constructor of Product is needed in order to initialize the product
    // macro. Takes a lot of time because whole package manager target
    // is initialized
    import "Product";

    include "packager/inst_source_dialogs.ycp";

    integer numSources = 0;

    list<map<string,any> > sourceStatesIn = [];
    list<map<string,any> > sourceStatesOut = [];
    list<integer> sourcesToDelete = [];

    // Do not sync the changes to ZENworks even if rug is present
    // This is handy for repairing an already out-of-sync situation
    boolean have_rug = nil;
    boolean norug = nil;

    // constant Plaindir
    const string plaindir_type = "Plaindir"; 


    /**
        Create a table item from a map as returned by the InstSrcManager agent.
        @param source The map describing the source as returned form the agent.
        @return An item suitable for addition to a Table.
    */
    define term createItem( integer index, map source ) ``{
        integer id = source[ "SrcId" ]:0;
        map generalData = Pkg::SourceGeneralData( id );
        map productData = Pkg::SourceProductData( id );
	y2milestone("generalData: %1", generalData);
	y2milestone("productData: %1", productData);

	string alias = haskey(sourceStatesOut[index]:$[], "name") ?
	    sourceStatesOut[index,"name"]:"" :
	    // unkown name (alias) of the source
	    generalData[ "alias" ]:productData["label"]:generalData[ "type" ]: _("Unknown Name");

        term item = `item(
			  `id( index ),
			  // corresponds to the "Enable/Disable" button
			  source[ "enabled" ]:true ? _("On") : _("Off"),
			  source["autorefresh"]:true ? _("On") : _("Off"),
			  // translators: unknown name for a given source
			  alias,
			  generalData[ "url" ]:""
			  );
        return item;
    }

    /**
     * Fill sources table with entries from the InstSrcManager agent.
     */
    define void fillTable() ``{
	y2milestone ("Filling repository table");
        list items = [];

        numSources = size( sourceStatesOut );

        integer i = 0;
        while ( i < numSources ) {
            items = add( items, createItem( i, sourceStatesOut[ i ]:$[] ) );
            i = i + 1;
        }

        UI::ChangeWidget( `id( `table ), `Items, items );
    }

    boolean LicenseAccepted (integer id) {
	Wizard::CreateDialog ();
	boolean ret = AddOnProduct::AcceptedLicenseAndInfoFile (id);
	UI::CloseDialog ();
	return ret;
    }

    define symbol createSource( string url ) ``{
	y2milestone("createSource: %1", url);

        if ( url != "" )
        {
	    // for Plaindir repository we have to use SourceCreateType() binding
	    boolean plaindir = false;
	    map parsed = URL::Parse(url);
	    string scheme = parsed["scheme"]:"";

	    if (scheme == "pkg")
	    {
		parsed["scheme"] = "dir";
		url = URL::Build(parsed);
		plaindir = true;
	    }

	    // check if SMB/CIFS share can be mounted
	    if (scheme == "smb" && SCR::Read(.target.size, "/sbin/mount.cifs") < 0)
	    {
		y2milestone("SMB/CIFS share cannot be mounted, installing missing 'cifs-mount' package...");
		// install cifs-mount package
		PackageSystem::CheckAndInstallPackages(["cifs-mount"]);
	    }

            list<integer> newSources = (plaindir) ?
		[ Pkg::SourceCreateType(url, "", plaindir_type) ] :
		Pkg::SourceScan( url, "" );

            if ( size( newSources ) == 0  )
            {
		// message part 1
                string _msg1 = sformat( _("Unable to create repository
from URL '%1'."), url );
		/* FIXME Pkg::LastErrorId always returns 'ok'
                string err = Pkg::LastErrorId();
                if ( err != "ok" ) {
                    if ( err == "instsrc_duplicate" )
			// message part 2 alt. 1
                        _msg2 = _("A repository for this product already exists.");
                    else
                }
		*/
		// message part 2 alt. 2 followed by description
                string _msg2 = _("Details:") + "\n" + Pkg::LastError() + "\n" +
		    // message part 3
		    _("Try again?");

                boolean tryagain = Popup::YesNo( _msg1 + "\n" + _msg2 );
                if ( tryagain ) return `again;
                else return `cancel;
            }
            else
            {
		list<integer> prod_sources = filter (integer s, newSources, {
		    map src_data = Pkg::SourceGeneralData (s);
		    string src_type = src_data["type"]:"";
		    return (src_type == "YaST" || src_type == "YUM" || src_type == plaindir_type);
		});
		if (size (prod_sources) == 0)
		{
		    if (! Popup::AnyQuestion (
			Popup::NoHeadline (),
// continue-back popup
_("There is no product information available at the given location.
If you expected to address a product, return back and enter
the correct location.
To make rpm packages located at the specified location available
in the packages selection, continue."),
			Label::ContinueButton (),
			Label::BackButton (),
			`focus_yes))
		    {
			return `again;
		    }
		}
                foreach( integer id, newSources, ``{
		  if (! LicenseAccepted (id))
		  {
		    Pkg::SourceDelete (id);
		  }
		  else
		  {
		    map src_data = Pkg::SourceGeneralData (id);
		    boolean auto_refresh = src_data["autorefresh"]:false;

		    // disable autorefresh for ISO images
		    string src_url = src_data["url"]:"";
		    if (substring(src_url, 0, 3) == "iso")
		    {
			y2milestone("ISO image detected, disabling autorefresh (%1)", src_url);
			auto_refresh = false;
		    }

                    map<string, any> sourceState = $[ "SrcId": id, "enabled": true, "autorefresh" : auto_refresh, "name" : src_data["name"]:"" ];
                    sourceStatesOut = add( sourceStatesOut, sourceState ); 
		  }
                } );
                return `ok;
            }
        }
    }

    /**
     * Find which repositories have to be added or deleted to ZENworks.
     * #182992: formerly we did not consider the enabled attribute.
     * But ZENworks cannot completely disable a repository (unsubscribing a
     * repository merely decreases its priority) so we consider a disabled repository
     * like a deleted one.
     * @param statesOld sourceStates{In or Out}
     * @param statesNew sourceStates{In or Out}
     * @return the list of SrcId's that are enabled in statesNew
     *  but are not enabled in statesOld
     */
    list<integer> newSources (list<map<string,any> > statesOld,
			      list<map<string,any> > statesNew) {
	y2milestone ("From %1 To %2", statesOld, statesNew);
	list<integer> ret = [];
	map<integer, boolean> seen = listmap (
	    map<string, any> src, statesOld,
	    ``( $[(src["SrcId"]:-1) : (src["enabled"]:true) ] ));
	foreach (map<string, any> src, statesNew, {
	    integer newid = src["SrcId"]:-1;
	    boolean newena = src["enabled"]:true;
	    if (newena && ! seen[newid]:false)
		ret = add (ret, newid);
	});
	y2milestone ("Difference %1", ret);
	return ret;
    }

    define void deleteSource( integer index ) ``{
	integer srcid = sourceStatesOut[index, "SrcId"]:-1;

	if( srcid != -1)
		sourcesToDelete = add( sourcesToDelete, srcid );

        sourceStatesOut = remove( sourceStatesOut, index );
    }

    boolean Write() {
	y2internal("New config: %1", sourceStatesOut);
 	boolean success = Pkg::SourceEditSet( sourceStatesOut );

	// we must sync before the repositories are deleted from zypp
	// otherwise we will not get their details
	list<integer> added   = newSources (sourceStatesIn, sourceStatesOut);
	list<integer> deleted = newSources (sourceStatesOut, sourceStatesIn);
	boolean have_rug = !norug && (integer)SCR::Read (.target.size, "/usr/bin/rug") >= 0;
	boolean any_changed = added != [] || deleted != []; // #217697
	if (success && have_rug && any_changed) {
	    UI::OpenDialog (
		`VBox (
		    `Label (SourceManager::SyncLabel ()),
		    `PushButton (`id (`abort), Label::AbortButton ())
		    ));
	    boolean syncok = SourceManager::SyncAddedAndDeleted (added, deleted);
	    UI::CloseDialog ();
	    if (!syncok)
	    {
		// yes/no popup
		if (!Popup::YesNo (_("Repository synchronization with ZMD failed.
Save changes anyway?")))
		    success	= false;

	    }
	}
	else {
	    y2milestone ("No rug or ZMD sync disabled - not syncing: success: %1, have_rug: %2, any_changed: %3", success, have_rug, any_changed);
	}

	foreach( integer id, sourcesToDelete, ``{
	    success = success && Pkg::SourceDelete(id);
	});

	// store in the persistent libzypp storage
	success = success && Pkg::SourceSaveAll(); // #176013

	return success;
   }


symbol SummaryDialog () {
    y2milestone ("Running Summary dialog");
    list items = [];

    // push button - change URL of the selected repository
    string replaceButtonLabel = _("&Replace...");
    // push button - refresh the selected repository now
    string refreshButtonLabel = _("Re&fresh Now");
    // push button - disable/enable the selected repository
    string enableButtonLabel = _("Status &On or Off");
    // push button - disable/enable automatic refresh of the selected repository
    string refreshOnOffButtonLabel = _("Refre&sh On or Off");
    // push button - set name of the selected repository
    string setAliasButtonLabel = _("Set &Name...");

    SourceManager::ReadSyncFlag();
    boolean sync_zmd = SourceManager::GetSyncFlag();
    if (sync_zmd == nil)
    {
	sync_zmd = true;
    }

    term contents =
        `VBox(
	      `HBox(
		    `Table(`id(`table),`opt(`notify, `immediate),
				// table header
			    `header( _("Status"),
				// table header
				_("Refresh"),
				// table header
				_("Name"),
				// table header
				_("URL") ),
			    items ),
		    `HSpacing()
		    ),
	      // TODO Help
	      `Left (`CheckBox (`id (`zmdsync),
				// Checkbox label
				_("Synchronize Changes with &ZENworks"),
				!norug && sync_zmd)),
	      `HBox(
		    `PushButton (`id (`add), `opt(`key_F3),
			Label::AddButton ()),
		    `PushButton(`id(`replace), `opt(`key_F4),
			Label::EditButton ()),
		    `PushButton (`id(`delete), `opt(`key_F5),
			Label::DeleteButton ()),
		    `HStretch (),
		    // menu button label
		    `MenuButton (`id(`menu_button), `opt(`key_F6), _("Repository Settings"), [
			`item(`id(`enable), enableButtonLabel),
			`item(`id(`refresh_on_off), refreshOnOffButtonLabel),
			`item(`id(`refresh), refreshButtonLabel ),
			`item(`id(`set_alias), setAliasButtonLabel)
		    ])
		),
                `VSpacing( 0.5 )
        );

    // dialog caption
    string title = _("Configured Software Repositories");
//    string title = _("Media Containing the Software Repository");

    // help
    string help_text = _("<p>
In this dialog, manage configured software repositories.</p>");

    help_text = help_text + _("<p>
<b>Adding a New Repository</b><br>
To add a new repository, use <b>Add</b> and specify the software repository.
</p>");

    // help, continued
    help_text = help_text + _("<p>
To install packages from <b>CD</b>,
have the CD set or the DVD available.
</p>
");

    // help, continued
    help_text = help_text + _("<p>
The CDs can be copied to the <b>hard disk</b>
Then use that as the repository.
Insert the path name where the first
CD is located, for example, /data1/<b>CD1</b>.
Only the base path is required if all CDs are copied
into one directory.
</p>
");

    // help, continued
    help_text = help_text + _("<p>
<b>Network</b> installation requires a working network connection.
Configure YaST2's \"Network Devices\" module first,
if required.  Specify the directory where the packages from
the first CD are located, such as /data1/CD1.
Only the base path is
required if packages are in one directory, for example, /usr/full-i386.
</p>
");

    // help, continued
    help_text = help_text + _("<p>
<b>Modifying a Repository</b>
To change a repository media, use <b>Edit</b>. To remove a repository, use
<b>Delete</b>. To enable or disable the repository, set refreshing on the
initialization time on or off, immediate refreshing or renaming the repository, use 
<b>Repository Settings</b>.</p>");

    // help, continued
    help_text = help_text + _("<p>
<b>Synchronize Changes with ZENworks</b> will call <tt>rug</tt>
to perform the changes also in that package management system.</p>");

    Wizard::SetNextButton(`next, Label::FinishButton() );
    Wizard::SetContents(title, contents, help_text, false, true);
    Wizard::HideBackButton();
    UI::ChangeWidget (`id (`zmdsync), `Enabled, have_rug);

    fillTable();

    symbol input = nil;

    integer current = -1;

    string url = "";

    boolean exit = false;

    repeat {

	if ( current >= 0 ) {
	    UI::ChangeWidget( `id( `table ), `CurrentItem, current );
	}

	input = (symbol)Wizard::UserInput();
	y2debug( "Input: %1", input );

	symbol createResult = `again;

	if (input == `add)
	{
	    return `add;
	}
	if ( input == `next )
        {
	  norug = ! (boolean) UI::QueryWidget (`id (`zmdsync), `Value);

	  // write ZMD status if the widget is enabled
	  if ((boolean)UI::QueryWidget(`id(`zmdsync), `Enabled))
	  {
	    SourceManager::SetSyncFlag(!norug);
	    SourceManager::WriteSyncFlag();
	  }

	  // store the new state
          boolean success = Write();
          if ( !success ) {
		// popup message part 1
                string _msg1 = _("Unable to save changes to repository
configuration.");
                string details = Pkg::LastError();
		// popup message part 2 followed by other info
                string _msg2 = details != "" ? (_("Details:") + "\n" + details)
		    : "";
		// popup message part 3
                _msg2 = _msg2 + "\n" + _("Try again?");

                boolean tryagain = Popup::YesNo( _msg1 + "\n" + _msg2 );
                if ( !tryagain ) exit = true;
          } else {
            exit = true;
          }
        }
	// Wizard::UserInput returns `back instead of `cancel when window is closed by WM
        else if (input == `abort || input == `back)
        {
	  // popup headline
          string headline = _("Abort Repository Configuration");
	  // popup message
          string msg = _("Abort the repository configuration?
All changes will be lost.");
          if ( Popup::YesNoHeadline( headline, msg ) ) {
            exit = true;
          }
        }
        else
        {
            current = (integer) UI::QueryWidget( `id( `table ), `CurrentItem );

            y2debug( "Current item: %1", current );

            map<string, any> sourceState = sourceStatesOut[ current ]:$[];
            integer id = sourceState[ "SrcId" ]:-1;

            if ( id < 0) {
              y2internal("Unable to determine repository id, broken repository?");
              continue;
            }

            if ( input == `replace )
            {
                map generalData = Pkg::SourceGeneralData( id );
                string url = generalData[ "url" ]:"";
		boolean auto_refresh = sourceState["autorefresh"]:true;
		boolean plaindir = generalData["type"]:"YaST" == plaindir_type;

                do {
		    // change schema if the repository type is plaindir
		    // to show the right popup dialog
		    if (plaindir)
		    {
			map parsed = URL::Parse(url);
			parsed["scheme"] = "pkg";
			url = URL::Build(parsed);
		    }

                    url = editUrl( url );

                    if ( size( url ) == 0 ) break;
                    createResult = createSource( url );
                    if ( createResult == `ok ) {
			deleteSource( current );
			fillTable();
                    }
                } while ( createResult == `again );
            }
	    else if ( input == `refresh )
            {
		Pkg::SourceRefreshNow (id);
		fillTable ();
            }
            else if ( input == `delete )
            {
		// yes-no popup
                if ( Popup::YesNo( _("Delete the selected repository from the list?") ) )
                {
		     deleteSource( current );
                    fillTable();
                }
            }
            else if ( input == `enable )
            {
                boolean state = sourceState[ "enabled" ]:true;
                state = !state;
		// corresponds to the "Enable/Disable" button
                string newstate = ( state ? _("On") : _("Off") );
                UI::ChangeWidget( `id( `table ), `Item( current, 0 ), newstate );
                sourceState[ "enabled" ] = state;
                sourceStatesOut[ current ] = sourceState;
            }
            else if ( input == `refresh_on_off )
            {
		integer source_id = sourceState["SrcId"]:0;
		map src_data = Pkg::SourceGeneralData (source_id);
		string type = src_data["type"]:"UnitedLinux";
                boolean state = sourceState[ "autorefresh" ]:true;

		if (type == "PlainDir" && ! state)
		{
		    // popup message
		    Popup::Message (_("For the selected repository, refresh
cannot be set."));
		}
		else
		{
		    state = !state;
		}
		// corresponds to the "Enable/Disable" button
                string newstate = ( state ? _("On") : _("Off") );
                UI::ChangeWidget( `id( `table ), `Item( current, 1 ), newstate );
                sourceState["autorefresh"] = state;
                sourceStatesOut[ current ] = sourceState;
            }
	    else if (input == `set_alias)
	    {
		string src_alias = sourceState["name"]:"";

		y2internal("Current alias: %1", src_alias);

		UI::OpenDialog(
		    `MarginBox(0.4, 0.2,
			`VBox(
			    `HSpacing(40),
			    // label - text entry
			    `TextEntry(`id(`alias), `opt(`hstretch), _("Name of the Repository"), src_alias),
			    `HBox(
				`PushButton(`id(`ok), `opt(`default, `key_F10), Label::OKButton()),
				`HSpacing(1),
				`PushButton(`id(`cancel), `opt(`key_F9), Label::CancelButton())
			    )
			)
		    )
		);

		symbol ret = nil;

		do
		{
		    ret = (symbol)UI::UserInput();
		    src_alias = (string)UI::QueryWidget(`id(`alias), `Value);

		    if (ret == `ok && (src_alias == nil || src_alias == ""))
		    {
			// error popup
			Report::Error(_("Name of the repository cannot be empty."));
			ret = `again;
		    }
		}
		while (ret != `ok && ret != `cancel && ret != `close);


		UI::CloseDialog();

		if (ret == `ok)
		{
		    y2internal("New alias: %1", src_alias);

		    // refresh value in the table
		    UI::ChangeWidget( `id( `table ), `Item( current, 2 ), src_alias );

		    // remember the alias
		    sourceState["name"] = src_alias;
		    sourceStatesOut[ current ] = sourceState;
		}
	    }
        }

    } until ( exit );

    y2debug( "Return: %1", input );

    return input;
}

symbol StoreSource () {
    string url = SourceDialogs::GetURL ();

    // special case, bugzilla #238680
    if (url == "slp://")
    {
	string required_package = "yast2-slp";
	boolean installed_before = PackageSystem::Installed (required_package);

	if (! Mode::installation () && ! installed_before) {
	    // Tries to Check and Install packages
	    if (
		! PackageSystem::CheckAndInstallPackagesInteractive ([required_package]) ||
		! PackageSystem::Installed (required_package)
	    ) {
		Report::Error (sformat (
		    // popup error message, %1 is the package name
		    _("Cannot search for SLP repositories
without having %1 package installed"),
		    required_package
		));
		y2warning ("Not searching for SLP repositories");
		return `back;
	    // New .slp agent has been added
	    // FIXME: lazy loading of agents will make this obsolete
	    } else {
		SCR::RegisterAgent(.slp, `ag_slp(`SlpAgent()));
	    }
	}

	string service = (string) WFM::call("select_slp_source");

	if (service == nil) {
	    y2milestone("No SLP service selected, returning back...");
	    return `back;
	}
	else
	{
	    url = service;
	}
    }

    if (createSource(url) == `again)
	return `back;
    return `next;
}

// main function - start the workflow
symbol StartInstSource()
{
    have_rug = (integer)SCR::Read (.target.size, "/usr/bin/rug") >= 0;
    norug = !have_rug || (size(WFM::Args()) > 0 && WFM::Args(0) == "norug");

    Wizard::CreateDialog();
    Wizard::SetDesktopIcon("sw_source");
    // dialog caption
    Wizard::SetContents(_("Initializing..."), `Empty (), "", false, true);

   // check whether running as root
   if (! Confirm::MustBeRoot () || ! PackageLock::Check ())
   {
	UI::CloseDialog ();
	return `abort;
   }

    PackageCallbacksInit::InitPackageCallbacks ();

    boolean restore = Pkg::SourceRestore();
    if( ! restore )
    {
	boolean cont = Popup::AnyQuestionRichText(
	    Label::ErrorMsg(),
	    // Error popup
	    _("<p>There were errors when restoring the repository configuration.</p>
") + "<p>" + Pkg::LastError() + "</p>",
	    50, 15,
	    Label::ContinueButton(), Label::CancelButton(), `focus_no
	);

	// really continue?
	if (!cont) {
	    return `abort;
	}
    }

    sourceStatesIn = Pkg::SourceEditGet();
    y2milestone( "Found repositories: %1", sourceStatesIn);
    sourceStatesOut = sourceStatesIn;

    map<string,any> aliases = $[
	"summary" : ``(SummaryDialog ()),
	"type" : ``(SourceDialogs::TypeDialog ()),
	"edit" : ``(SourceDialogs::EditDialog ()),
	"store" : ``(StoreSource ())
    ];

    map sequence = $[
	"ws_start" : "summary",
	"summary" : $[
	    `add : "type",
	    `edit : "edit",
	    `abort : `abort,
	    `next : `next,
	],
	"type" : $[
	    `next : "edit",
	    `finish : "store",
	    `abort : `abort,
	],
	"edit" : $[
	    `next : "store",
	    `abort : `abort,
	],
	"store" : $[
	    `next : "summary",
	    `abort : `abort,
	],
    ];

    y2milestone ("Starting repository sequence");
    symbol ret = Sequencer::Run (aliases, sequence);

    UI::CloseDialog ();
    return ret;
}

map cmdline_description = $[
    "id"	: "inst_source",
    /* Command line help text for the repository module, %1 is "zypper" */
    "help"	: sformat(_("Installation Repositories - this module doesn't support command line interface, use '%1' instead."), "zypper"),
    "guihandler"        : StartInstSource,
];

return CommandLine::Run(cmdline_description);

} // EOF
