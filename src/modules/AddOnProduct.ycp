/**
 * File:
 *	AddOnProduct.ycp
 *
 * Module:
 *	AddOnProduct
 *
 * Summary:
 *	This module provides integration of the add-on products
 *
 * Authors:
 *	Jiri Srain <jsrain@suse.de>
 *	Lukas Ocilka <locilka@suse.cz>
 */

{
module "AddOnProduct";

// IMPORTANT: maintainer of yast2-add-on is responsible for this module

textdomain "packager";

import "Label";
import "Mode";
import "ProductControl";
import "ProductFeatures";
import "Report";
import "XML";
import "Wizard";
import "FileUtils";
import "Language";
import "Popup";
import "InstShowInfo";
import "ProductLicense";
import "FileUtils";
import "Directory";
import "String";
import "WorkflowManager";

// variables for installation with product
/**
 * ID for cache in the inst-sys
 */
integer src_cache_id = -1;

/**
 * System proposals have already been prepared for merging?
 */
boolean system_proposals_prepared = false;

/**
 * System workflows have already been prepared for merging?
 */
boolean system_workflows_prepared = false;

/**
 * List of all selected sources
 *
 * @struct add_on_products = [
 *   $[
 *     "media" : 4, // ID of the source
 *     "product_dir" : "/",
 *     "product" : "openSUSE version XX.Y",
 *   ],
 *   ...
 * ]
 */
global list<map<string,any> > add_on_products = [];

/**
 * ID of currently added source for the add-on product
 */
global integer src_id  = nil;

// for the add-on product workflow - needed for dialog skipping
/**
 * return value of last step in the product adding workflow
 */
global symbol last_ret = nil;

global boolean modified = false;

global list <integer> mode_config_sources = [];

/**
 * Adapts the inst-sys from the tarball
 * @param filename string the filename with the tarball to use to the update
 * @return boolean true on success
 */
global boolean UpdateInstSys (string filename) {
    src_cache_id = src_cache_id + 1;
    string tmpdir = (string)SCR::Read (.target.tmpdir);
    tmpdir = sformat ("%1/%2", tmpdir, src_cache_id);
    map out = (map)SCR::Execute (.target.bash_output, sformat ("
/bin/mkdir %1;
cd %1;
/bin/tar -xvf %2;
/sbin/adddir %1 /;
", tmpdir, filename));
    if (out["exit"]:0 != 0)
    {
	y2error ("Including installation image failed: %1", out);
	return false;
    }
    y2milestone ("Including installation image succeeded");
    return true;
}

/**
 * New add-on product might add also new agents.
 * Functions Rereads all available agents.
 *
 * @see bugzilla #239055, #245508
 */
global void RereadAllSCRAgents () {
    y2milestone ("Registering new agents...");
    boolean ret = (boolean) SCR::RegisterNewAgents();

    if (ret) {
	y2milestone ("Successful");
    } else {
	y2error ("Error occured during registering new agents!");
	Report::Error (_("An error occurred while preparing the installation system."));
    }
}

/**
 * Remove the /y2update directory from the system
 */
void CleanY2Update() {
    SCR::Execute (.target.bash, "/bin/rm -rf /y2update");
}

/**
 * Show /media.1/info.txt file in a pop-up message if such file exists.
 * Show license if such exists and return whether users accepts it.
 * Returns 'nil' when did not succed.
 *
 * @return boolean whether the license has been accepted
 */
global boolean AcceptedLicenseAndInfoFile (integer src_id) {
    symbol ret = ProductLicense::AskAddOnLicenseAgreement (src_id);
    if (ret == nil)
	return nil;
    else if (ret == `abort || ret == `back)
    {
	y2milestone ("License confirmation failed");
	return false;
    }
    return true;
}

symbol DoInstall_NoControlFile () {
    y2milestone("File /installation.xml not found, running sw_single for this source");
    WFM::CallFunction ("sw_single", []);

    return `register;
}

boolean IntegrateY2Update (integer src_id) {
    string binaries = Pkg::SourceProvideOptionalFile (src_id, 1, "/y2update.tgz");
    // File /y2update.tgz exists
    if (binaries != nil)
    {
	// Try to extract files from the archive
	map out = (map)SCR::Execute (.target.bash_output, sformat ("
test -d /y2update && rm -rf /y2update;
/bin/mkdir -p /y2update/all;
cd /y2update/all;
/bin/tar -xvf %1;
cd /y2update;
ln -s all/usr/share/YaST2/* .;
ln -s all/usr/lib/YaST2/* .;
", binaries));

	// Failed
	if (out["exit"]:0 != 0)
	{
	    // error report
	    Report::Error (_("An error occurred while preparing the installation system."));
	    CleanY2Update();
	    return false;
	} else {
	    // bugzilla #239055
	    RereadAllSCRAgents();
	}
    }
    else
    {
	y2milestone("File /y2update.tgz not provided");
    }

    return true;
}

symbol DoInstall_WithControlFile (string control) {
    y2milestone ("File /installation.xml was found, running own workflow...");
    // copy the control file to local filesystem - in case of media release
    string tmp = (string)SCR::Read (.target.tmpdir);
    tmp = tmp + "/installation.xml";
    SCR::Execute (.target.bash, sformat ("/bin/cp %1 %2", control, tmp));
    control = tmp;

    if (! IntegrateY2Update (src_id)) return nil;

    // set control file
    ProductControl::custom_control_file = control;
    if (!ProductControl::Init())
    {
	// error report
	Report::Error (sformat (_("Control file %1 not found on media."),
	    control));
	CleanY2Update();
	return nil;
    }

    // start workflow
    Wizard::OpenNextBackStepsDialog();
    // dialog caption
    Wizard::SetContents(_("Initializing..."), `Empty (), "", false, false);

    list<map> stage_mode = [$["stage": "normal",  "mode": "installation" ]];
    ProductControl::AddWizardSteps(stage_mode);
    Mode::SetMode ("installation");
    symbol ret = ProductControl::Run();

    UI::CloseDialog();
    CleanY2Update();

    return ret;
}

/**
 * Contains list of source IDs that request registration
 */
list <integer> addons_requesting_registration = [];

global void ClearRegistrationRequest (integer src_id) {
    y2milestone ("Clearing registration flag for source ID %1", src_id);
    if (src_id != nil) {
	addons_requesting_registration = filter (integer one_source, addons_requesting_registration, {
	    return one_source != src_id;
	});
    }
}

/**
 * Returns whether registration is requested by at least one of
 * used Add-On products.
 *
 * @return boolean if requested
 */
global boolean ProcessRegistration () {
    boolean force_registration = false;

    // checking add-on products one by one
    foreach (map<string,any> prod, AddOnProduct::add_on_products, {
	integer srcid = (integer) prod["media"]:nil;

	if (srcid != nil && contains (addons_requesting_registration, srcid)) {
	    force_registration = true;
	    break;
	}
    });
    
    y2milestone ("Requesting registration: %1", force_registration);
    return force_registration;
}

/**
 * Add-On product might have been added into products requesting
 * registration. This pruduct has been removed (during configuring
 * list of add-on products).
 */
global void RemoveRegistrationFlag (integer src_id) {
    // filtering out src_id
    addons_requesting_registration = filter (integer one_id, addons_requesting_registration, {
	return one_id != src_id;
    });
    
    // removing cached file
    string tmpdir = (string) SCR::Read (.target.tmpdir) + "/add-on-content-files/";
    string cachedfile = sformat ("%1content-%2", tmpdir, src_id);
    if (FileUtils::Exists (cachedfile)) {
	y2milestone ("Removing cached file %1", cachedfile);
	SCR::Execute (.target.remove, cachedfile);
    }
}

/**
 * Checks whether the content file of the add-on has a flag REGISTERPRODUCT
 * set to "true" or "yes". If it has, product is added into list of pruducts
 * that need registration. Cached content file is used if possible.
 *
 * @param integer source id
 */
global void PrepareForRegistration (integer src_id) {
    string tmpdir = (string) SCR::Read (.target.tmpdir) + "/add-on-content-files/";

    // create directory if doesn't exist
    if (! FileUtils::Exists (tmpdir)) {
	integer run = (integer) SCR::Execute (.target.bash, sformat("/bin/mkdir -p '%1'", tmpdir));
	if (run != 0) {
	    y2error ("Cannot create directory %1", tmpdir);
	    return nil;
	}
    }

    // use cached file if possible
    string contentfile = sformat ("%1content-%2", tmpdir, src_id);
    if (FileUtils::Exists (contentfile)) {
	y2milestone ("Using cached contentfile %1", contentfile);
    } else {
	y2milestone ("Checking contentfile from source");
	string sourcefile = Pkg::SourceProvideOptionalFile (src_id, 1, "/content");
	if (sourcefile == nil) {
	    y2warning ("Cannot obtain content file!");
	    return nil;
	}
	// copying content file
	integer run = (integer) SCR::Execute (.target.bash,
	    sformat ("/bin/cp '%1' '%2'", String::Quote (sourcefile), String::Quote (contentfile))
	);
	if (run != 0) {
	    y2error ("Cannot copy '%1' to '%2'", sourcefile, contentfile);
	    return nil;
	}
    }

    // registering agent for the current content file
    SCR::RegisterAgent (.addon.content, `ag_ini (
	`IniAgent( contentfile, $[
	    "options" : [ "read_only", "global_values", "flat" ],
	    "comments" : [ "^#.*", "^[ \t]*$", ],
	    "params" : [
		$[ "match" : [ "^[ \t]*([a-zA-Z0-9_\.]+)[ \t]*(.*)[ \t]*$", "%s %s" ] ]
	    ]
	]
    )));
    string register_product = (string) SCR::Read (.addon.content.REGISTERPRODUCT);
    SCR::UnregisterAgent (.addon.content);

    // evaluating REGISTERPRODUCT flag, default (nil == false)
    y2milestone ("RegisterProduct flag for source %1 is %2", src_id, register_product);
    if (register_product == "yes" || register_product == "true") {
	addons_requesting_registration = add (addons_requesting_registration, src_id);
    }
}

/**
 * Calls registration client if needed.
 *
 * @param integer source id
 */
global void RegisterAddOnProduct (integer src_id) {
    if (contains (addons_requesting_registration, src_id)) {
	y2milestone ("Source ID %1 requests registration", src_id);
	WFM::CallFunction ("suse_register", []);
    } else {
	y2milestone ("Source ID %1 doesn't need registration", src_id);
    }
}

/**
 * Do installation of the add-on product within an installed system
 * srcid is got via AddOnProduct::src_id
 *
 * @param string src_id
 * @return symbol the result symbol from wizard sequencer
 */
global symbol DoInstall() {
    // Display /media.1/info.txt if such file exists
    // Display license and wait for agreement
    // Not needed here, license already shown in the workflow
    /*
    boolean license_ret = AcceptedLicenseAndInfoFile(src_id);
    if (license_ret != true) {
	y2milestone("Removing the current source ID %1", src_id);
	Pkg::SourceDelete(src_id);
	return nil;
    }
    */

    // FATE #301312
    PrepareForRegistration (src_id);

    symbol ret = nil;

    string control = Pkg::SourceProvideOptionalFile (src_id, 1, "/installation.xml");
    // Fallback -- Source didn't provide needed controll file
    // Handling as it was an installation source
    if (control == nil) {
	ret = DoInstall_NoControlFile();
    } else {
	ret = DoInstall_WithControlFile (control);
    }

    if (ret != nil) {
	// registers Add-On product if requested
	RegisterAddOnProduct (src_id);
    }
    
    y2milestone ("Returning: %1", ret);
    return ret;
}

/**
 * Integrate the add-on product to the installation workflow, including
 * preparations for 2nd stage and inst-sys update
 * @param srcid integer the source ID of the installation source
 * @return boolean true on success
 */
global boolean Integrate (integer srcid) {
    y2milestone ("Integrating source %1", srcid);

    // Adds workflow to the Workflow Store if any workflow exists
    WorkflowManager::AddWorkflow (`addon, srcid, "");

    // Updating inst-sys
    string y2update = Pkg::SourceProvideOptionalFile (srcid, 1, "/y2update.tgz");
    if (y2update == nil) {
	y2milestone ("No YaST update found on the media");
    } else {
	UpdateInstSys (y2update);
    }

    return true;
}

/**
 * Opposite to Integrate()
 *
 * @param srcid integer the source ID of the installation source
 */
global void Disintegrate (integer srcid) {
    WorkflowManager::RemoveWorkflow (`addon, srcid, "");
}

/**
 * Some product(s) were removed, reintegrating their control files from scratch.
 */
global boolean ReIntegrateFromScratch () {
    y2milestone ("Reintegration workflows from scratch...");

    // bugzilla #239055
    RereadAllSCRAgents();

// Should have been done before (by calling AddOnProduct::Integrate()
//    foreach (map<string,any> prod, AddOnProduct::add_on_products, {
//        integer srcid = (integer) prod["media"]:nil;
//        
//        if (srcid == nil) {
//            y2error ("Wrong definition of Add-on product: %1, cannot reintegrate", srcid);
//            return;
//        } else {
//            y2milestone ("Reintegrating product %1", prod);
//            Integrate (srcid);
//        }
//    });
    boolean redraw = WorkflowManager::SomeWorkflowsWereChanged();

    // New implementation: Control files are cached, just merging them into the Base Workflow
    WorkflowManager::MergeWorkflows();

    // steps might have been changed, forcing redraw
    if (redraw) {
	y2milestone ("Forcing RedrawWizardSteps()");
	WorkflowManager::RedrawWizardSteps ();
    }

    return true;
}

global boolean CheckProductDependencies (list<string> products) {
// TODO check the dependencies of the product
    return true;
}

/**
 * Auto-integrate add-on products in specified file
 * @param filelist string a file containing a list of add-on products to integrate
 * @return boolean true on exit
 */
global boolean AddPreselectedAddOnProducts(string filelist) {
    if (filelist == nil)
    {
	y2milestone ("No add-on products defined on the media");
	return true;
    }
    list<string> products = splitstring ((string)SCR::Read (.target.string, filelist), "\r\n");

    y2milestone ("Adding products: %1", products);
    foreach (string p, products, {
	if (p == "")
	    return;
	list<string> elements = splitstring (p, " \t");
	elements = filter (string e, elements, { return e != ""; });
	string url = elements[0]:"";
	string pth = elements[1]:"/";
	elements = remove (elements, 0);
	elements = remove (elements, 0);
	integer src = Pkg::SourceCreate (url, pth);
	if (! AcceptedLicenseAndInfoFile(src))
	{
	    Pkg::SourceDelete (src);
	    return;
	}
	Integrate (src);
	if (size (elements) > 0)
	{
	    foreach (string e, elements, {
		Pkg::ResolvableInstall (e, `product);
	    });
	}
	else
	{
	    list<map<string,any> > products = Pkg::ResolvableProperties ("", `product, "");
	    products = filter (map<string,any> p, products, {
		return p["source"]:-1 == src;
	    });
	    foreach (map<string,any> p, products, {
		Pkg::ResolvableInstall (p["name"]:"", `product);
	    });
	}
    });
}

/* Export/Import --> */

global map Export () {
    list<map<string,any> > exp = maplist (map<string,any> p, add_on_products, {
	if (haskey (p, "media"))
	    p = remove (p, "media");
	return p;
    });
    return $[
	"add_on_products" : exp,
    ];
}

global boolean Import (map settings) {
    add_on_products = settings["add_on_products"]:[];
    modified = false;
    if (Mode::config ())
    {
	foreach (map prod, add_on_products, {
	    string media = prod["media_url"]:"";
	    string pth = prod["product_dir"]:"/";
	    integer src = Pkg::SourceCreate (media, pth);
	    if (src != -1)
		mode_config_sources = add (mode_config_sources, src);
	});
    }
    return true;
}

global void CleanModeConfigSources () {
    foreach (integer src, mode_config_sources, {
	Pkg::SourceDelete (src);
    });
    mode_config_sources = [];
}

/**
 * Returns the path where Add-Ons configuration is stored during the fist stage installation.
 * This path reffers to the installed system.
 *
 * @see bugzilla #187558
 */
global string TmpExportFilename () {
    return Directory::vardir + "/exported_add_ons_configuration";
}

/**
 * Reads the Add-Ons configuration stored on disk during the first stage installation.
 *
 * @see bugzilla #187558
 */
global boolean ReadTmpExportFilename () {
    string tmp_filename = TmpExportFilename();
    modified = true;

    if (FileUtils::Exists(tmp_filename)) {
	y2milestone ("Reading %1 content", tmp_filename);

	// there might be something already set, store the current configuration
	list <map <string,any> > already_in_configuration = add_on_products;
	map configuration_from_disk  = (map) SCR::Read (.target.ycp, tmp_filename);
	y2milestone ("Configuration from disk: %1", configuration_from_disk);

	if (configuration_from_disk != nil) {
	    Import (configuration_from_disk);
	    if (already_in_configuration != [] && already_in_configuration != nil) {
		add_on_products = (list <map <string,any> >) union (add_on_products, already_in_configuration);
	    }
	    return true;
	} else {
	    y2error ("Reading %1 file returned nil result!", tmp_filename);
	    return false;
	}
    } else {
	y2warning ("File %1 doesn't exists, skipping...", tmp_filename);
	return true;
    }
}

/* <-- Export/Import */

} // module end
