/**
 * File:
 *	AddOnProduct.ycp
 *
 * Module:
 *	AddOnProduct
 *
 * Summary:
 *	This module provides integration of the add-on products
 *
 * Authors:
 *	Jiri Srain <jsrain@suse.de>
 *	Lukas Ocilka <locilka@suse.cz>
 */

{
module "AddOnProduct";

// IMPORTANT: maintainer of yast2-add-on is responsible for this module

textdomain "packager";

import "Label";
import "Mode";
import "ProductControl";
import "ProductFeatures";
import "Report";
import "XML";
import "Wizard";
import "FileUtils";
import "Language";
import "Popup";
import "InstShowInfo";
import "ProductLicense";
import "FileUtils";
import "Directory";
import "String";
import "WorkflowManager";
import "URL";
import "Mode";

// variables for installation with product
/**
 * ID for cache in the inst-sys
 */
integer src_cache_id = -1;

/**
 * System proposals have already been prepared for merging?
 */
boolean system_proposals_prepared = false;

/**
 * System workflows have already been prepared for merging?
 */
boolean system_workflows_prepared = false;

/**
 * List of all selected repositories
 *
 * @struct add_on_products = [
 *   $[
 *     "media" : 4, // ID of the source
 *     "product_dir" : "/",
 *     "product" : "openSUSE version XX.Y",
 *     "autoyast_product" : "'PRODUCT' tag for AutoYaST Export",
 *   ],
 *   ...
 * ]
 */
global list<map<string,any> > add_on_products = [];

/**
 * ID of currently added repository for the add-on product
 */
global integer src_id  = nil;

// for the add-on product workflow - needed for dialog skipping
/**
 * return value of last step in the product adding workflow
 */
global symbol last_ret = nil;

global boolean modified = false;

global list <integer> mode_config_sources = [];

global map<string,any> current_addon = $[];

// Bugzilla #239630
// In installation: check for low-memory machines
global boolean low_memory_already_reported = false;

// Bugzilla #305554
// Both online-repositories and add-ons use the same function and variable
// if true, both are skipped at once without asking
global boolean skip_add_ons = false;

// --> FATE #302123: Allow relative paths in "add_on_products" file
string base_product_url = nil;

global void SetBaseProductURL (string url) {
    if (url == "" || url == nil)
	y2warning ("Empty base url");

    base_product_url = url;
    y2milestone ("New base URL: %1", base_product_url);
}

global string GetBaseProductURL () {
    return base_product_url;
}

/**
 * Returns an absolute URL from base + relative url.
 * Relative URL needs to start with 'reulrl://' othewise
 * it is not considered being relative and it's returned
 * as it is (just the relative_url parameter).
 *
 * @param string base_url
 * @param string relative_url
 * @return string absolute_url
 *
 * @example
 *   AddOnProduct::GetAbsoluteURL (
 *     "http://www.example.org/some%20dir/another%20dir",
 *     "relurl://../AnotherProduct/"
 *   ) -> "http://www.example.org/some%20dir/AnotherProduct/"
 *   AddOnProduct::GetAbsoluteURL (
 *     "username:password@ftp://www.example.org/dir/",
 *     "relurl://./Product_CD1/"
 *   ) -> "username:password@ftp://www.example.org/dir/Product_CD1/"
 */
global string GetAbsoluteURL (string base_url, string url) {
    if (! regexpmatch (url, "^relurl://")) {
	y2debug ("Not a relative URL: %1", url);
	return url;
    }

    if (base_url == nil || base_url == "") {
	y2error ("No base_url defined");
	return url;
    }

    // bugzilla #306670
    integer base_params_pos = search (base_url, "?");
    string base_params = "";

    if (base_params_pos != nil && base_params_pos >= 0) {
	base_params = substring (base_url, (base_params_pos + 1));
	base_url = substring (base_url, 0, base_params_pos);
    }

    integer added_params_pos = search (url, "?");
    string added_params = "";

    if (added_params_pos != nil && added_params_pos >= 0) {
	added_params = substring (url, (added_params_pos + 1));
	url = substring (url, 0, added_params_pos);
    }

    if (! regexpmatch (base_url, "/$")) {
	base_url = base_url + "/";
    }

    y2milestone ("Merging '%1' (params '%2') to '%3' (params '%4')", url, added_params, base_url, base_params);
    url = regexpsub (url, "^relurl://(.*)$", "\\1");

    url = sformat ("%1%2", base_url, url);

    // merge /something/../
    integer max_count = 100;

    while (max_count > 0 && regexpmatch (url, "(.*/)[^/]+/+\\.\\./")) {
	max_count = max_count - 1;
	list <integer> str_offset_l = (list <integer>) regexppos (url, "/\\.\\./");
	integer str_offset = str_offset_l[0]:nil;

	if (str_offset != nil && str_offset > 0) {
	    string stringfirst = substring (url, 0, str_offset);
	    string stringsecond = substring (url, str_offset);

	    y2debug ("Pos: %1 First: >%2< Second: >%3<", str_offset, stringfirst, stringsecond);

	    stringfirst = regexpsub (stringfirst, "^(.*/)[^/]+/*$", "\\1");
	    stringsecond = regexpsub (stringsecond, "^/\\.\\./(.*)$", "\\1");
	    
	    url = stringfirst + stringsecond;
	}
    }

    // remove /./
    max_count = 100;

    while (max_count > 0 && regexpmatch (url, "/\\./")) {
	max_count = max_count - 1;
	url = regexpsub (url, "^(.*)/\\./(.*)", "\\1/\\2");
    }

    map <string, string> base_params_map  = URL::MakeMapFromParams (base_params);
    map <string, string> added_params_map = URL::MakeMapFromParams (added_params);
    map <string, string> final_params_map = (map <string, string>) union (base_params_map, added_params_map);

    if (size (final_params_map) > 0) {
	y2milestone ("%1 merge %2 -> %3", base_params_map, added_params_map, final_params_map);

	url = url + "?" + URL::MakeParamsFromMap (final_params_map);
    }

    y2milestone ("Final URL: '%1'", url);
    return url;
}
// <--

/**
 * Adapts the inst-sys from the tarball
 * @param filename string the filename with the tarball to use to the update
 * @return boolean true on success
 */
global boolean UpdateInstSys (string filename) {
    src_cache_id = src_cache_id + 1;
    string tmpdir = (string)SCR::Read (.target.tmpdir);
    tmpdir = sformat ("%1/%2", tmpdir, src_cache_id);
    map out = (map)SCR::Execute (.target.bash_output, sformat ("
/bin/mkdir %1;
cd %1;
/bin/tar -xvf %2;
/sbin/adddir %1 /;
", tmpdir, filename));
    if (out["exit"]:0 != 0)
    {
	y2error ("Including installation image failed: %1", out);
	return false;
    }
    y2milestone ("Including installation image succeeded");
    return true;
}

/**
 * New add-on product might add also new agents.
 * Functions Rereads all available agents.
 *
 * @see bugzilla #239055, #245508
 */
global void RereadAllSCRAgents () {
    y2milestone ("Registering new agents...");
    boolean ret = (boolean) SCR::RegisterNewAgents();

    if (ret) {
	y2milestone ("Successful");
    } else {
	y2error ("Error occured during registering new agents!");
	Report::Error (_("An error occurred while preparing the installation system."));
    }
}

/**
 * Remove the /y2update directory from the system
 */
void CleanY2Update() {
    SCR::Execute (.target.bash, "/bin/rm -rf /y2update");
}

/**
 * Show /media.1/info.txt file in a pop-up message if such file exists.
 * Show license if such exists and return whether users accepts it.
 * Returns 'nil' when did not succed.
 *
 * @return boolean whether the license has been accepted
 */
global boolean AcceptedLicenseAndInfoFile (integer src_id) {
    symbol ret = ProductLicense::AskAddOnLicenseAgreement (src_id);
    if (ret == nil)
	return nil;
    else if (ret == `abort || ret == `back)
    {
	y2milestone ("License confirmation failed");
	return false;
    }
    return true;
}

boolean AnyPatternInRepo()
{
    list<map> patterns = Pkg::ResolvableProperties("", `pattern, "");

    y2milestone("Total number of patterns: %1", size(patterns));

    patterns = filter(map pat, patterns,
	{
	    return (pat["source"]:nil == src_id);
	}
    );

    y2milestone("Found %1 add-on patterns", size(patterns));
    y2debug("Found add-on patterns: %1", patterns);

    return size(patterns) > 0;
}

symbol DoInstall_NoControlFile () {
    y2milestone("File /installation.xml not found, running sw_single for this repository");

    // display pattern the dialog when there is a pattern provided by the addon
    // otherwise use search mode
    symbol mode = AnyPatternInRepo() ? `patternSelector : `searchMode;
    // enable repository management if not in installation mode
    boolean enable_repo_management = Mode::normal();

    map args = $[ "dialog_type" : mode, "repo_mgmt" : enable_repo_management ];
    y2milestone("Arguments for sw_single: %1", args);

    any ret = WFM::CallFunction ("sw_single", [args]);
    y2milestone("sw_single returned: %1", ret);

    if (ret == `abort || ret == `cancel || ret == `close)
	return `abort;

    return `register;
}

boolean IntegrateY2Update (integer src_id) {
    string binaries = Pkg::SourceProvideOptionalFile (src_id, 1, "/y2update.tgz");
    // File /y2update.tgz exists
    if (binaries != nil)
    {
	// Try to extract files from the archive
	map out = (map)SCR::Execute (.target.bash_output, sformat ("
test -d /y2update && rm -rf /y2update;
/bin/mkdir -p /y2update/all;
cd /y2update/all;
/bin/tar -xvf %1;
cd /y2update;
ln -s all/usr/share/YaST2/* .;
ln -s all/usr/lib/YaST2/* .;
", binaries));

	// Failed
	if (out["exit"]:0 != 0)
	{
	    // error report
	    Report::Error (_("An error occurred while preparing the installation system."));
	    CleanY2Update();
	    return false;
	} else {
	    // bugzilla #239055
	    RereadAllSCRAgents();
	}
    }
    else
    {
	y2milestone("File /y2update.tgz not provided");
    }

    return true;
}

symbol DoInstall_WithControlFile (string control) {
    y2milestone ("File /installation.xml was found, running own workflow...");
    // copy the control file to local filesystem - in case of media release
    string tmp = (string)SCR::Read (.target.tmpdir);
    tmp = tmp + "/installation.xml";
    SCR::Execute (.target.bash, sformat ("/bin/cp %1 %2", control, tmp));
    control = tmp;

    if (! IntegrateY2Update (src_id)) return nil;

    // set control file
    ProductControl::custom_control_file = control;
    if (!ProductControl::Init())
    {
	// error report
	Report::Error (sformat (_("Control file %1 not found on media."),
	    control));
	CleanY2Update();
	return nil;
    }

    // start workflow
    Wizard::OpenNextBackStepsDialog();
    // dialog caption
    Wizard::SetContents(_("Initializing..."), `Empty (), "", false, false);

    list<map> stage_mode = [$["stage": "normal",  "mode": "installation" ]];
    ProductControl::AddWizardSteps(stage_mode);
    Mode::SetMode ("installation");
    symbol ret = ProductControl::Run();

    UI::CloseDialog();
    CleanY2Update();

    return ret;
}

/**
 * Contains list of repository IDs that request registration
 */
list <integer> addons_requesting_registration = [];

global void ClearRegistrationRequest (integer src_id) {
    y2milestone ("Clearing registration flag for repository ID %1", src_id);
    if (src_id != nil) {
	addons_requesting_registration = filter (integer one_source, addons_requesting_registration, {
	    return one_source != src_id;
	});
    }
}

/**
 * Returns whether registration is requested by at least one of
 * used Add-On products.
 *
 * @return boolean if requested
 */
global boolean ProcessRegistration () {
    boolean force_registration = false;

    // checking add-on products one by one
    foreach (map<string,any> prod, AddOnProduct::add_on_products, {
	integer srcid = (integer) prod["media"]:nil;

	if (srcid != nil && contains (addons_requesting_registration, srcid)) {
	    force_registration = true;
	    break;
	}
    });
    
    y2milestone ("Requesting registration: %1", force_registration);
    return force_registration;
}

/**
 * Add-On product might have been added into products requesting
 * registration. This pruduct has been removed (during configuring
 * list of add-on products).
 */
global void RemoveRegistrationFlag (integer src_id) {
    // filtering out src_id
    addons_requesting_registration = filter (integer one_id, addons_requesting_registration, {
	return one_id != src_id;
    });
    
    // removing cached file
    string tmpdir = (string) SCR::Read (.target.tmpdir) + "/add-on-content-files/";
    string cachedfile = sformat ("%1content-%2", tmpdir, src_id);
    if (FileUtils::Exists (cachedfile)) {
	y2milestone ("Removing cached file %1", cachedfile);
	SCR::Execute (.target.remove, cachedfile);
    }
}

/**
 * Checks whether the content file of the add-on has a flag REGISTERPRODUCT
 * set to "true" or "yes". If it has, product is added into list of pruducts
 * that need registration. Cached content file is used if possible.
 *
 * @param integer source id
 */
global void PrepareForRegistration (integer src_id) {
    string tmpdir = (string) SCR::Read (.target.tmpdir) + "/add-on-content-files/";

    // create directory if doesn't exist
    if (! FileUtils::Exists (tmpdir)) {
	integer run = (integer) SCR::Execute (.target.bash, sformat("/bin/mkdir -p '%1'", tmpdir));
	if (run != 0) {
	    y2error ("Cannot create directory %1", tmpdir);
	    return nil;
	}
    }

    // use cached file if possible
    string contentfile = sformat ("%1content-%2", tmpdir, src_id);
    if (FileUtils::Exists (contentfile)) {
	y2milestone ("Using cached contentfile %1", contentfile);
    } else {
	y2milestone ("Checking contentfile from repository");
	string sourcefile = Pkg::SourceProvideOptionalFile (src_id, 1, "/content");
	if (sourcefile == nil) {
	    y2warning ("Cannot obtain content file!");
	    return nil;
	}
	// copying content file
	integer run = (integer) SCR::Execute (.target.bash,
	    sformat ("/bin/cp '%1' '%2'", String::Quote (sourcefile), String::Quote (contentfile))
	);
	if (run != 0) {
	    y2error ("Cannot copy '%1' to '%2'", sourcefile, contentfile);
	    return nil;
	}
    }

    // registering agent for the current content file
    SCR::RegisterAgent (.addon.content, `ag_ini (
	`IniAgent( contentfile, $[
	    "options" : [ "read_only", "global_values", "flat" ],
	    "comments" : [ "^#.*", "^[ \t]*$", ],
	    "params" : [
		$[ "match" : [ "^[ \t]*([a-zA-Z0-9_\.]+)[ \t]*(.*)[ \t]*$", "%s %s" ] ]
	    ]
	]
    )));
    string register_product = (string) SCR::Read (.addon.content.REGISTERPRODUCT);
    SCR::UnregisterAgent (.addon.content);

    // evaluating REGISTERPRODUCT flag, default (nil == false)
    y2milestone ("RegisterProduct flag for repository %1 is %2", src_id, register_product);
    if (register_product == "yes" || register_product == "true") {
	addons_requesting_registration = add (addons_requesting_registration, src_id);
    }
}

/**
 * Calls registration client if needed.
 *
 * @param integer source id
 */
global void RegisterAddOnProduct (integer src_id) {
    if (contains (addons_requesting_registration, src_id)) {
	y2milestone ("Repository ID %1 requests registration", src_id);
	WFM::CallFunction ("inst_suse_register", []);
    } else {
	y2milestone ("Repository ID %1 doesn't need registration", src_id);
    }
}

// function content defined later
void HandleProductPATTERNS (integer srcid);

/**
 * Do installation of the add-on product within an installed system
 * srcid is got via AddOnProduct::src_id
 *
 * @param string src_id
 * @return symbol the result symbol from wizard sequencer
 */
global symbol DoInstall() {
    // Display /media.1/info.txt if such file exists
    // Display license and wait for agreement
    // Not needed here, license already shown in the workflow
    /*
    boolean license_ret = AcceptedLicenseAndInfoFile(src_id);
    if (license_ret != true) {
	y2milestone("Removing the current source ID %1", src_id);
	Pkg::SourceDelete(src_id);
	return nil;
    }
    */

    // FATE #301312
    PrepareForRegistration (src_id);

    // FATE #302398: PATTERNS keyword in content file
    HandleProductPATTERNS (src_id);

    symbol ret = nil;

    string control = Pkg::SourceProvideOptionalFile (src_id, 1, "/installation.xml");
    // Fallback -- Repository didn't provide needed controll file
    // Handling as it was a repository
    if (control == nil) {
	ret = DoInstall_NoControlFile();
    } else {
	ret = DoInstall_WithControlFile (control);
    }

    y2milestone("Result of the add-on installation: %1", ret);

    if (ret != nil && ret != `abort) {
	// registers Add-On product if requested
	RegisterAddOnProduct (src_id);
    }
    
    y2milestone ("Returning: %1", ret);
    return ret;
}

/**
 * Every Add-On can preselect some patterns.
 * Only patterns that are not selected/installed yet will be used.
 *
 * @struct $[
 *   src_id : [
 *     "pattern_1", "pattern_2", "pattern_6"
 *   ]
 * ]
 */
map <integer, list <string> > patterns_preselected_by_addon = $[];

boolean SelectProductPatterns (string content_file, integer src_id) {

    // TODO FIXME: really needed?
    // Installing the product from the resitory should do the same!

    string cmd = sformat (
	"grep '^PATTERNS[\t ]\+' '%1' | sed 's/^PATTERNS[\t ]\+//'",
	String::Quote (content_file)
    );

    map cmd_out = (map) SCR::Execute (.target.bash_output, cmd);

    if (cmd_out["exit"]:-1 != 0) {
	y2error ("Command: >%1< returned: %2", cmd, cmd_out);

	return false;
    }

    list <string> patterns_to_select = splitstring (cmd_out["stdout"]:"", "\t ");
    patterns_to_select = filter (string one_pattern, patterns_to_select, {
	return (one_pattern != nil && one_pattern != "");
    });

    if (size (patterns_to_select) == 0) {
	y2milestone ("Add-On doesn't have any required patterns (PATTERNS in content)");
	return true;
    }

    y2milestone ("Add-On requires these PATTERNS: %1", patterns_to_select);
    // clear/set
    patterns_preselected_by_addon[src_id] = [];

    boolean ret = true;

    foreach (string one_pattern, patterns_to_select, {
	list <map <string,any> > pattern_properties = Pkg::ResolvableProperties (one_pattern, `pattern, "");

	boolean already_selected = false;

	foreach (map <string,any> one_pattern_found, pattern_properties, {
	    symbol patt_status = one_pattern_found["status"]:`unknown;
	    // patern is already selected
	    if (patt_status == `installed || patt_status == `selected) {
		already_selected = true;
		break;
	    }
	});

	if (already_selected) {
	    y2milestone ("Pattern %1 is already installed/selected", one_pattern);
	    return;
	}

	if (! Pkg::ResolvableInstall (one_pattern, `pattern)) {
	    y2error ("Cannot select pattern: %1, reason: %2", one_pattern, Pkg::LastError());
	    ret = false;
	} else {
	    patterns_preselected_by_addon[src_id] = add (patterns_preselected_by_addon[src_id]:[], one_pattern);
	}
    });

    return ret;
}


boolean DeselectProductPatterns (integer src_id) {
    list <string> patterns_to_deselect = patterns_preselected_by_addon[src_id]:[];

    if (size (patterns_to_deselect) == 0) {
	y2milestone ("There's no pattern to be deselected");
	return true;
    }

    boolean ret = true;

    foreach (string one_pattern, patterns_to_deselect, {
	if (! Pkg::ResolvableNeutral (one_pattern, `pattern, true)) {
	    y2error ("Cannot deselect pattern: %1, reason: %2", one_pattern, Pkg::LastError());
	    ret = false;
	}
    });

    return ret;
}

/**
 * Function checks whether the product content file contains
 * PATTERNS tag and pre-selects patterns listed there.
 *
 * @param integer source ID
 */
void HandleProductPATTERNS (integer srcid) {
    // FATE #302398: PATTERNS keyword in content file
    string content_file = Pkg::SourceProvideOptionalFile (srcid, 1, "/content");

    if (content_file == nil) {
	y2warning ("Add-On %1 doesn't have a content file", srcid);
    } else {
	SelectProductPatterns (content_file, srcid);
    }
}

/**
 * Integrate the add-on product to the installation workflow, including
 * preparations for 2nd stage and inst-sys update
 * @param srcid integer the ID of the repository
 * @return boolean true on success
 */
global boolean Integrate (integer srcid) {
    y2milestone ("Integrating repository %1", srcid);

    // Updating inst-sys
    string y2update = Pkg::SourceProvideOptionalFile (srcid, 1, "/y2update.tgz");

    if (y2update == nil) {
	y2milestone ("No YaST update found on the media");
    } else {
	UpdateInstSys (y2update);
    }

    // FATE #302398: PATTERNS keyword in content file
    HandleProductPATTERNS (srcid);

    // Adds workflow to the Workflow Store if any workflow exists
    WorkflowManager::AddWorkflow (`addon, srcid, "");

    return true;
}

/**
 * Opposite to Integrate()
 *
 * @param srcid integer the ID of the repository
 */
global void Disintegrate (integer srcid) {
    DeselectProductPatterns (srcid);

    WorkflowManager::RemoveWorkflow (`addon, srcid, "");
}

/**
 * Some product(s) were removed, reintegrating their control files from scratch.
 */
global boolean ReIntegrateFromScratch () {
    y2milestone ("Reintegration workflows from scratch...");

    // bugzilla #239055
    RereadAllSCRAgents();

// Should have been done before (by calling AddOnProduct::Integrate()
//    foreach (map<string,any> prod, AddOnProduct::add_on_products, {
//        integer srcid = (integer) prod["media"]:nil;
//
//        if (srcid == nil) {
//            y2error ("Wrong definition of Add-on product: %1, cannot reintegrate", srcid);
//            return;
//        } else {
//            y2milestone ("Reintegrating product %1", prod);
//            Integrate (srcid);
//        }
//    });
    boolean redraw = WorkflowManager::SomeWorkflowsWereChanged();

    // New implementation: Control files are cached, just merging them into the Base Workflow
    WorkflowManager::MergeWorkflows();

    // steps might have been changed, forcing redraw
    if (redraw) {
	y2milestone ("Forcing RedrawWizardSteps()");
	WorkflowManager::RedrawWizardSteps ();
    }

    return true;
}

global boolean CheckProductDependencies (list<string> products) {
// TODO check the dependencies of the product
    return true;
}

/**
 * Auto-integrate add-on products in specified file (usually add_on_products file)
 * @param filelist string a file containing a list of add-on products to integrate
 * @return boolean true on exit
 */
global boolean AddPreselectedAddOnProducts (string filelist) {
    if (filelist == nil)
    {
	y2milestone ("No add-on products defined on the media");
	return true;
    }
    list<string> products = splitstring ((string)SCR::Read (.target.string, filelist), "\r\n");

    string base_url = GetBaseProductURL();
    y2milestone ("Base URL: %1", base_url);

    y2milestone ("Adding products: %1", products);
    foreach (string p, products, {
	if (p == "")
	    return;

	list <string> elements = splitstring (p, " \t");
	elements = filter (string e, elements, { return e != ""; });
	string url = elements[0]:"";
	string pth = elements[1]:"/";
	if (elements[0]:nil != nil) elements = remove (elements, 0);
	if (elements[0]:nil != nil) elements = remove (elements, 0);

	// FATE #302123
	if (base_url != nil && base_url != "") {
	    url = GetAbsoluteURL (base_url, url);
	}
	y2milestone ("Adding Repository: %1 %2", url, pth);

	integer src = Pkg::SourceCreate (url, pth);
	if (! AcceptedLicenseAndInfoFile(src))
	{
	    Pkg::SourceDelete (src);
	    return;
	}
	Integrate (src);

	// adding the product to the list of products
	// bugzilla #269625
	map <string, string> prod = (map <string, string>) Pkg::SourceProductData (src);

	AddOnProduct::add_on_products = add (AddOnProduct::add_on_products, $[
	    "media" : src,
	    "product" : prod["label"]:prod["productname"]:prod["productversion"]:"",
	    "autoyast_product" : prod["productname"]:"",
	    "media_url" : url,
	    "product_dir" : pth,
	]);

	if (size (elements) > 0)
	{
	    foreach (string e, elements, {
		Pkg::ResolvableInstall (e, `product);
	    });
	}
	else
	{
	    list<map<string,any> > products = Pkg::ResolvableProperties ("", `product, "");
	    products = filter (map<string,any> p, products, {
		return p["source"]:-1 == src;
	    });
	    foreach (map<string,any> p, products, {
		Pkg::ResolvableInstall (p["name"]:"", `product);
	    });
	}
    });

    // reread agents, redraw wizard steps, etc.
    ReIntegrateFromScratch();
}

/* Export/Import --> */

/**
 * Returns map describing all used add-ons.
 *
 * @return map
 *
 * @struct This is an XML file created from exported map:
 * <add-on>
 *   <add_on_products config:type="list">
 *     <listentry>
 *       <media_url>ftp://server.name/.../</media_url>
 *       <product>NEEDS_TO_MATCH_"PRODUCT"_TAG_FROM_content_FILE!</product>
 *       <product_dir>/</product_dir>
 *     </listentry>
 *     ...
 *   </add_on_products>
 * </add-on>
 */
global map Export () {
    y2milestone ("Add-Ons Input: %1", add_on_products);

    list<map<string,any> > exp = maplist (map<string,any> p, add_on_products, {
	if (haskey (p, "media"))
	    p = remove (p, "media");

	// bugzilla #279893
	if (haskey (p, "autoyast_product")) {
	    p["product"] = p["autoyast_product"]:"";
	    p = remove (p, "autoyast_product");
	}

	return p;
    });

    y2milestone ("Add-Ons Output: %2", exp);

    return $[
	"add_on_products" : exp,
    ];
}

global boolean Import (map settings) {
    add_on_products = settings["add_on_products"]:[];
    modified = false;
    if (Mode::config ())
    {
	foreach (map prod, add_on_products, {
	    string media = prod["media_url"]:"";
	    string pth = prod["product_dir"]:"/";
	    integer src = Pkg::SourceCreate (media, pth);
	    if (src != -1)
		mode_config_sources = add (mode_config_sources, src);
	});
    }
    return true;
}

global void CleanModeConfigSources () {
    foreach (integer src, mode_config_sources, {
	Pkg::SourceDelete (src);
    });
    mode_config_sources = [];
}

/**
 * Returns the path where Add-Ons configuration is stored during the fist stage installation.
 * This path reffers to the installed system.
 *
 * @see bugzilla #187558
 */
global string TmpExportFilename () {
    return Directory::vardir + "/exported_add_ons_configuration";
}

/**
 * Reads the Add-Ons configuration stored on disk during the first stage installation.
 *
 * @see bugzilla #187558
 */
global boolean ReadTmpExportFilename () {
    string tmp_filename = TmpExportFilename();
    modified = true;

    if (FileUtils::Exists(tmp_filename)) {
	y2milestone ("Reading %1 content", tmp_filename);

	// there might be something already set, store the current configuration
	list <map <string,any> > already_in_configuration = add_on_products;
	map configuration_from_disk  = (map) SCR::Read (.target.ycp, tmp_filename);
	y2milestone ("Configuration from disk: %1", configuration_from_disk);

	if (configuration_from_disk != nil) {
	    Import (configuration_from_disk);
	    if (already_in_configuration != [] && already_in_configuration != nil) {
		add_on_products = (list <map <string,any> >) union (add_on_products, already_in_configuration);
	    }
	    return true;
	} else {
	    y2error ("Reading %1 file returned nil result!", tmp_filename);
	    return false;
	}
    } else {
	y2warning ("File %1 doesn't exists, skipping...", tmp_filename);
	return true;
    }
}


boolean AcceptUnsignedFile(string file)
{
    y2milestone("Accepting unsigned file %1", file);
    return true;
}

boolean RejectUnsignedFile(string file)
{
    y2milestone("Rejecting unsigned file %1", file);
    return false;
}

boolean AcceptFileWithoutChecksum(string file)
{
    y2milestone("Accepting file without checksum: %1", file);
    return true;
}

boolean RejectFileWithoutChecksum(string file)
{
    y2milestone("Rejecting file without checksum: %1", file);
    return false;
}

boolean AcceptVerificationFailed(string file, map<string,any> key)
{
    y2milestone("Accepting failed verification of file %1 with key %2", file, key);
    return true;
}

boolean RejectVerificationFailed(string file, map<string,any> key)
{
    y2milestone("Rejecting failed verification of file %1 with key %2", file, key);
    return false;
}


global boolean AcceptUnknownGpgKeyCallback( string filename, string keyid )
{
    y2milestone("AcceptUnknownGpgKeyCallback %1: %2", filename, keyid);

    return ( current_addon["signature-handling","accept_unknown_gpg_key","all"]:false ||
             contains( current_addon["signature-handling","accept_unknown_gpg_key","keys"]:[], keyid ) );
}

global boolean ImportGpgKeyCallback(map<string,any> key)
{
    y2milestone("ImportGpgKeyCallback: %1", key);

    return ( current_addon["signature-handling","import_gpg_key","all"]:false ||
             contains( current_addon["signature-handling","import_gpg_key","keys"]:[], key["id"]:"" ) );
}

global boolean AcceptNonTrustedGpgKeyCallback(map<string,any> key)
{
    y2milestone("AcceptNonTrustedGpgKeyCallback %1", key);

    return ( current_addon["signature-handling","accept_non_trusted_gpg_key","all"]:false ||
             contains( current_addon["signature-handling","accept_non_trusted_gpg_key","keys"]:[], key["id"]:"" ) );
}


/* <-- Export/Import */

/*
  <add-on>
    <add_on_products config:type="list">
      <listentry>
        <media_url>http://software.opensuse.org/download/server:/dns/SLE_10/</media_url>
        <product>buildservice</product>
        <product_dir>/</product_dir>
        <signature-handling>
           <accept_unsigned_file config:type="boolean">true</accept_unsigned_file>
           <accept_file_without_checksum config:type="boolean">true</accept_file_without_checksum>
           <accept_verification_failed config:type="boolean">true</accept_verification_failed>
           <accept_unknown_gpg_key>
             <all config:type="boolean">true</all>
             <keys config:type="list">
                <keyid>...</keyid>
                <keyid>3B3011B76B9D6523</keyid>
             </keys>
           </accept_unknown_gpg_key>
           <accept_non_trusted_gpg_key>
             <all config:type="boolean">true</all>
             <keys config:type="list">
                <keyid>...</keyid>
             </keys>
           </accept_non_trusted_gpg_key>
           <import_gpg_key>
             <all config:type="boolean">true</all>
             <keys config:type="list">
                <keyid>...</keyid>
             </keys>
           </import_gpg_key>
        </signature-handling>
      </listentry>
    </add_on_products>
  </add-on>
*/
global void SetSignatureCallbacks( string product ) {
    current_addon = $[];
    foreach( map<string,any> addon, add_on_products, ``{
        if( addon["product"]:"" != product )
            continue;
        current_addon = addon; // remember the current addon for the Callbacks
        if( haskey( addon["signature-handling"]:$[], "accept_unsigned_file" ) )
            Pkg::CallbackAcceptUnsignedFile(
                addon["signature-handling","accept_unsigned_file"]:false ? AcceptUnsignedFile : RejectUnsignedFile
            );
        if( haskey( addon["signature-handling"]:$[], "accept_file_without_checksum" ) )
            Pkg::CallbackAcceptFileWithoutChecksum(
                addon["signature-handling","accept_file_without_checksum"]:false ? AcceptFileWithoutChecksum : RejectFileWithoutChecksum
            );
        if( haskey( addon["signature-handling"]:$[], "accept_verification_failed") )
            Pkg::CallbackAcceptVerificationFailed(
                addon["signature-handling","accept_verification_failed"]:false ? AcceptVerificationFailed : RejectVerificationFailed
            );
        if( haskey( addon["signature-handling"]:$[], "accept_unknown_gpg_key") )
            Pkg::CallbackAcceptUnknownGpgKey(AddOnProduct::AcceptUnknownGpgKeyCallback);
        if( haskey( addon["signature-handling"]:$[], "import_gpg_key") )
            Pkg::CallbackImportGpgKey(AddOnProduct::ImportGpgKeyCallback);
        if( haskey( addon["signature-handling"]:$[], "accept_non_trusted_gpg_key") )
            Pkg::CallbackAcceptNonTrustedGpgKey(AddOnProduct::AcceptNonTrustedGpgKeyCallback);

        break;
    });
    return;
}

} // module end
