/**
 * File:	Packages.ycp
 * Package:	Package selections
 * Authors:	Anas Nashif <nashif@suse.de>
 *
 * $Id$
 */

{

module "Packages";

textdomain "packager";

import "AddOnProduct";
import "Arch";
import "Directory";
import "InstURL";
import "SourceManager";
import "Kernel";
import "Mode";
import "Stage";
import "Linuxrc";
import "Language";
import "ProductFeatures";
import "ProductControl";
import "Report";
import "SlideShow";
import "SpaceCalculation";
import "Storage";
import "String";
import "Popup";
import "Label";
import "Wizard";
import "DirInstall";
import "PackageCallbacksInit";
import "Product";
import "DefaultDesktop";

/**
 * Force full proposal routine next run
 */
boolean full_repropose = false;

/**
 * Installation source has been initialized?
 */
boolean init_called = false;

/**
 * Error which occurred during installation source initialization
 */
string init_error = nil;


    global boolean install_sources = false;	// Installing source packages ?
    global integer timestamp = 0;		// last time of getting the target map

    global string metadir = "/yast-install";
    global boolean metadir_used = false;	// true if meta data and inst-sys is in ramdisk

    global list<integer> theSources = [];		// id codes of sources in priority order
    global list<string> theSourceDirectories = [];	// product directories on sources
    global map<integer,integer> theSourceOrder = $[];	// installation order

    string servicepack_metadata = "/servicepack.tar.gz";

    // to remember if warning should occurre if switching base selection
    global boolean base_selection_modified = false;

    global boolean base_selection_changed = false;

    // Local variables


    string choosen_base_selection = "";

    // count of errors during packages solver
    global integer solve_errors = 0;

    /**
     * Packages to be selected when proposing the list
     */
    list<string> additional_packages = [];

    boolean system_packages_selected = false;

// DefaultDesktop::PrefferedWindowManager
//    global string window_manager = nil;

    global boolean using_patterns = false;

    global string add_on_products_list = nil;

    boolean init_popup_open = false;


// summary functions

/**
 * List selected resolvables of specified kind
 * @param what symbol specifying the kind of resolvables to select
 * @param format string format string to print summaries in
 * @return a list of selected resolvables
 */
global list<string> ListSelected (symbol what, string format) {
    if (format == "" || format == nil)
	format = "%1";
    list<map<string,any> > selected = Pkg::ResolvableProperties ("", what, "");
    selected = filter (map<string,any> r, selected, {
	return r["status"]:nil == `selected;
    });
    list<string> ret = maplist (map<string,any> r, selected, {
	string disp = r["summary"]:r["name"]:"";
	return sformat (format, disp);
    });
    return ret;
}

/**
 * Count the total size of packages to be installed
 * @return string formatted size of packages to be installed
 */
global string CountSizeToBeInstalled () {
    integer sz = 0;
    if (! Mode::installation () && !DirInstall::installing_into_dir )
    {
	list<string> packages = Pkg::GetPackages (`selected, true);
	foreach (string p, packages, {
	    sz = sz + Pkg::PkgSize (p);
	});
	// convert into kB
	sz = sz / 1024;
    }
    else // in case of fresh installation, disk is initially empty
    {
	map<string,list> du = Pkg::TargetGetDU ();
	foreach (string mp, list usages, du, {
	    sz = sz + usages[2]:0 - usages[1]:0;
	});
    }
    y2milestone ("Total size of packages to install (kB): %1", sz);
    return String::FormatSizeWithPrecision (sz*1024, 1, true);
}

/**
 * Return information about suboptimal distribution if relevant
 * @return string the information string or empty string
 */
global string InfoAboutSubOptimalDistribution () {
    // warn about suboptimal distribution
    // this depends on the kernel
    string dp = (string) SCR::Read(.content.DISTPRODUCT);
    if (dp==nil)
	dp = "";

    if (ProductFeatures::GetBooleanFeature ("software",
	"inform_about_suboptimal_distribution") &&
	Arch::i386 () && issubstring(dp, "DVD"))
    {
	string tmp = (string) SCR::Read(.proc.cpuinfo.value."0"."flags");
	list flags = (size (tmp) > 0) ? splitstring (tmp, " ") : [];

	// this depends on the cpu (lm = long mode)
	if (contains (flags, "lm"))
	{
	    // warning text
	    return _("Your computer is a 64-bit x86-64 system. However, you are trying to install a 32-bit distribution.");
	}
    }
    return "";
}

/**
 * Return the summary output lines
 * @param flags a list of flags, allowed are `product, `pattern, `selection,
 *  `size, `desktop
 * @return a list of the output lines
 */
global list<string> SummaryOutput (list<symbol> flags) {
    list<string> output = [ InfoAboutSubOptimalDistribution () ];
    if (contains (flags, `product))
	output = (list<string>)merge (output, ListSelected (`product, ""));
    if (contains (flags, `desktop))
	output = (list<string>)add (output, DefaultDesktop::Description ());
    if (contains (flags, `pattern))
	output = (list<string>)
	    merge (output, ListSelected (`pattern, "+  %1"));
    if (contains (flags, `selection))
	output = (list<string>)
	    merge (output, ListSelected (`selection, "+  %1"));
    if (contains (flags, `desktop))
	output = (list<string>)add (output,
	    // part of summary, %1 is size of packages (in MB or GB)
	    sformat (_("Size of Packages to Install: %1"),
		CountSizeToBeInstalled ()));

    output = filter (string o, output, {
	return o != "" && o != nil;
    });

    return output;
}

/**
 * Check if selected software fits on the partitions
 * @param init boolean true if partition sizes have changed
 * @return boolean true if selected software fits, false otherwise
 */
global boolean CheckDiskSize (boolean init) {
    if (init)
    {
	y2milestone ("Resetting space calculation");
	SpaceCalculation::GetPartitionInfo();
    }
    return SpaceCalculation::CheckDiskSize();
}

/**
 * Print the installatino proposal summary
 * @param flags a list of symbols, see above
 * @param boolean use_cache if true, use previous proposal if possible
 * @returnu a map proposal summary
 */
global map Summary (list<symbol> flags, boolean use_cache) {
    if (init_error != nil)
    {
	return $[
	    "warning" : init_error,
	    "warning_level" : `blocker,
	];
    }
    map ret = $[];
    if (! CheckDiskSize (! use_cache))
    {
	ret = $[
	    "warning" : ProductFeatures::GetFeature ("software","selection_type") == `fixed
		// summary warning
		? _("Not enough disk space.")
		// summary warning
		: _("Not enough disk space. Remove some packages in the single selection."),
	    "warning_level" : Mode::update() ? `warning : `blocker,
	];
    }
    ret["raw_proposal"] = SummaryOutput (flags);
    return ret;
}






// proposal control functions

global void ForceFullRepropose () {
    full_repropose = true;
}

global boolean SelectProduct ();

/**
 * Reset package selection, but keep objects of specified type
 * @param keep a list of symbols specifying type of objects to be kept
 */
global void Reset (list<symbol> keep) {
    list<map<string,any> > restore = [];
    foreach (symbol type, keep, {
	list<map<string,any> > selected = Pkg::ResolvableProperties ("", type, "");
	foreach (map<string,any> s, selected, {
	    restore = add (restore, $[
		"type" : type,
		"name" : s["name"]:""
	    ]);
	});
    });
    Pkg::PkgReset();
    foreach (map<string,any> res, restore, {
	Pkg::ResolvableInstall (res["name"]:"", (symbol)(res["type"]:nil));
    });
    system_packages_selected = false;
}

/**
 * Initialize add-on products provided by the installation source
 */
global void InitializeAddOnProducts() {
    if (Packages::add_on_products_list != nil)
    {
	y2milestone ("Found list of add-on products to preselect: %1", Packages::add_on_products_list);
	Packages::SelectProduct ();
	PackageCallbacksInit::SetMediaCallbacks();
	AddOnProduct::AddPreselectedAddOnProducts (Packages::add_on_products_list);
	Packages::add_on_products_list = nil; // do not select them any more
    }
}


    /*-----------------------------------------------------------------------
     * LOCALE FUNCTIONS
     *-----------------------------------------------------------------------*/

    /**
     * Add a package to list to be selected before proposal
     * Can be called only before the installation proposal, later doesn't
     * have any effect
     * @param package string package to be selected
     */
    global void addAdditionalPackage(string package)
    {
	additional_packages = add (additional_packages, package);
    }

    /**
     * Compute architecture packages
     * @return list(string)
     */
    define list<string> architecturePackages ()
    {
	list<string> packages = [];

	// remove unneeded / add needed packages for ppc
	if (Arch::ppc ())
	{
	    if (Arch::board_iseries ())
	    {
		packages = add (packages, "ibmsis");
		packages = add (packages, "scsi");
		packages = add (packages, "iprutils");
	    }

	    if (Arch::board_mac ())
	    {
		packages = add (packages, "mouseemu");
	    }

	    if (Arch::board_mac_new ()
		|| Arch::board_mac_old ())
	    {
		string pmac_board = "";
		list<map> pmac_compatible = (list<map>) SCR::Read(.probe.cpu);
		foreach (map pmac_compatible_tmp, pmac_compatible, {
		    pmac_board = pmac_compatible_tmp["system"]:"";
		});

		// install pbbuttonsd on PowerBooks and iMacs
		if (issubstring (pmac_board, "PowerBook")
		    || issubstring (pmac_board, "PowerMac2,1")
		    || issubstring (pmac_board, "PowerMac2,2")
		    || issubstring (pmac_board, "PowerMac4,1")
		    || issubstring (pmac_board, "iMac,1"))
		{
		    packages = add (packages, "pbbuttonsd");
		    packages = add (packages, "powerprefs");
		}

		// mol is fun, and needs root access to kmem
		packages = add (packages, "mol");
		packages = add (packages, "sudo");
	    }

	    if (Arch::ppc64 () && Arch::board_chrp ())
	    {
		packages = add (packages, "iprutils");
	    }
	}

	if (Arch::ia64 ())
	{
	    // install fpswa if the firmware has an older version
	    if (SCR::Execute(.target.bash, "/sbin/fpswa_check_version") != 0)
	    {
		packages = add (packages, "fpswa");
	    }
	}

	// add numactl on x86_64 with SMP
	if (Arch::has_smp () && Arch::x86_64 ())
	{
	    packages = add (packages, "numactl");
	    packages = add (packages, "irqbalance");
	}

	return packages;
    }


    /**
     * graphicPackages ()
     * Compute graphic (x11) packages
     * @return list(string)	list of rpm packages needed
     */
    define list<string> graphicPackages ()
    {
	list<string> packages = [];

	// don't setup graphics if running via serial console
	if (!Linuxrc::serial_console ())
	{
	    packages = [ "xorg-x11", "xorg-x11-server", "xorg-x11-server-glx",
		"libusb", "sax2", "sax2-gui", "sax2-ident", "sax2-tools",
		"sax2-libsax", "sax2-libsax-perl"];
	}

	y2milestone ("X11 Packages to install: %1", packages);
	return packages;
    }


    /**
     * Compute special packages
     * @return list(string)
     */
    define list<string> modePackages ()
    {
	list<string> packages = [];

	if (Linuxrc::vnc ())
	{
	    packages = add (packages, "tightvnc");
	    packages = add (packages, "yast2-qt");
	    packages = add (packages, "xorg-x11");
	    packages = add (packages, "fvwm2");
	    packages = add (packages, "sax2-tools");
	}

	if (Linuxrc::InstallInf ("Display_IP") != nil)
	{
	    packages = add (packages, "yast2-qt");
	    packages = add (packages, "xorg-x11");
	    packages = add (packages, "fvwm2");
	    packages = add (packages, "sax2-tools");
	}

	if (Linuxrc::braille ())
	{
	    packages = add (packages, "sbl");
	}
	y2milestone ("Installation mode packages: %1", packages);
	return packages;
    }


    /**
     * Compute special java packages
     * @return list(string)
     */
    define list<string> javaPackages ()
    {
	if (!Arch::alpha ())
	    return [];

	list<string> packages = [];

	list cpus = (list) SCR::Read (.probe.cpu);
	string model = cpus[0, "model"]:"EV4";
	string cputype = substring (model, 2, 1);

	if ((cputype == "6") || (cputype == "7") || (cputype == "8"))
	{
	    packages = ["cpml_ev6"];
	}
	else
	{
	    packages = ["cpml_ev5"];
	}
	return packages;
    }


    /**
     * Compute language dependant packages
     * @return list(string)
     */
    define list<string> languagePackages ()
    {
	list<string> packages = [];
	list<string> locales = Pkg::GetAdditionalLocales();
	locales = prepend (locales, Pkg::GetLocale());
	string transpac = "yast2-trans-";

	foreach (string loc, locales, {
	    if (Pkg::IsAvailable (transpac + loc))
		packages = add (packages, transpac + loc);
	    else if (Pkg::IsAvailable (transpac + substring (loc, 0, 2)))
		packages = add (packages, transpac + substring (loc, 0, 2));
	    else
		y2warning ("No locale package found for %1", loc);
	});
	y2milestone ("Language packages: %1", packages);
	return packages;
    }


    /**
     * Compute board (vendor) dependant packages
     * @return list(string)
     */
    define list<string> boardPackages ()
    {
	list<string> packages = [];

	list <map <string, any> > probe = (list <map <string, any> >)SCR::Read (.probe.system);
	packages = (list<string>)probe[0,"requires"]:[];
	y2milestone ("Board/Vendor specific packages: %1", packages);

	return packages;
    }


    /*
     * Additional kernel packages from control file
     * @return list<string> Additional Kernel packages
     */
    define list<string> ComputeAdditionalKernelPackages ()
    {
	string final_kernel = Kernel::GetFinalKernel ();
        integer pos = findfirstof(final_kernel, "-");
        string extension = substring(final_kernel, pos, size(final_kernel));
        list<string> akp = [];
        if (extension!="")
        {
	    list<string> kernel_packages = (list<string>)
		ProductFeatures::GetFeature ("software", "kernel_packages");
            if (size(kernel_packages) > 0 && kernel_packages != nil)
            {
                akp = maplist(string p , kernel_packages, {
                        return (p + "-" + extension);
                        });
            }
        }
        return akp;
    }

    /*-----------------------------------------------------------------------
     * GLOBAL FUNCTIONS
     *-----------------------------------------------------------------------*/


    global define list<string> ComputeSystemSelectionList ()
    {
	list<string> selection_list = [];
        // also add the 'laptop' selection if PCMCIA detected
        if (Arch::is_laptop ())
        {
            selection_list  =  Pkg::GetSelections( `available, "laptop");
        }

	list<string> addon_selections = (list<string>)
	    ProductFeatures::GetFeature ("software", "addon_selections");
        if (size(addon_selections) > 0 && "addon_selections"!=nil)
        {
            selection_list=(list<string>)union(selection_list,
                    addon_selections);
        }
        return selection_list;
    }

global list<string> ComputeSystemPatternList () {
    list<string> pattern_list = [];
    // also add the 'laptop' selection if PCMCIA detected
    if (Arch::is_laptop () || Arch::has_pcmcia ())
    {
	foreach (string pat_name, ["laptop", "Laptop"], {
	    list<map<string, any> > pat_list = Pkg::ResolvableProperties (pat_name, `pattern, "");
	    if (size (pat_list) > 0)
		pattern_list = add (pattern_list, pat_name);
	});
    }
    y2milestone ("System patterns: %1", pattern_list);
    return pattern_list;
}


    /**
     * Build and return list of packages which depends on the
     * the current target system and the preselected packages
     * (architecture, X11....)
     * @return list<string> packages
     */
    global define list<string> ComputeSystemPackageList ()
    {
	list<string> install_list =  architecturePackages ();

	install_list = (list<string>) union (install_list, modePackages ());
	install_list = (list<string>) union (install_list,
	                                     Storage::AddPackageList());
	install_list = (list<string>) union (install_list,
					     additional_packages);

	// Kernel is added in autoinstPackages () if autoinst is enabled
	if (!Mode::update () || !Mode::autoinst ())
	{
            list <string> kernel_pkgs = Kernel::ComputePackages ();
            list <string> kernel_pkgs_additional = ComputeAdditionalKernelPackages();
	    install_list = (list <string>) union (install_list, kernel_pkgs);
            if (size(kernel_pkgs_additional) > 0 && kernel_pkgs_additional != nil)
            {
	        install_list = (list <string>) union (install_list, kernel_pkgs_additional);
            }
        }

	if (Pkg::IsSelected("xorg-x11") && Linuxrc::vnc ())
	{
	    install_list = (list<string>) union (install_list, graphicPackages ());
	}
	else
	{
	    y2milestone ("Not selecting graphic packages");
	}

	if (Pkg::IsSelected("java"))
	{
	    install_list = (list<string>) union (install_list, javaPackages ());
	}
	else
	{
	    y2milestone ("Not selecting java packages");
	}

	install_list = (list<string>) union (install_list, languagePackages ());

	install_list = (list<string>) union (install_list, boardPackages ());

	// and the most flexible enhancement for other products
        // NOTE: not really flexible, because it requires the client
        // in the instsys, instead use <kernel-packages> in the control file.
	if (ProductFeatures::GetFeature ("software", "packages_transmogrify") != "")
	{
            list<string> tmp_list = (list<string>)
		WFM::CallFunction (ProductFeatures::GetStringFeature ("software", "packages_transmogrify"),
				   [ install_list ]);

            // Make sure we did not get a nil from calling the client, i.e.
            // if the client does not exist at all..
            if (tmp_list != nil)
            {
                install_list = tmp_list;
            }
	}

	list<string> packages = (list<string>)
	    ProductFeatures::GetFeature ("software", "packages");
        if (size(packages) > 0 && packages != nil )
        {
            y2milestone("Adding packages from control file: %1", packages);
            install_list = (list<string>) union (install_list, packages);
        }

	install_list = toset (install_list);
	y2milestone ("auto-adding packages: %1", install_list);
	return install_list;
    }

    /**
     * SetBaseSelection (string base name)
     * @param string base selection name
     * @return boolean
     */
    global define boolean SetBaseSelection (string basename)
    {
	list base_selections = Pkg::GetSelections (`selected, "base");
	string current_base_selection = base_selections[0]:"";
	if (current_base_selection != "")
	{
	    Reset ([`product]);
	    Pkg::ClearSelection (current_base_selection);
	}
	Pkg::SetSelection (basename);
	Pkg::ActivateSelections ();
	Pkg::PkgFreshen();
	Pkg::PkgSolve(false);
    }

/**
 * Check whether content file in the specified source is the same
 * as the one in the ramdisk
 * @param source integer the source ID to check
 * @return boolean true if content files match
 */
global boolean CheckContentFile (integer source) {
    y2milestone ("Checking content file");
    string instmode = Linuxrc::InstallInf("InstMode");
    if (! (instmode == nil || instmode == "cd" || instmode == "dvd"))
    {
	y2milestone ("Installing via network, not checking the content file");
	return true;
    }
    string media_content = Pkg::SourceProvideFile (source, 1, "/content");
    string media = (string)SCR::Read (.target.string, media_content);
    string ramdisk = (string)SCR::Read (.target.string, "/content");
    boolean ret = (media == ramdisk);
    y2milestone ("Content files are the same: %1", ret);
    return ret;
}

    /**
     * Initialize the installation sources
     */
    global void Init(boolean unused_param)
    {
	if (init_called)
	{
	    y2warning ("Packages::Init() already called");
	    return;
	}

	PackageCallbacksInit::InitPackageCallbacks ();

	//
	// Initialize package manager
	//
	init_error = nil;
	y2milestone ("Packages::Init()");
	// usual mountpoint for the source medium
	string base_url = "";

	if ( Mode::test () )
	{
	    // Fake values for testing purposes
	    base_url = "dir:///dist/next-i386";
	}
	else
	{
	    base_url = InstURL::installInf2Url ("");
	}

	// check if url contains "@" -> might be username/password, hide from logging
	string log_url = InstURL::HidePassword(base_url);
	y2milestone ("Initialize Package Manager: %1", log_url);

	// Set languages for packagemanager. Always set the UI language. Set
	// language for additional packages only in Stage::initial ().

	Pkg::SetLocale (Language::language);

	if (Stage::initial ())
	{
	    Pkg::SourceStartCache (true);			// dummy, so further calls to Pkg::Pkg* don't restart it

	    Pkg::SourceSetRamCache (false);

	    integer initial_source = nil;
	    while (initial_source == nil)
	    {
		map out = (map) SCR::Execute (.target.bash_output, "/bin/ls -d /*.gpg");
		foreach (string file, splitstring (out["stdout"]:"", "\n"), {
		    if (file != "")
			Pkg::ImportGPGKey (file, true);
		});
		initial_source = Pkg::SourceCreateBase (base_url, "");
		if (initial_source == -1 || initial_source == nil)
		{
		    y2error ("No source on '%1'", log_url);
		    // error in proposal, %1 is URL
		    init_error = sformat (_("No catalog found at '%1'."),
			log_url);
		    return;
		}
		if (! CheckContentFile (initial_source))
		{
		    string label = (string)SCR::Read (.content.PRODUCT);
		    // bug #159754, release the mounted CD
		    Pkg::SourceReleaseAll();
		    // message popup, %1 is product name
		    Popup::Message (sformat (_("Insert %1 CD 1"), label));
		    Pkg::SourceDelete (initial_source);
		    initial_source = nil;
		}
	    }

            // setup slidedir
            map productmap = Pkg::SourceProductData (initial_source);
            string datadir = productmap["datadir"]:"suse";
	    // FIXME: this is optional
	    string slidedir_find = "/" + datadir + "/setup/slide";
	    string dir = Pkg::SourceProvideOptionalFile (initial_source, 1,
		slidedir_find + "/directory.yast");
	    string slidedir = nil;
	    if (dir != nil)
		slidedir = Pkg::SourceProvideDir( initial_source, 1, slidedir_find );

	    string our_slidedir = (string)WFM::Read( .local.tmpdir, "" );
	    if (slidedir == nil) {
		y2error("No slide directory '%1' found on source '%2'.", slidedir_find, initial_source);
	    } else {
		// copy all files to our own copy
		WFM::Execute( .local.bash,  sformat( "cp -r %1/* %2/", slidedir, our_slidedir ) ) ;
	    }
	    y2milestone( "Setting up the slide directory local copy: %1",  our_slidedir);
	    SlideShow::SetSlideDir (our_slidedir);

	    string tmp_add_on_products = Pkg::SourceProvideOptionalFile (initial_source, 1, "/add_on_products");
	    if (tmp_add_on_products != nil)
	    {
		add_on_products_list = ((string)SCR::Read (.target.tmpdir)) + "/add_on_products";
		WFM::Execute (.local.bash, sformat ("cp %1 %2", tmp_add_on_products, add_on_products_list));
	    }
	    else
	    {
		add_on_products_list = nil;
	    }

            /* Check for Service Pack */
            boolean servicepack_available = false;
            if ((integer)WFM::Read(.local.size, servicepack_metadata) > 0)
            {
                y2milestone("Service Pack data available");
                servicepack_available = true;
            }

	    y2milestone ("No order file, doing single source installation");
	    theSources = [ initial_source ];

	    if (servicepack_available)
	    {
		string spdir = metadir + "/Service-Pack/CD1";
		WFM::Execute (.local.mkdir, spdir);
		y2milestone ("Filling %1", spdir);
		WFM::Execute(.local.bash, "tar -zxvf " +
		    servicepack_metadata + " -C " + spdir);
		string sp_url = "dir:" + spdir;
		integer sp_source = Pkg::SourceCreate (sp_url, "");
		// close the popup in order to be able to ask about the license
		if (init_popup_open)
		    UI::CloseDialog ();
		if (sp_source == -1)
		    Report::Error (_("Failed to integrate service pack source."));
		else if (! AddOnProduct::AcceptedLicenseAndInfoFile(sp_source))
		{
		    y2milestone ("service pack license rejected");
		    Pkg::SourceDelete (sp_source);
		}
		else
		{
		    if ((integer)WFM::Read (.local.size, spdir + "/installation.xml") > 0)
		    {
			AddOnProduct::WFIntegrate (spdir + "/installation.xml");
		    }
		    if ((integer)WFM::Read (.local.size, spdir + "/y2update.tgz") > 0)
		    {
			AddOnProduct::UpdateInstSys (spdir + "/y2update.tgz");
		    }
		    theSources = add (theSources, sp_source);
		    y2internal ("Service pack source: %1, changing to URL: %2", sp_source, base_url);
		    Pkg::SourceChangeUrl (sp_source, base_url);
		}
		if (init_popup_open)
		    UI::OpenDialog(`opt(`decorated ), `Label(_("Initializing catalogs...")));
	    }

	    if (ProductFeatures::GetFeature ("software", "selection_type") == `fixed)
	    {
                Pkg::SetSelection (ProductFeatures::GetStringFeature ("software", "base_selection"));
	    }
	}
	else	// cont or normal mode
	{
	    theSources = Pkg::SourceStartCache (true);
	    if (theSources == nil || size (theSources) <= 0)
	    {
		y2error ("Pkg::SourceStartCache failed");
		theSources = [];
	    }
	    else if ( Stage::cont ()    // rewrite URL if cd/dvd since ide-scsi might have changed it
		     && ((substring (base_url, 0, 2) == "cd")
			|| (substring (base_url, 0, 3) == "dvd")))
	    {
		foreach (integer source, theSources, {
		    map data = Pkg::SourceGeneralData (source);		// get source data
		    string url = data["url"]:"";
		    if ((substring (url, 0, 2) == "cd")			// source comes from cd/dvd
			|| (substring (url, 0, 3) == "dvd"))
		    {
                        string new_url = InstURL::RewriteCDUrl(url);
			y2milestone ("rewrite url: '%1'->'%2'", url, InstURL::HidePassword(new_url));
			Pkg::SourceChangeUrl (source, new_url);
		    }
		});
	    }
	}

	y2milestone ("theSources %1", theSources);
	y2milestone ("theSourceDirectories %1", theSourceDirectories);
	if (size (theSources) >= 0)
	{
	    init_called = true;
	}
	else
	{
	    import "PackageCallbacks";

	    // an error message
	    string errortext = sformat (_("Error while initializing package descriptions.
Check the log file %1 for more details."), Directory::logdir + "/y2log") +
		"\n" + Pkg::LastError();

	    // FIXME somewhere get correct current_label and wanted_label
	    string result = PackageCallbacks::MediaChange (errortext, base_url, "",
							   0, "", 1, "", false);
	}
	if( Mode::autoinst ())
	{
	    // In the autoyast mode it could be that the proposal
	    // screen will not be displayed. So the product will
	    // not be set. Bug 178831
	    SelectProduct ();
	}
    }


    define void SetSelectionAndComputeSystemPackages (string selection)
    {
        // set the new selection
        boolean ret = Pkg::SetSelection (selection);

        y2milestone ( "Selecting '%1' returns: %2", selection, ret );

        ret = Pkg::ActivateSelections();
        y2milestone ("Pkg::ActivateSelections() returns %1", ret);

        // add additional (internal) packages, like kernel etc.
	list<string> system_packages = Packages::ComputeSystemPackageList();
        Pkg::DoProvide (system_packages);
	Pkg::PkgFreshen();
	// fnfx and ial conflict (see bug 112949)
	if (contains (system_packages, "fnfx"))
	    Pkg::PkgTaboo ("ial");
        Pkg::PkgSolve(false);

        list selected_selections = Pkg::GetSelections( `selected, "base");
        selected_selections = union ( selected_selections, Pkg::GetSelections( `selected, "") );
        y2milestone( "INSTALLING software selection: %1", selected_selections );
    }


/**
 * Select the base product on the media for installation
 * @return boolean true on success
 */
global boolean SelectProduct () {
    Packages::Init (false); // argument ignored anyway...
    list<map<string,any> > products = Pkg::ResolvableProperties ("", `product, "");
    products = filter (map<string,any> p, products, {
	return p["category"]:"" == "base";
    });
    if (size (products) == 0)
    {
	y2milestone ("No base product found on media");
	return true;
    }
    list<map<string,any> >selected_products = filter (map<string,any> p, products, {
	return p["status"]:nil == `selected;
    });
    // no product selected -> select them all
    boolean ret = true;
    if (size (selected_products) == 0)
    {
	y2milestone ("No product selected so far...");
	foreach (map<string,any> p, products, {
	    y2milestone ("Selecting product %1", p["name"]:"");
	    ret = Pkg::ResolvableInstall (p["name"]:"", `product) && ret;
	});
    }
    return ret;
}

/**
 * Select system patterns
 * @param reselect boolean true to select only those which are alrady selected
 */
void SelectSystemPatterns (boolean reselect) {
    list<string> system_patterns = ComputeSystemPatternList ();
    // autoinstallation has patterns specified in the profile
    if (! Mode::autoinst ())
    {
	system_patterns = (list<string>)
	    toset (merge (system_patterns, Product::patterns));
	system_patterns = (list<string>)
	    toset (merge (system_patterns, DefaultDesktop::PatternsToSelect ()));
		// FIXME handle patterns to deselect as well
    }
    if (! reselect)
    {
	list<string> to_deselect = DefaultDesktop::PatternsToDeselect ();
	y2milestone ("Deselecting system patterns %1", to_deselect);
	foreach (string p, to_deselect, {
	    Pkg::ResolvableRemove (p, `pattern);
	});
	y2milestone ("Selecting system patterns %1", system_patterns);
	foreach (string p, system_patterns, {
	    Pkg::ResolvableInstall (p, `pattern);
	});
    }
    else
    {
	y2milestone ("Re-selecting system patterns %1", system_patterns);
	list<string>pats = filter (string p, system_patterns, {
	    list<map<string,any> > descrs = Pkg::ResolvableProperties (p, `pattern, "");
	    descrs = filter (map<string,any> descr, descrs, {
		return descr["status"]:nil == `selected;
	    });
	    return size (descrs) > 0;
	});
	y2milestone ("Selected patterns to be reselected: %1", pats);
	foreach (string p, pats, {
	    Pkg::ResolvableRemove (p, `pattern);
	    Pkg::ResolvableInstall (p, `pattern);
	});
    }
}

/**
 * Select system packages
 * @param reselect boolean true to select only those which are alrady selected
 */
void SelectSystemPackages (boolean reselect) {
    list<string> system_packages = ComputeSystemPackageList();
    if (! reselect)
    {
	y2milestone ("Selecting system packages %1", system_packages);
    }
    else
    {
	y2milestone ("Re-selecting new versions of system packages %1", system_packages);
	// first deselect the package (and filter selected ones)
	system_packages = filter (string p, system_packages, {
	    if (Pkg::IsProvided (p) || Pkg::IsSelected (p))
	    {
		Pkg::PkgDelete (p);
		return true;
	    }
	    return false;
	});
	y2milestone ("System packages to be reselected: %1", system_packages);
    }
    map <string, any> res = Pkg::DoProvide (system_packages);
    if (size (res) > 0)
    {
	foreach (string s, any a, res, {
	    y2warning ("Pkg::DoProvide failed for %1: %2", s, a);
	});
    }
}

/**
 * Select appropriate XEN kernel if the XEN pattern is selected
 */
void SelectXenKernel () {
    // check Xen pattern status
    list<map> xen_patterns  = Pkg::ResolvableProperties("xen_server", `pattern, "");

    // is the Xen pattern selected?
    boolean xen_selected = false;

    foreach(map pattern, xen_patterns,
    {
	if (pattern["status"]:`unknown == `selected)
	{
	    xen_selected = true;
	}
    });

    if (xen_selected)
    {
	// run the solver if a package is selected
	boolean run_solver = false;

	if (contains (Kernel::GetPackages (), "kernel-bigsmp"))
	{
	    run_solver = !Pkg::IsSelected("kernel-xenpae");

	    y2milestone("Selected Xen kernel: kernel-xenpae");
	    // install PAE Xen
	    Pkg::PkgNeutral("kernel-xen");
	    Pkg::PkgInstall("kernel-xenpae");
	}
	else
	{
	    run_solver = !Pkg::IsSelected("kernel-xen");

	    y2milestone("Selected Xen kernel: kernel-xen");
	    // install standard Xen
	    Pkg::PkgNeutral("kernel-xenpae");
	    Pkg::PkgInstall("kernel-xen");
	}

	y2milestone("run_solver: %1", run_solver);
	if (run_solver)
	{
	    if (! Pkg::PkgSolve(true))
	    {
		solve_errors = Pkg::PkgSolveErrors ();
	    }
	}
    }
}

/**
 * Make a proposal for package selection
 * @param force reset
 * @param re-initialize
 * @return map for the API proposal
 */
global map Proposal (boolean force_reset, boolean reinit, boolean simple) {
    UI::OpenDialog(`opt(`decorated ),
	// popup label
	`Label (_("Evaluating package selection...")));

    y2milestone ("Packages::Proposal: force_reset %1, reinit %2, lang '%3'",
	force_reset, reinit, Language::language);

    if ( force_reset )
    {
	Kernel::ProbeKernel();
	Packages::Reset ([`product]);
	reinit = true;
    }

    boolean initial_run = reinit || ! init_called;
    Init (false);

    if (init_error != nil)
    {
	UI::CloseDialog();
	return Summary ([], false);
    }

    if (initial_run)
    {
	// autoyast can configure AdditionalLocales
	// we don't want to overwrite this
	if( ! Mode::autoinst ())
	{
	    Pkg::SetAdditionalLocales ([Language::language]);
	}
    }

    SelectProduct ();

    if (ProductFeatures::GetFeature ("software", "selection_type") == `auto)
    {
	y2milestone ("Doing pattern-based software selection");

	SelectSystemPackages (system_packages_selected && ! initial_run);
	SelectSystemPatterns (system_packages_selected && ! initial_run);
	system_packages_selected = true;
	Pkg::PkgFreshen();
    }
    else if (ProductFeatures::GetFeature ("software","selection_type") == `fixed)
    {
	y2milestone ("Selection type: fixed");
    }
    else
    {
	y2error ("unknown value %1 for ProductFeatures::GetFeature (software, selection_type)",
	     (symbol)ProductFeatures::GetFeature ("software", "selection_type"));
    }

    if (! Pkg::PkgSolve (false))
    {
	solve_errors = Pkg::PkgSolveErrors ();
    }

    SelectXenKernel ();

    map ret = Summary (
	[ `product, `pattern, `selection, `size, `desktop ],
	false);
    // TODO simple proposal

    UI::CloseDialog();

    y2milestone ("Software proposal: %1", ret);

    return ret;
}

/**
 * Initialize the catalogs with popup feedback
 */
global void InitializeCatalogs() {
    // Intermediate contents of the software selection screen
    UI::OpenDialog(`opt(`decorated ), `Label(_("Initializing catalogs...")));
    init_popup_open = true;

    // intialize package source to get a list of selections
    Packages::Init (false);

    UI::CloseDialog ();
    init_popup_open = false;
}
/* EOF */
}
