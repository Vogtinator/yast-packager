/**
 * Module: 		SlideShowCallbacks.ycp
 *
 * Authors:		Gabriele Strattner <gs@suse.de>
 *			Klaus Kaempf <kkaempf@suse.de>
 *
 * Purpose: 		provides the Callbacks for SlideShow
 *
 */

{
    module "SlideShowCallbacks";

    textdomain "packager";

    import "Installation";
    import "Label";
    import "Mode";
    import "Stage";
    import "PackageCallbacks";
    import "Popup";
    import "SlideShow";
    import "Message";
    import "Directory";

    boolean _remote_provide = false;

    string pkg_inprogress = "";

    /**
     * Check for user button presses and handle them.
     *
     * @return true if user wishes to abort
     **/
    void HandleInput()
    {
	// any button = SlideShow::debug ? UI::PollInput() : UI::TimeoutUserInput( 10 );
	any button = UI::PollInput();

	// in case of cancel ask user if he really wants to quit installation
	if ( button == `abort || button == `cancel )
	{
	    if ( Mode::normal () )
	    {
		SlideShow::SetUserAbort(Popup::AnyQuestion( Popup::NoHeadline(),
						// popup yes-no
						 _("Do you really want\nto quit the installation?"),
						 Label::YesButton(),
						 Label::NoButton(),
						 `focus_no ));
	    }
	    else if ( Stage::initial () )
	    {
		SlideShow::SetUserAbort(Popup::ConfirmAbort( `unusable ));
	    }
	    else	// Mode::update (), Stage::cont ()
	    {
		SlideShow::SetUserAbort(Popup::ConfirmAbort( `incomplete ));
	    }

	    if (SlideShow::GetUserAbort())
	    {
		SlideShow::AppendMessageToInstLog (_("Aborted"));
	    }
	}
	else
	{
	    SlideShow::HandleInput( button );
	}
    }


    /**
     *  at start of file providal
     */
    global boolean StartProvide( string name, integer archivesize, boolean remote )
    {
	pkg_inprogress = name;

	if ( remote )
	{
	    SlideShow::SlideProvideStart (name , archivesize, remote);
	    _remote_provide = true;
	}

	return true;
    }


    /**
     * during file providal
     */
    global boolean ProgressProvide( integer percent )
    {
	if (_remote_provide)
	{
	    SlideShow::UpdateCurrentPackageProgress ( percent );
	}
	HandleInput();
	return ! SlideShow::GetUserAbort();
    }


    /**
     * during file providal
     */
    global string DoneProvide( integer error, string reason, string name )
    {
	if ( _remote_provide )
	{
	    SlideShow::UpdateCurrentPackageProgress( 100 );
	    _remote_provide = false;
	}
	if (SlideShow::GetUserAbort())
	{
	    return "CANCEL";
	}
	if (error != 0)
	{
	    return PackageCallbacks::DoneProvide( error, reason, name );
	}

	return "";
    }


    global void ScriptStart(string patch_name, string patch_version, string patch_arch, string script_path, boolean installation)
    {
	string patch_full_name = PackageCallbacks::FormatPatchName(patch_name, patch_version, patch_arch);
	y2milestone("ScriptStart: patch:%1, script:%2, installation:%3", patch_full_name, script_path, installation);

	// reset the progressbar
	if (UI::WidgetExists(`progressCurrentPackage))
	{
	    UI::ChangeWidget(`progressCurrentPackage, `Label, patch_full_name);
	    UI::ChangeWidget(`progressCurrentPackage, `Value, 0);
	}

	// message in the installation log widget, %1 is a patch name which contains the script
	string log_line = sformat(_("Starting script %1"), patch_full_name);

	SlideShow::AppendMessageToInstLog(log_line);
    }

    global boolean ScriptProgress (boolean ping, string output)
    {
	y2milestone("ScriptProgress: ping:%1, output: %2", ping, output);

	if (output != nil && output != "")
	{
	    string log_line = output;

	    // remove the trailing new line character
	    if (substring(output, size(output) - 1, 1) == "\n")
	    {
		output = substring(output, 0, size(output) - 1);
	    }

	    // add the output to the log widget
	    SlideShow::AppendMessageToInstLog(output);
	}

	any input = UI::PollInput ();
	y2milestone("input: %1", input);

	if (input == `abort || input == `close)
	    return false;

	return true;
    }

    global void ScriptProblem(string description)
    {
	y2milestone("ScriptProblem: %1", description);
	Popup::Error(description);
    }

    global void ScriptFinish()
    {
	y2milestone("ScriptFinish");
    }

    global void Message(string patch_name, string patch_version, string patch_arch, string message)
    {
	string patch_full_name = PackageCallbacks::FormatPatchName(patch_name, patch_version, patch_arch);
	y2milestone("Message (%1): %2", patch_full_name, message);

	if (patch_full_name != "")
	{
	    // label, %1 is patch name with version and architecture
	    patch_full_name = sformat(_("Patch %1\n\n"), patch_full_name);
	}

	Popup::LongMessage(patch_full_name + message);
    }



    //--------------------------------------------------------------------------
    // slide show

    term YesNoButtonBox()
    {
	term yes_button = `PushButton(`id(`yes), `opt(`key_F10), Label::YesButton());
	term no_button  = `PushButton(`id(`no_button), `opt(`default, `key_F9), Label::NoButton());

	return `HBox(
	    `HStretch(),
	    `HWeight( 1, yes_button),
	    `HSpacing(2),
	    `HWeight( 1, no_button ),
	    `HStretch()
	);
    }

    // never show the disk space warning popup during autoinstallation
    boolean ask_again = Mode::autoinst() ? false : true;
    // true == continue with the installtion
    boolean user_input = true;

    boolean YesNoAgainWarning(string message)
    {
	if (!ask_again)
	{
	    return user_input;
	}

	term icon = `Empty();

	// show the warning icon if possible
	map ui_capabilities = UI::GetDisplayInfo();

	if ( ui_capabilities[ "HasLocalImageSupport" ]:false )
	{
	    icon = `Image( Directory::icondir + "32x32/apps/msg_warning.png", "" );
	}

	term content = `MarginBox(1.5, 0.5,
	    `VBox(
		`HBox(
		    `VCenter(icon),
		    `HSpacing(1),
		    `VCenter(`Heading(Label::WarningMsg())),
		    `HStretch()
		    ),
		`VSpacing(0.2),
		`Left( `Label( message ) ),
		`VSpacing(0.2),
		`Left(`CheckBox(`id(`dont_ask), Message::DoNotShowMessageAgain())),
		`VSpacing(0.5),
		YesNoButtonBox()
	    )
	);

	UI::OpenDialog(`opt(`decorated), content);

	any ret = UI::UserInput();

	ask_again = (boolean) UI::QueryWidget(`id(`dont_ask), `Value);

	if (!ask_again)
	{
	    // remember the user input
	    user_input = (ret == `yes);
	}

	UI::CloseDialog();

	return ret == `yes;
    }



    /**
     * Callback that will be called by the packager for each RPM as it is being installed or deleted.
     * Note: The packager doesn't call this directly - the corresponding wrapper callbacks do
     * and pass the "deleting" flag as appropriate.
     **/
    global void DisplayStartInstall(string pkg_name, string pkg_description, integer pkg_size, boolean deleting )
    {
	SlideShow::SlideDisplayStart( pkg_name, pkg_description, pkg_size, deleting );
	HandleInput();

	// warn user about exhausted diskspace during installation (not if deleting packages)
	if (!deleting && ask_again)
	{
	    map<string, list<integer> > pkgdu = Pkg::PkgDU(pkg_inprogress);

	    y2debug("PkgDU(%1): %2", pkg_inprogress, pkgdu);

	    if (pkgdu != nil)
	    {
		// check each mount point
		foreach(string part, list<integer> data, pkgdu,
		    {
			// skip read-only partitions, the package cannot be installed anyway
			if (data[3]:0 == 1)
			{
			    y2debug("Skipping read-only partition %1", part);
			    continue;
			}

			string target_dir = Installation::destdir + part;
			integer disk_available = Pkg::TargetAvailable(target_dir);

			y2debug("partition: %1 (%2), available: %3", part, target_dir, disk_available);

			if (disk_available < data[2]:0)
			{
			    y2warning("Not enought free space in %1 (%2): available: %3, required: %4", part, target_dir, disk_available, data[2]:0);

			    boolean cont = YesNoAgainWarning(
				// warning popup - %1 is directory name (e.g. /boot)
				sformat(_("The disk space in partition %1 is nearly exhausted.\nContinue with the installation?"), part));

			    if (!cont)
			    {
				SlideShow::SetUserAbort(true);
			    }

			    // don't check the other partitions
			    break;
			}
		    }
		);
	    }
	    else
	    {
		// disk usage for each partition is not known
		// assume that all files will be installed into the root directory
		integer disk_available = Pkg::TargetAvailable(Installation::destdir);

		y2milestone("Available space (%1): %2", Installation::destdir, disk_available);

		if (disk_available < pkg_size)
		{
		    y2warning("Not enough free space in %1: available: %2, required: %3", Installation::destdir, disk_available, pkg_size);

		    boolean cont = YesNoAgainWarning(
			// yes-no popup
			_("The disk space is nearly exhausted.\nContinue with the installation?")
		    );

		    if (!cont)
		    {
			SlideShow::SetUserAbort(true);
		    }
		}
	    }
	}
    }


    /**
     *  at start of package install
     */
    global boolean StartPackage( string name, string summary, integer install_size, boolean is_delete )
    {
	PackageCallbacks::_package_name = name;
	PackageCallbacks::_package_size = install_size;
	PackageCallbacks::_deleting_package = is_delete;

	DisplayStartInstall( name,
				    summary,
				    install_size,
				    is_delete);

	// dummy value, libzypp callback is void()
	return true;
    }


    /**
     * ProgressPackage percent
     **/
    global boolean ProgressPackage ( integer pkg_percent )
    {
	HandleInput();

	if (!SlideShow::GetUserAbort())
	{
	    SlideShow::UpdateCurrentPackageProgress ( pkg_percent );
	}

	if (SlideShow::GetUserAbort())
	{
	    y2internal("Aborted at %1%%", pkg_percent);
	}

	return ! SlideShow::GetUserAbort();
    };

    /**
     * at end of install
     * just to override the PackageCallbacks default (which does a 'CloseDialog' :-})
     */
    global string DonePackage( integer error, string reason )
    {
	if (SlideShow::GetUserAbort())
	    return "I";
	SlideShow::UpdateCurrentPackageProgress (100);

	string ret = "";
	if (error != 0)
	{
	    ret = PackageCallbacks::DonePackage( error, reason );
	}
	if (size (ret) == 0 || tolower (substring (ret, 0, 1)) != "r")
	{
	    SlideShow::SlideDisplayDone(
		PackageCallbacks::_package_name,
		PackageCallbacks::_package_size,
		PackageCallbacks::_deleting_package);
	}
	return ret;
    }


    /**
     *  at start of file providal
     */
    global void StartDeltaProvide( string name, integer archivesize )
    {
	SlideShow::SlideGenericProvideStart (name , archivesize, _("Downloading delta RPM %1 (download size %2)"), true /*remote*/);
	_remote_provide = true;
    }

    /**
     *  at start of file providal
     */
    global void StartDeltaApply( string name )
    {
	SlideShow::SlideDeltaApplyStart (name);
	_remote_provide = true;
    }
    /**
     *  at start of file providal
     */
    global void StartPatchProvide( string name, integer archivesize )
    {
	SlideShow::SlideGenericProvideStart (name , archivesize, _("Downloading patch RPM %1 (download size %2)"), true /*remote*/);
	_remote_provide = true;
    }

    /**
     * during file providal
     */
    global void ProgressDeltaApply( integer percent )
    {
	SlideShow::UpdateCurrentPackageProgress ( percent );
    }

    /**
     *  at end of file providal
     */
    global void FinishPatchDeltaProvide()
    {
	_remote_provide = false;
    }

    global void ProblemDeltaDownload (string descr) {
	_remote_provide = false;
	// error in installation log, %1 is detail error description
	SlideShow::AppendMessageToInstLog (sformat (_("Failed to download delta RPM: %1"), descr));
    }

    global void ProblemDeltaApply (string descr) {
	_remote_provide = false;
	// error in installation log, %1 is detail error description
	SlideShow::AppendMessageToInstLog (sformat (_("Failed to apply delta RPM: %1"), descr));
    }

    global void ProblemPatchDownload (string descr) {
	_remote_provide = false;
	// error in installation log, %1 is detail error description
	SlideShow::AppendMessageToInstLog (sformat (_("Failed to download patch RPM: %1"), descr));
    }

    /**
     * change of source
     * source: 0 .. n-1
     * media:  1 .. n
     **/
    global void CallbackSourceChange( integer source, integer media)
    {
	PackageCallbacks::SourceChange( source, media );		// inform PackageCallbacks about the change
	SlideShow::SetCurrentCdNo( source, media );
	SlideShow::UpdateCurrentPackageProgress(0);
	SlideShow::UpdateAllCdProgress(false);
    };
}
