/**
 * Module: 		SlideShowCallbacks.ycp
 *
 * Authors:		Gabriele Strattner <gs@suse.de>
 *			Klaus Kaempf <kkaempf@suse.de>
 *
 * Purpose: 		provides the Callbacks for SlideShow
 *
 */

{
    module "SlideShowCallbacks";

    textdomain "packager";

    import "Installation";
    import "Label";
    import "Mode";
    import "Stage";
    import "PackageCallbacks";
    import "Popup";
    import "SlideShow";

    boolean shutup = ( Mode::autoinst() )?(true):(false);	// show the disk space warning popup only once and never in autoinstall
    boolean _remote_provide = false;
    boolean user_abort = false;


    /**
     * Check for user button presses and handle them.
     *
     * @return true if user wishes to abort
     **/
    void HandleInput()
    {
	// any button = SlideShow::debug ? UI::PollInput() : UI::TimeoutUserInput( 10 );
	any button = UI::PollInput();

	// in case of cancel ask user if he really wants to quit installation
	if ( button == `abort || button == `cancel )
	{
	    if ( Mode::normal () )
	    {
		user_abort = Popup::AnyQuestion( Popup::NoHeadline(),
						// popup yes-no
						 _("Do you really want\nto quit the installation?"),
						 Label::YesButton(),
						 Label::NoButton(),
						 `focus_no );
	    }
	    else if ( Stage::initial () )
	    {
		user_abort = Popup::ConfirmAbort( `unusable );
	    }
	    else	// Mode::update (), Stage::cont ()
	    {
		user_abort = Popup::ConfirmAbort( `incomplete );
	    }
	    if (user_abort)
	    {
		SlideShow::AppendMessageToInstLog (_("Aborted"));
	    }
	}
	else
	{
	    SlideShow::HandleInput( button );
	}
    }


    /**
     *  at start of file providal
     */
    global boolean StartProvide( string name, integer archivesize, boolean remote )
    {
	if ( remote )
	{
	    SlideShow::SlideProvideStart (name , archivesize, remote);
	    _remote_provide = true;
	}

	return true;
    }


    /**
     * during file providal
     */
    global boolean ProgressProvide( integer percent )
    {
	if (_remote_provide)
	{
	    SlideShow::UpdateCurrentPackageProgress ( percent );
	}
	HandleInput();
	return ! user_abort;
    }


    /**
     * during file providal
     */
    global string DoneProvide( integer error, string reason, string name )
    {
	if ( _remote_provide )
	{
	    SlideShow::UpdateCurrentPackageProgress( 100 );
	    _remote_provide = false;
	}
	if (user_abort)
	{
	    return "CANCEL";
	}
	if (error != 0)
	{
	    return PackageCallbacks::DoneProvide( error, reason, name );
	}

	return "";
    }


    global void ScriptStart(string patch_name, string patch_version, string patch_arch, string script_path, boolean installation)
    {
	string patch_full_name = PackageCallbacks::FormatPatchName(patch_name, patch_version, patch_arch);
	y2milestone("ScriptStart: patch:%1, script:%2, installation:%3", patch_full_name, script_path, installation);

	// reset the progressbar
	if (UI::WidgetExists(`progressCurrentPackage))
	{
	    UI::ChangeWidget(`progressCurrentPackage, `Label, patch_full_name);
	    UI::ChangeWidget(`progressCurrentPackage, `Value, 0);
	}

	// message in the installation log widget, %1 is a patch name which contains the script
	string log_line = sformat(_("Starting script %1"), patch_full_name);

	SlideShow::AppendMessageToInstLog(log_line);
    }

    global boolean ScriptProgress (boolean ping, string output)
    {
	y2milestone("ScriptProgress: ping:%1, output: %2", ping, output);

	if (output != nil && output != "")
	{
	    string log_line = output;

	    // remove the trailing new line character
	    if (substring(output, size(output) - 1, 1) == "\n")
	    {
		output = substring(output, 0, size(output) - 1);
	    }

	    // add the output to the log widget
	    SlideShow::AppendMessageToInstLog(output);
	}

	any input = UI::PollInput ();
	y2milestone("input: %1", input);

	if (input == `abort || input == `close)
	    return false;

	return true;
    }

    global void ScriptProblem(string description)
    {
	y2milestone("ScriptProblem: %1", description);
	Popup::Error(description);
    }

    global void ScriptFinish()
    {
	y2milestone("ScriptFinish");
    }

    global void Message(string patch_name, string patch_version, string patch_arch, string message)
    {
	string patch_full_name = PackageCallbacks::FormatPatchName(patch_name, patch_version, patch_arch);
	y2milestone("Message (%1): %2", patch_full_name, message);

	if (patch_full_name != "")
	{
	    // label, %1 is patch name with version and architecture
	    patch_full_name = sformat(_("Patch %1\n\n"), patch_full_name);
	}

	Popup::LongMessage(patch_full_name + message);
    }



    //--------------------------------------------------------------------------
    // slide show


    /**
     * Callback that will be called by the packager for each RPM as it is being installed or deleted.
     * Note: The packager doesn't call this directly - the corresponding wrapper callbacks do
     * and pass the "deleting" flag as appropriate.
     *
     * return true: go on with installation
     *        false: abort installation
     **/
    global boolean DisplayStartInstall( string  pkg_name,
					       string  pkg_description,
					       integer pkg_size,
					       integer disk_usage,
					       integer disk_capacity,
					       boolean deleting )
    {
	SlideShow::SlideDisplayStart( pkg_name, pkg_description, pkg_size, deleting );
	HandleInput();

	integer disk_percentage_left = (disk_usage * 100) / disk_capacity;

	// warn user about exhausted diskspace during installation (not if deleting packages)
	if (! deleting)
	{
//	    if ( disk_percentage_left > 95 && !shutup)
// changed the condition because it fails on large disks (#115235)
	    if (disk_usage + 2 * pkg_size > disk_capacity && ! shutup)
	    {
		boolean cont = Popup::AnyQuestion( Label::WarningMsg(),
						   // yes-no popup
						   _("The disk space is nearly exhausted.\nContinue with the installation?"),
						   Label::YesButton(),
						   Label::NoButton(),
						   `focus_no );

		if (!cont)
		    return false;
		else
		    shutup = true;
	    }
	}

	return ! user_abort;
    }


    /**
     *  at start of package install
     */
    global boolean StartPackage( string name, string summary, integer install_size, boolean is_delete )
    {
	PackageCallbacks::_package_name = name;
	PackageCallbacks::_package_size = install_size;
	PackageCallbacks::_deleting_package = is_delete;

	return DisplayStartInstall( name,
				    summary,
				    install_size,
				    Pkg::TargetUsed( Installation::destdir ),
				    Pkg::TargetCapacity( Installation::destdir ),
				    is_delete);
    }


    /**
     * ProgressPackage percent
     **/
    global boolean ProgressPackage ( integer pkg_percent )
    {
	HandleInput();
	SlideShow::UpdateCurrentPackageProgress ( pkg_percent );

	return ! user_abort;
    };

    /**
     * at end of install
     * just to override the PackageCallbacks default (which does a 'CloseDialog' :-})
     */
    global string DonePackage( integer error, string reason )
    {
	if (user_abort)
	    return "I";
	SlideShow::UpdateCurrentPackageProgress (100);

	string ret = "";
	if (error != 0)
	{
	    ret = PackageCallbacks::DonePackage( error, reason );
	}
	if (size (ret) == 0 || tolower (substring (ret, 0, 1)) != "r")
	{
	    SlideShow::SlideDisplayDone(
		PackageCallbacks::_package_name,
		PackageCallbacks::_package_size,
		PackageCallbacks::_deleting_package);
	}
	return ret;
    }


    /**
     *  at start of file providal
     */
    global void StartDeltaProvide( string name, integer archivesize )
    {
	SlideShow::SlideGenericProvideStart (name , archivesize, _("Downloading delta RPM %1 (download size %2)"), true /*remote*/);
	_remote_provide = true;
    }

    /**
     *  at start of file providal
     */
    global void StartDeltaApply( string name )
    {
	SlideShow::SlideDeltaApplyStart (name);
	_remote_provide = true;
    }
    /**
     *  at start of file providal
     */
    global void StartPatchProvide( string name, integer archivesize )
    {
	SlideShow::SlideGenericProvideStart (name , archivesize, _("Downloading patch RPM %1 (download size %2)"), true /*remote*/);
	_remote_provide = true;
    }

    /**
     * during file providal
     */
    global void ProgressDeltaApply( integer percent )
    {
	SlideShow::UpdateCurrentPackageProgress ( percent );
    }

    /**
     *  at end of file providal
     */
    global void FinishPatchDeltaProvide()
    {
	_remote_provide = false;
    }

    global void ProblemDeltaDownload (string descr) {
	_remote_provide = false;
	// error in installation log, %1 is detail error description
	SlideShow::AppendMessageToInstLog (sformat (_("Failed to download delta RPM: %1"), descr));
    }

    global void ProblemDeltaApply (string descr) {
	_remote_provide = false;
	// error in installation log, %1 is detail error description
	SlideShow::AppendMessageToInstLog (sformat (_("Failed to apply delta RPM: %1"), descr));
    }

    global void ProblemPatchDownload (string descr) {
	_remote_provide = false;
	// error in installation log, %1 is detail error description
	SlideShow::AppendMessageToInstLog (sformat (_("Failed to download patch RPM: %1"), descr));
    }

    /**
     * change of source
     * source: 0 .. n-1
     * media:  1 .. n
     **/
    global void CallbackSourceChange( integer source, integer media)
    {
	PackageCallbacks::SourceChange( source, media );		// inform PackageCallbacks about the change
	SlideShow::SetCurrentCdNo( source, media );
	SlideShow::UpdateCurrentPackageProgress(0);
	SlideShow::UpdateAllCdProgress();
    };
}
