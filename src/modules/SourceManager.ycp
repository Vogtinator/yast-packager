/**
 * File:	modules/SourceManager.ycp
 * Package:	Package Source Management
 * Summary:	SourceManager settings, input and output functions
 * Authors:	Anas Nashif <nashif@suse.de>
 * Status:      Work in Progress
 *
 * $Id$
 *
 * Representation of the configuration of source-manager.
 * Input and output routines.
 */

{

textdomain "packager";
module "SourceManager";

import "Progress";
import "Report";
import "Popup";
import "Label";
import "Summary";
import "Message";
import "HTML";
import "Arch";
import "Mode";
import "Stage";
import "URL";


global list<integer> newSources = [];

global integer numSources = 0;
    
global list<integer> sourceStates = [];

global list<map<string,any> > sourceStatesIn = [];

global list<map<string,any> > sourceStatesOut = [];


list<map> slp_sources = [];

string pm_init_blocker = "";

global map url_tokens = $[];

global string currentUrl = "";

/**
 * Prototypes
 */
global boolean Modified();

/**
 * Data was modified?
 */
global boolean modified = false;

/**
 */
global boolean proposal_valid = false;

/**
 * Abort function
 * return boolean return true if abort
 */
global boolean AbortFunction() {
    return false;
    }

/**
 * Abort function
 * @return boolean return true if abort
 */
global define boolean Abort() ``{
    if(AbortFunction != nil)
    {
	return AbortFunction () == true;
    }
    return false;
}

/**
 * Data was modified?
 * @return true if modified
 */
global boolean Modified() {
    y2debug("modified=%1",modified);
    //return modified;
    return (sourceStatesIn != sourceStatesOut);
}

global boolean ReadSources()
{
    boolean success = Pkg::SourceStartManager( false );
    if (!success)
        return success;
    sourceStates = Pkg::SourceStartCache ( false );
    sourceStatesIn = Pkg::SourceEditGet();
    sourceStatesOut = sourceStatesIn;
    return true;
}

/*
 * Disabled for now
global list<map> ReadSLPSources() {
    import "SLP";
    list<map> _slp_sources = SLP::FindSrvs("service:install.suse", "");
    _slp_sources = maplist (map s, _slp_sources, ``{
               s["attr"] = SLP::GetAttrMap(s["srvurl"]:"");
               return s;
            });

    _slp_sources = filter(map s , _slp_sources, 
            ``(issubstring(s["attr","machine"]:"", Arch::architecture())));

    return _slp_sources;
}
*/

/**
 * Read all source-manager settings
 * @return true on success
 */
global boolean Read() {

    /* SourceManager read dialog caption */
    string caption = _("Initializing Available Catalogs");

    integer steps = 2;


    // We do not set help text here, because it was set outside
    Progress::New( caption, " ", steps, [
	    /* Progress stage 1/3 */
	    _("Read configured catalogs"),
	    /* Progress stage 2/3 */
	    _("Detect available catalogs via SLP")
	], [
	    /* Progress step 1/3 */
	    _("Reading configured catalogs..."),
	    /* Progress step 2/3 */
	    _("Detecting available catalogs..."),
	    /* Progress finished */
	    _("Finished")
	],
	""
    );

    // read database
    if(Abort()) return false;
    Progress::NextStage();


    /* Error message */
    if(!ReadSources()) Report::Error(_("Cannot read catalogs."));

    // read another database
    if(Abort()) return false;
    Progress::NextStep();


    /* Error message */
    if(false) Report::Error(_("Cannot detect availabe catalogs."));

    if(Abort()) return false;
    /* Progress finished */
    Progress::NextStage();

    // slp_sources = ReadSLPSources();
    
    y2debug ("slp catalogs: %1", slp_sources);

    if(Abort()) return false;
    modified = false;
    return true;
}

/**
 * Commit changed sources
 */ 
global boolean CommitSources() {
    y2debug("In: %1  Out: %2",   sourceStatesIn, sourceStatesOut );
    boolean success = false;
    while (true)
    {
        success = Pkg::SourceEditSet( sourceStatesOut );
        if ( !success ) {
	    // popup message header
            string _msg1 = _("Unable to save changes to the catalog
                    repository.
");
            string err = Pkg::LastErrorId();
	    // popup message, after message header, header of details
            string _msg2 = _("Details:") + "\n" + Pkg::LastError();
	    // end of popup message, question
            _msg2 = _msg2 + "\n" + _("Try again?");

            boolean tryagain = Popup::YesNo( _msg1 + "\n" + _msg2 );
            if (tryagain )
                continue;
            else
                break;
        }
        else
        {
            break;
        }
    }
    return success;
}

/**
 * Write all source-manager settings
 * @return true on success
 */
global boolean Write() {
    
    /* SourceManager read dialog caption */
    string caption = _("Saving Catalog Configuration");

    integer steps = 1;

    // We do not set help text here, because it was set outside
    Progress::New(caption, " ", steps, [
	    /* Progress stage 1/1 */
	    _("Write catalog settings"),
	], [
	    /* Progress step 1/1 */
	    _("Writing the settings..."),

	    /* Progress finished */
	    _("Finished")
	],
	""
    );

    // write settings
    if(Abort()) return false;
   
    Progress::NextStage();
    /* Error message */

    boolean exit = CommitSources();

        
    
    if(Abort()) return false;
    /* Progress finished */
    Progress::NextStage();

    if(Abort()) return false;
    
    return exit;
}

/**
 * Get all source-manager settings from the first parameter
 * (For use by autoinstallation.)
 * @param settings The YCP structure to be imported.
 * @return boolean True on success
 */
global boolean Import (map settings) {
    return true;
}

/**
 * Dump the source-manager settings to a single map
 * (For use by autoinstallation.)
 * @return map Dumped settings (later acceptable by Import ())
 */
global map Export () {
    return $[];
}




global boolean CreateLocalMetaData ( 
        integer SrcId, 
        string metaDir,
        string slidedir,
        string descrDir, 
        string prodDir) {

    boolean  all_sources_ok=true;
    string localdir = metaDir+"/"+descrDir;
    WFM::Execute (.local.mkdir, localdir);
    y2debug("created local dir : %1", localdir );
    string datadir = Pkg::SourceProvideDir (SrcId, 1, descrDir+"/media.1");
    if (datadir != nil)
    {
        WFM::Execute (.local.mkdir, localdir+"/media.1");
        WFM::Execute (.local.bash, "/bin/cp " + datadir + "/* " + localdir+"/media.1");
    }
    else
    {
        y2error ("media doesn't provide %1", descrDir + "/media.1");
        if (Popup::AnyQuestion (
                    //	Popup::NoHeadline(),
		    // popup headline
                    _("Reading Media Description Failed"),
                    sformat (
			// popup message, %1 is filename
                        _("Cannot read media description for %1.
                            Packages from this media cannot be installed."), descrDir),
                    Label::IgnoreButton (),
                    Label::AbortButton (),
                    `cancel))
        {
            return false;
        }
        else
        {
            all_sources_ok = false;
        }
    }

    // content file
    datadir = Pkg::SourceProvideFile (SrcId, 1, descrDir+"/content");
    WFM::Execute (.local.bash, "/bin/cp " + datadir + " " + localdir + "/content");

    // DESCRDIR
    WFM::Execute (.local.bash, "/bin/grep DESCRDIR " + localdir + "/content > /tmp/descrdir");
    string descrline = (string) WFM::Read (.local.string, "/tmp/descrdir");
    list<string> descrsplit = splitstring (descrline, " \t\n");
    string _descrdir = descrsplit[1]:"";
    if (size (_descrdir) > 0)
    {
        y2milestone ("descrdir %1", _descrdir);
        WFM::Execute (.local.mkdir, localdir+"/"+_descrdir);
        datadir = Pkg::SourceProvideDir (SrcId, 1, descrDir+"/"+_descrdir);
        if (datadir != nil)
        {
            WFM::Execute (.local.bash, "/bin/cp " + datadir + "/* " +localdir+"/"+_descrdir);
        } else {
            y2error("Error providing %1", _descrdir );
        }
    }

    // copy GPG keys if there are any

    string directory_file = Pkg::SourceProvideFile (
	SrcId, 1, descrDir + "/directory.yast");

    string directory_str = (string)
	WFM::Read (.local.string, directory_file);
    list<string> directory = splitstring (directory_str, "\n");
    directory = filter (string d, directory, {
	return substring (d, 0, 10) == "gpg-pubkey";
    });
    y2milestone ("GPG keys to be copied: %1", directory);
    foreach (string k, directory, {
	string file = Pkg::SourceProvideFile (
	    SrcId, 1, descrDir + "/" + k);
	WFM::Execute (.local.bash,
	    "cp /" + file + " " + localdir);
    });

    // slide show

    if (size (_descrdir) > 5)
    {
        string tmp = substring (_descrdir, 0, size (_descrdir) - 5) + "slide";
        y2milestone("slide dir: %1", tmp );
        WFM::Execute (.local.mkdir, localdir+"/"+tmp);
        // FIXME: SourceProvideDir can't handle dirs with subdirs
        datadir = Pkg::SourceProvideDir (SrcId, 1, descrDir+"/"+tmp);
        // datadir = "/var/adm/YaST/InstSrcManager/IS_CACHE_0x00000001/MEDIA" + orderdir+"/"+tmp;
        y2milestone ("tmp=%1, datadir=%2", tmp, datadir);
        if (datadir != nil)
        {
            y2milestone ("copy slide show %1 %2", datadir, slidedir);
            WFM::Execute (.local.bash, "/bin/cp -r " + datadir + "/* " + slidedir);

            // if directory is empty, remove it.
            WFM::Execute (.local.bash, "/bin/rmdir " + slidedir);
        }
    }

    return all_sources_ok;

}


/**
 * Get Source ID by index 
 */
global integer GetSrcIdByIndex(integer idx)   {
    
    integer SrcId = sourceStatesOut[idx, "SrcId"]:-1;
  
    return SrcId;
}

/**
 * Set current used source URL by index 
 */
global void SetUrlByIndex(integer idx)   {
    
    integer SrcId = sourceStatesOut[idx, "SrcId"]:-1;
    currentUrl = Pkg::SourceGeneralData(SrcId)["url"]:"";
    return;
}


/**
 * Get Source ID when only URL is known 
 */
global define integer getSourceId( string url ) {
    
    numSources = size( sourceStatesOut );
    integer i = 0;
    integer id = -1;
    while ( i < numSources )
    { 
        map generalData = Pkg::SourceGeneralData(sourceStatesOut[i, "SrcId"]:-1 );
	if ( generalData[ "url" ]:"" == url )
	{
	    id = sourceStatesOut[i, "SrcId"]:-1;
	    break;
	}        
    }
    
    return id;
}






/**
 * Gather Source Metadata
 */
global define map SourceData(integer source) ``{
    map g =  Pkg::SourceGeneralData( source );
    y2milestone("generalData: %1", g);
    map p =  Pkg::SourceProductData( source );
    y2milestone("productData: %1", p);
    return ((map)union(g,p));
}

/**
 * Create a Source from an URL
 */
global symbol createSource( string url ) {
    
    if ( url != "" )
    {
	if (!Mode::commandline())
	{
	    // Popup::Message( sformat( "URL: %1", url ) );
	    UI::OpenDialog(
			   `VBox(
				 `VSpacing( 0.2 ),
				 `Label( _("Adding catalog...") ),
				 `VSpacing( 0.2 )
				 )
			   );
	}
	newSources = Pkg::SourceScan( url, "" );

	if (!Mode::commandline())	
	    UI::CloseDialog();

	
	if ( size( newSources ) == 0  )
	{
	    string _msg1 = sformat( _("Unable to create catalog
from URL '%1'."), url );
	    string err = Pkg::LastErrorId();
	    string _msg2 = "";
	    if ( err != "ok" ) {
		if ( err == "instsrc_duplicate" )
		    _msg2 = _("A catalog for this product already exists.");
		else
		    _msg2 = _("Details:") + "\n" + Pkg::LastError();
	    }
	    // end of popup message, question
	    _msg2 = _msg2 + "\n" + _("Try again?");

	    boolean tryagain = Popup::YesNo( _msg1 + "\n" + _msg2 );
	    if ( tryagain ) return `again;
	    else return `cancel;
	}
	else
	{
	    list<integer> ul_sources = filter (integer s, newSources, {
		map src_data = Pkg::SourceGeneralData (s);
		string src_type = src_data["type"]:"";
		return src_type == "YaST";
	    });
	    if (size (ul_sources) == 0)
	    {
		if (! Popup::AnyQuestion (
					  Popup::NoHeadline (),
// continue-back popup
					  _("There is no product information available at the given location.
If you expected to address a product, return back and enter
the correct location.
To make rpm packages located at the specified location available
in the packages selection, continue."),
					  Label::ContinueButton (),
					  Label::BackButton (),
					  `focus_yes))
		{
		    return `again;
		}
	    }
	    foreach( integer id, newSources, ``{
		map<string, any> sourceState = $[ "SrcId": id, "enabled": true ];
		sourceStatesOut = add( sourceStatesOut, sourceState ); 
	    } );
	    return `ok;
	}
    }
    return `cancel;
}

/**
 * Delete Source by Source ID
 */
global void deleteSourceBySrcId( integer SrcId )   {

    y2debug("removing source: %1 %2", SrcId,   sourceStatesOut );
    numSources = size( sourceStatesOut );
    integer i = 0;
    
    while ( i < numSources )
    {

	if ( sourceStatesOut[i, "SrcId"]:-1 == SrcId )
	{	    
	    sourceStatesOut = remove( sourceStatesOut, i );
	    break;
	}        
    }
    return;
    
}


/**
 * Delete Source by Source Index
 */
global void deleteSourceByIndex (integer idx ) {
    
    sourceStatesOut = remove( sourceStatesOut, idx );
    return;
}
    
/**
 * Delete Source by Source URL
 */
global void deleteSourceByUrl (string url ) {
    deleteSourceBySrcId(getSourceId(url));    
    return;
}

/**
 * Create Summary Item
 */
define string createItem( integer index, map source ) {
    integer id = source[ "SrcId" ]:0;
    map generalData = Pkg::SourceGeneralData( id );
    map productData = Pkg::SourceProductData( id );
    string sitem = "";
    string status = source[ "enabled" ]:true
	// status info, to be used inside summary
	? _("Enabled")
	// status info, to be used inside summary
	: _("Disabled");
    string color = source[ "enabled" ]:true ? "#006600" : "#FF0000";
    sitem = sitem + HTML::Colorize("["+status+"] ",
            color);
    // translators: name of a source if no other idenfication found
    sitem = sitem + productData[ "label" ]:generalData["type"]:_("unknown");
    sitem = sitem + " ( " + generalData[ "url" ]:"" + ")";
    return sitem;
}


/**
 * Create Source Item for Overview
 */
define term  createOverviewItem( integer index, map source ) {
    integer id = source[ "SrcId" ]:0;
    map generalData = Pkg::SourceGeneralData( id );
    map productData = Pkg::SourceProductData( id );
      

    term item = `item(
		      `id(index ),
		      source[ "enabled" ]:true
		      // corresponds to the "Enable/Disable" button
			? _("On")
		      // corresponds to the "Enable/Disable" button
			: _("Off"),
		      productData[ "label" ]:generalData["type"]:_("Unknown"),
		      generalData[ "url" ]:""
		      );    
   
    return item;
}


/**
 * Handle Multiple source URLs (order/instorder)
 */ 
boolean HandleMultipleSources( string url )	{

    boolean metadir_used = false;
    list<string> theSourceDirectories = [];
    map<integer,integer> theSourceOrder = $[];

    list theSources=[];
    string tmpdir = (string) SCR::Read(.target.tmpdir );
    string metadir = tmpdir + "/yast-install";


    Pkg::SourceStartManager( false );
    integer initial_source = Pkg::SourceScan(url, "")[0]:nil;
    if (initial_source == nil)
    {
        y2error ("No source on '%1'", url);
        return false;
    }

    return false;
}


/**
 * Create a textual summary and a list of unconfigured cards
 * @return summary of the current configuration
 */
global list Summary() {

    string summary = "";
    // summary header
    summary = Summary::AddHeader(summary, _("Configured Catalogs"));
    summary = Summary::OpenList(summary);
    numSources = size( sourceStatesOut );
    integer i = 0;
    while ( i < numSources ) {
       summary = Summary::AddListItem(summary,createItem(i, sourceStatesOut[ i ]:$[]));
        i = i + 1;
    }
    summary = Summary::CloseList(summary);


  
    list unconf = maplist(map s, slp_sources, ``{
	string id = substring(s["srvurl"]:"", 21);
	y2debug("source url : %1", id );
	// part of item in summary
	return(`item(`id(id), s["attr", "label"]:_("Unknown")
	    // part of item in summary meaning "switched on"
	    + _(" On ") + s["pcHost"]:""));
    });   

    return [summary, unconf ];
}

/**
 * Create an overview table with all configured cards
 * @return table items
 */
global list Overview() {
    numSources = size( sourceStatesOut );
    integer i = 0;
    list source_overview = [];
    while ( i < numSources ) {
	source_overview = add(source_overview,
                createOverviewItem(i, sourceStatesOut[ i ]:$[] ));
        i = i + 1;
    }
    return source_overview;
}

    // ------------------------------------------------------------------------------------------------------
    // adding YaST installation source into the ZMD

    /**
     * Runs a bash command with timeout.
     * @struct Returns map $[
     *     "exit" : int_return_code,
     *     "stdout"  : [ "script", "stdout", "lines" ],
     *     "stderr"  : [ "script", "stderr", "lines" ],
     * ]
     *
     * @param string command
     * @param integer timeout in sec.
     * @return map with out, err and ret_code
     */
    map RunCommandWithTimeout (string run_command, integer script_time_out) {
	y2milestone("Running command \"%1\" in background...", run_command);

	boolean started = (boolean) SCR::Execute(.background.run_output_err, run_command);
	if (!started) {
	    y2error("Cannot run '%1'", run_command);
	    return nil;
	}
	
	list<string> script_out = [];
	list<string> script_err = [];
	integer time_spent = 0;
	integer return_code = nil;
	boolean cont_loop = true;
	integer sleep_step = 20;
	script_time_out = script_time_out * 1000;
	
	// while continuing is needed and while it is possible
	while (cont_loop && ((boolean) SCR::Read(.background.output_open) || (integer) SCR::Read(.background.pid) > 0)) {
	    // time-out
	    if (time_spent >= script_time_out) {
		y2error("Command '%1' timed-out after %2 mces", run_command, time_spent);
		cont_loop = false;
	    }
	    
	    time_spent = time_spent + sleep_step;
	    sleep(sleep_step);
	}
	y2milestone("Time spent: %1 msec", time_spent);

	// fetching the return code if not timed-out
	if (cont_loop) {
	    script_out  = (list<string>) SCR::Read(.background.newout);
	    script_err  = (list<string>) SCR::Read(.background.newerr);
	    return_code = (integer) SCR::Read(.background.status);
	}
	SCR::Execute(.background.kill, "");

	map command_ret = $[
	    "exit"   : return_code,
	    "stdout" : script_out,
	    "stderr" : script_err,
	];
	return command_ret;
    }

    /**
     * Run
     * - with a timeout
     * - on dumb terminal to disable colors etc
     * - using 'exit $?' because of buggy behavior '.background vs. ZMD'
     */
    map RunDumb60 (string command) {
	map ret = RunCommandWithTimeout ("TERM=dumb; " + command + "; exit $?", 60);
	if (ret == nil) ret = $[];
	return ret;
    }

    /**
     * Detect whether ZMD is running
     */
    boolean CheckZMDStatus () {
	string rug_command = "/usr/bin/rug";
	map zmd_status = RunDumb60 (rug_command + " ping >/dev/null");
	y2milestone("ZMD status: %1, err: %2", zmd_status["exit"]:nil, zmd_status["stderr"]:[]);
	return zmd_status["exit"]:nil == 0;
    }

    /**
     * Returns count of services matching the pattern. Returns 'nil'
     * if something fails.
     *
     * @param string grep_pattern to match the ZYPP service
     * @return integer count of matching lines
     */
    integer CountOfZMDServicesMatching (string grep_pattern) {
	map ret = RunDumb60 ("/usr/bin/rug service-list");
	if (ret["stdout"]:nil != nil) {
	    list <string> matching = filter (string one_line, (list <string>) ret["stdout"]:[], {
		return regexpmatch(one_line, grep_pattern);
	    });
	    return size(matching);
	} else {
	    y2error("Counting of services failed, returned %1", ret);
	    return nil;
	}
    }

    /**
     * Adds a ZYPP service into ZMD
     * @param src_id installation source id
     * @return success
     */
    boolean AddZYPPServiceIntoZMD (integer src_id) {
	map gendata = Pkg::SourceGeneralData (src_id);
	string url = gendata["url"]:"";
	// ZMD must have unique URIs, so we append the alias
	string alias = gendata["alias"]:"";
	y2milestone ("id: %1, url: %2, alias: %3", src_id, url, alias);
	if (url == "" || alias == "") {
	    y2error ("ugh");
	    return false;
	}

	// URL (un)escapes for us
	// maybe a bug with "="?
	map parsed_url = URL::Parse (url);
	string query = parsed_url["query"]:"";
	if (query != "") query = query + ";";
	parsed_url["query"] = query + "alias=" + alias;
	string test_url = URL::Build (parsed_url);
	y2milestone ("test zmd url: %1", test_url);

	string separator = (search (url, "?") == nil)? "?": ";";
	url = url + separator + "alias=" + alias;
	y2milestone ("zmd url: %1", url);

	string name = alias;

	map ret = RunDumb60 (
	    sformat (
		"/usr/bin/rug service-add --type=zypp '%1' '%2' && /usr/bin/rug subscribe '%1'",
		url, name
		)
	    );
	if (ret["exit"]:nil == 0) {
	    return true;
	} else {
	    y2error("Adding ZYPP service failed, returned %1", ret);
	    return false;
	}
    }

    /* ZMD service name - used for starting and stopping ZMD */
    string zmd_service_name = "/etc/init.d/novell-zmd";

    /**
     * Stops zmd when it 'was not running'.
     * It's expected that ZMD is running.
     *
     * @param boolean was_running
     * @return boolean true if successful
     */
    boolean StopZMDIfItWasNotRunning (boolean was_running) {
	// It was running, nothing to change
	if (was_running) return true;
	
	y2milestone("Stopping service ZMD %1", zmd_service_name);
	map zmd_stop = RunDumb60 (zmd_service_name + " stop");
	y2milestone("ZMD stop: %1", zmd_stop);
	if (zmd_stop["exit"]:nil != 0) {
	    Report::Error(Message::CannotStopService(zmd_service_name));
	}
	
	y2milestone("ZMD stopped");
	return true;
    }

    /**
     * Checks whether ZMD is running, starts it when isn't. Checks whether a ZYPP source is listed
     * in the ZMD services, adds one if it is missing.
     * Everything is done via the .background agent with timeout (number in seconds).
     *
     * @return boolean whether the syncing succeeds
     */
    global boolean SyncYaSTInstSourceWithZMD () {
	// Notes for maintainer:
	//     - using .background agent because of ZMD/rug call that can stuck
	//     - using 'exit $?' that work well with ZMD/rug and .background together
	//     - using TERM=dumb to suppress colors, progress bars etc. from ZMD/rug
	//     - when the function finishes, it must leave ZMD in the same status (running/stopped)
	//       as it was when the function started
	//
	// WARNIG: this function starts ZMD and expects that LIBZYPP has no lock over
	//         the RPM database. You can run it only when the RPM is not locked
	//         otherwise the ZMD will block itself!

	y2milestone("--- Syncing YaST inst source with ZMD ---");

	// Check the ZMD status and start if not running
	// If the ZMD wasn't running, we will try to start it and then we will have to stop it at the end
	boolean zmd_was_running = CheckZMDStatus ();
	if (! zmd_was_running) {
	    // Starting the service
	    map zmd_start = RunDumb60 (zmd_service_name + " start");
	    y2milestone("ZMD start: %1", zmd_start);
	    // Checking the status after start
	    boolean zmd_is_running = CheckZMDStatus ();
	    if (! zmd_is_running) {
		Report::Error(Message::CannotStartService(zmd_service_name));

		// In case of timeout
//FIXME
//		if (zmd_status == nil) StopZMDIfItWasNotRunning(zmd_was_running);
		y2milestone("--- Syncing finished ---");
		return false;
	    }
	}

	// this will not work, /installation is gone
	if (false) {
	// Check whether the ZYPP service is already in zmd db or not
	integer count_of_services = CountOfZMDServicesMatching(".*ZYPP.*/installation.*");
	if (count_of_services == nil) {
	    y2warning("Cannot get list of services...");
	} else if (count_of_services > 0) {
	    y2milestone("ZYPP service already presented (%1)", count_of_services);

	    // Stop ZMD if needed
	    StopZMDIfItWasNotRunning(zmd_was_running);
	    y2milestone("--- Syncing finished ---");
	    return true;
	}
	}
	
	// Count of services were 'nil' or '0'
	list<integer> src_ids = Pkg::SourceGetCurrent (true /*enabled only?*/);
	boolean added_ok = true;
	foreach (integer src_id, src_ids, {
	    added_ok = AddZYPPServiceIntoZMD (src_id) && added_ok;
	});
	if (added_ok) {
	    y2milestone("Adding ZYPP service succeeded");
	} else {
	    Report::Error(Message::CannotWriteSettingsTo("ZMD"));
	    y2error("Adding ZYPP service failed");
	}

	// Stop ZMD if needed
	StopZMDIfItWasNotRunning(zmd_was_running);
	y2milestone("--- Syncing finished ---");
	return true;
    }

    // adding YaST installation source into the ZMD
    // ------------------------------------------------------------------------------------------------------

/* EOF */
}
