<HTML>
<HEAD>
<TITLE>PACKAGE agent</TITLE>
</HEAD>
<BODY>
<H1>PACKAGE agent</H1>
<HR>
<H2>Purpose</H2>
<p>The PACKAGE agent has the responsibility about packages which have to be installed or updated.<BR>
It provides package informations and checks all dependencies and required diskspaces.</p>
<P>
If the path cannot be recognized, <TT>void</TT> is returned.
<P>
<H2>Implementation</H2>
<p>The agent needs some configuration files as input:</p>
    <ul>
      <li><i>common.pkd</i>: The descriptionfile of <tt>all</tt> packages
	( name, series, dependencies, ...).</li>
      <li><i>du.dir</i>: Required diskspace for each packet.</li>
      <li><i>info</i>: Include Version, minBaseSystem.....</li>
      <li><i>update.inf</i>: Gives informations about the installed system.</li>
      <li><i>&lt;language&gt;.pkg</i>: Package descriptionfile.</li>
    </ul>
<p>Furthermore the agent will need some other environments:</p>
    <ul>
      <li>Path of the <i>common.pkd</i> and <i>&lt;language&gt;.pkg</i>.</li>
      <li>Path of the <i>du.dir</i>.</li>
      <li>List of partitions and their sizes (used, free).</li>
      <li>Selected language.</li>
      <li>Path of the rpm-DB.</li>
      <li>ROOT-Path .</li>
      <li>YaST-Path /var/lib/YaST.</li>
    </ul>
<P>
<H2>Execute() Commands</H2>
<H3>.package.setEnvironment</H3>
Initialize the agent with the environment.<BR>
<BR>
Argument: $[ string packageinfopath, string common.pkd, string language, string dudir, map partition, string rootpath,
    	   string yastpath, boolean update, boolean forceInit ]<BR>
<BR>
Returns: true/false<BR>
<BR>
Usage: <TT>Execute (.package.setEnvironment, $["packageinfopath":"/mnt/suse/setup/desc", "common.pkd":"common.pkd",
"language":"german", "dudir":"/mnt/suse/setup/du/du.dir", "partition":[$["name":"/","used":0,"free":1500],
$["name":"var","used":0,"free":100000]], "rootpath":"/", "yastpath":"/var/lib/YaST", "update": true,
"forceInit":false]  ) </TT>
<BR>
All disk-sizes are kBytes; memoptimezed and forceInit have not to be declared.
<p>
<H3>.package.setInstallSelection</H3>
Set the list of packets which have to be installed. Every other selection will be deleted, if notResetSingleSelected == false.<BR>
<BR>
Argument: list ofPackage, boolean notResetSingleSelected<BR>
<BR>
Returns: true/false<BR>
<BR>
Usage: <TT>Execute(.package.setInstallSelection, ["aaa_base","aaa_dir"], false)</TT><BR>
<P>
<H3>.package.setDeleteSelection</H3>
Set the list of packets which have to be deleted. Every other previous selection will be removed.<BR>
<BR>
Argument: list package<BR>
<BR>
Returns: true/false<BR>
<BR>
Usage: <TT>Execute(.package.setDeleteSelection,["xv","yast2"])</TT><BR>
<P>
<H3>.package.setUpdateSelection</H3>
Set the list of packets which have to be updated. Every other privious update selection will be removed.<BR>
<BR>
Argument: list packages<BR>
<BR>
Returns: true/false<BR>
<BR>
Usage: <TT>Execute (.package.setUpdateSelection,["aaa_base","aaa_dir"])</TT><BR>
<P>
<H3>.package.selectInstall</H3>
Set a package which has to be installed.<BR>
<BR>
Argument:  string package, boolean automatic ( due dependencies )<BR>
<BR>
Returns: true/false<BR>
<BR>
Usage: <TT>Execute (.package.selectInstall,"xv", false)</TT><BR>
<P>
<H3>.package.selectSelInstall</H3>
Set a selectiongroup for installation.<BR>
<BR>
Argument:  string selectiongroup, boolean reset old selection<BR>
<BR>
Returns: true/false<BR>
<BR>
Usage: <TT>Execute (.package.selectSelInstall,"default", false)</TT><BR>
<P>
<H3>.package.selectInstallList</H3>
Set the list of packets which have to be installed. Every other privious selection will NOT be removed.<BR>
<BR>
Argument:  list packages, boolean automatic ( due dependencies )<BR>
<BR>
Returns: true/false<BR>
<BR>
Usage: <TT>Execute (.package.selectInstallList,["xv","xteddy"], false)</TT><BR>
<P>
<H3>.package.deselectInstall</H3>
Reset the installation selection of a packet.<BR>
<BR>
Argument:  string package<BR>
<BR>
Returns: true/false<BR>
<BR>
Usage: <TT>Execute (.package.deselectInstall,"xv")</TT><BR>
<P>
<H3>.package.deselectSelInstall</H3>
Reset the installation selection of a selectiongroup.<BR>
<BR>
Argument:  string selectiongroup<BR>
<BR>
Returns: true/false<BR>
<BR>
Usage: <TT>Execute (.package.deselectSelInstall,"default")</TT><BR>
<P>
<H3>.package.selectUpdate</H3>
Select a package for update.<BR>
<BR>
Argument:  string package<BR>
<BR>
Returns: true/false<BR>
<BR>
Usage: <TT>Execute (.package.selectUpdate,"aaa_base")</TT><BR>
<P>
<H3>.package.selectUpdateList</H3>
Select a list of package for update.<BR>
<BR>
Argument:  list packages<BR>
<BR>
Returns: true/false<BR>
<BR>
Usage: <TT>Execute (.package.selectUpdateList,["aaa_base", "aaa_dir"])</TT><BR>
<P>
<H3>.package.deselectUpdate</H3>
Reset a packageselection for update.<BR>
<BR>
Argument:  string package<BR>
<BR>
Returns: true/false<BR>
<BR>
Usage: <TT>Execute (.package.deselectUpdate,"aaa_base")</TT><BR>
<P>
<H3>.package.selectDelete</H3>
Set a package to delete.<BR>
<BR>
Argument:  string package<BR>
<BR>
Returns: true/false<BR>
<BR>
Usage: <TT>Execute (.package.selectDelete,"aaa_base")</TT><BR>
<P>
<H3>.package.deselectDelete</H3>
Reset a package selection.<BR>
<BR>
Argument:  string package<BR>
<BR>
Returns: true/false<BR>
<BR>
Usage: <TT>Execute (.package.deselectDelete,"aaa_base")</TT><BR>
<P>
<H3>.package.deleteAdditionalDependencies</H3>
Delete all Dependencies where package X requires<BR>
<BR>
Argument:  string package<BR>
<BR>
Returns: true/false<BR>
<BR>
Usage: <TT>Execute (.package.deleteAdditionalDependencies,"aaa_base")</TT><BR>
<P>
<H3>.package.deleteUnsolvedRequirements</H3>
Delete the unresolved requirements where a package needs one of the packages from &lt;tagName&gt;<BR>
<BR>
Argument:  string tagName<BR>
<BR>
Returns: true/false<BR>
<BR>
Usage: <TT>Execute (.package.deleteUnsolvedRequirements,"aaa")</TT><BR>
<P>
<H3>.package.deleteConflictDependencies</H3>
Delete all Conflict Dependencies between "packageName1" and package "packageName2".
"packageName1" is the current selected packages<BR>
<BR>
Argument:  string packageName1, string packageName2<BR>
<BR>
Returns: true/false<BR>
<BR>
Usage: <TT>Execute (.package.deleteConflictDependencies,"aaa_base","aaa_dir")</TT><BR>
<P>
<H3>.package.deleteSelUnsolvedRequirements</H3>
Delete the unresolved requirements where a selectiongroup needs one of the selections from "tagName"<BR>
<BR>
Argument:  string tagName<BR>
<BR>
Returns: true/false<BR>
<BR>
Usage: <TT>Execute (.package.deleteSelUnsolvedRequirements,"aaa")</TT><BR>
<P>
<H3>.package.deleteSelConflictDependencies</H3>
Delete all Conflict Dependencies between "selectionName1" and selection "selectionName2".
"selectionName1" is the current selected selection<BR>
<BR>
Argument: string selectionName1, string selectionName2<BR>
<BR>
Returns: true/false<BR>
<BR>
Usage: <TT>Execute (.package.deleteSelConflictDependencies,"minimal","default")</TT><BR>
<P>
<H3>.package.saveState</H3>
Saving actual state of the server ( included selected packages, dependencies, .... )<BR>
<BR>
Argument:  NIL<BR>
<BR>
Returns: true/false<BR>
<BR>
Usage: <TT>Execute (.package.saveState, nil)</TT><BR>
<P>
<H3>.package.restoreState</H3>
Restore old state, which have been saved with the call "saveState".<BR>
<BR>
Argument:  NIL<BR>
<BR>
Returns: true/false<BR>
<BR>
Usage: <TT>Execute (.package.restoreState, nil)</TT><BR>
<P>
<H3>.package.deleteOldState</H3>
Delete old state, which have been saved with the call "saveState".<BR>
<BR>
Argument:  NIL<BR>
<BR>
Returns: true/false<BR>
<BR>
Usage: <TT>Execute (.package.deleteOldState, nil)</TT><BR>
<P>
<H3>.package.setSourceInstallation</H3>
Select or deselect source installation.<BR>
<BR>
Argument:  boolean install<BR>
<BR>
Returns: true/false<BR>
<BR>
Usage: <TT>Execute (.package.setSourceInstallation, true)</TT><BR>
<P>
<H3>.package.checkBrokenUpdate</H3>
 Check, if an update has not been successfully.<BR>
<BR>
Argument: NIL<BR>
<BR>
Returns: Returns a list of packages which have to be installed or delete successfully: $["aaa_base","u", "at", "d", ......]<BR>
<BR>
Usage: <TT>Execute (.package.checkBrokenUpdate, NIL)</TT><BR>
<P>
<H3>.package.saveUpdateStatus</H3>
 Save the update-status into /var/lib/YaST/install.lst.<BR>
<BR>
Argument: $["ToDelete":["xyz1","aasdf",....], "ToInstall":["kaakl","aas"], "RMode":"Recover" ]<BR>
<BR>
Returns: true/false<BR>
<BR>
Usage: <TT>Execute (.package.saveUpdateStatus,$["ToDelete":["xv"], "ToInstall":["aaa_base","aaa_dir"], "RMode":"Recover" ])</TT><BR>
<P>
<H3>.package.backupUpdateStatus</H3>
Save the update-status from /var/lib/YaST/install.lst to /var/lib/YaST/install.lst.bak<BR>
<BR>
Argument: Nil<BR>
<BR>
Returns: true/false<BR>
<BR>
Usage: <TT>Execute (.package.backupUpdateStatus, nil)</TT><BR>
<P>
<H3>.package.checkPackage</H3>
Check, if the package has been installed without errors.<BR>
<BR>
Argument: string packageName<BR>
<BR>
Returns: list [&lt;rpm-version&gt;,&lt;common.pkd-version&gt;]<BR>
<BR>
Usage: <TT>Execute (.package.checkPackage, "aaa_base")</TT><BR>
<P>
<H3>.package.closeUpdate</H3>
Close Update and save  /var/lib/YaST/update.inf if it was successfully.<BR>
<BR>
Argument: boolean basesystemUpdated<BR>
<BR>
Returns: true/false<BR>
<BR>
Usage: <TT>Execute (.package.closeUpdate, true)</TT><BR>
<P>
<H3>.package.searchPackage</H3>
Returns a map of packages to which the searchmaskstring fits<BR>
<BR>
Argument: map like: $[ "searchmask":"informix"; "onlyName":true, "casesensitive":false ]<BR>
<BR>
Returns: map like: $["aaa_base":["SuSE Linux Verzeichnisstruktur", "X", 378, "1.2.3-1" ], "aaa_dir",[...],...]<BR>
<BR>
Usage: <TT>Execute (.package.searchPackage,$[ "searchmask":"informix"; "onlyName":true, "casesensitive":false ])</TT><BR>
<P>
<H3>.package.compareSuSEVersions</H3>
Compare the version of installed system with the version of install-medium.<BR>
<BR>
Argument: string to_install_version<BR>
If it is a NULL string this version will be read from /var/adm/mount/suse/setup/descr/info<BR>
<BR>
Returns: map like:  $["installedGreater": TRUE , "installedVersion":"6.3", "updateVersion":"6.4.0"] if no equal; else $[]<BR>
<BR>
Usage: <TT>Execute (.package.compareSuSEVersions, "6.4")</TT><BR>
<P>
<H3>.package.closeMedium</H3>
 Let the agent known, that he cannot access the common.pkd<BR>
<BR>
Argument: NIL<BR>
<BR>
Returns: true/false<BR>
<BR>
Usage: <TT>Execute (.package.closeMedium, NIL)</TT><BR>
<P>
<H2>Read() commands</H2>
<P>
<H3>.package.packageList</H3>
 Reads all package informations which are described in common.pkd.<BR>
<BR>
Argument: none<BR>
<BR>
Returns: map like $["aaa_base":["SuSE Linux Verzeichnisstruktur", "X", 378,<version> ], "aaa_dir",[...],...]<BR>
<BR>
Usage: <TT>Read (.package.packageList)</TT><BR>
<P>
<H3>.package.hierarchyInformation</H3>
Evaluate a branch of the package tree.<BR>
<BR>
Argument: $["branch":&lt;branch&gt;, "rpmgroup":true]<BR>
Returns:<BR>
If branch is NULL the contents of map are the series.<BR>
If branch is the Name of a serie, the return value is a list of all packages which belongs to the serie.<BR>
If rpmgroup is true rpmgroups are handled instead of series.<BR>
<BR>
Usage: <TT>Read (.package.hierarchyInformation,$["branch":"", "rpmgroup":true])</TT><BR>
<P>
<H3>.package.longDesc</H3>
Get the long description of a package.<BR>
<BR>
Argument: string packageName<BR>
<BR>
Returns: string<BR>
<BR>
Usage: <TT>Read (.package.longDesc,"aaa_base")</TT><BR>
<P>
<H3>.package.shortName</H3>
Get the shortname of a package ( used in rpm and the dependencies ).<BR>
<BR>
Argument: string long packageName<BR>
<BR>
Returns: string<BR>
<BR>
Usage: <TT>Read (.package.shortName,"aaa_base")</TT><BR>
<P>
<H3>.package.shortDesc</H3>
Get the short description of a package.<BR>
<BR>
Argument: string packageName<BR>
<BR>
Returns: string<BR>
<BR>
Usage: <TT>Read (.package.shortDesc,"aaa_base")</TT><BR>
<P>
<H3>.package.version</H3>
Get the version of a package.<BR>
<BR>
Argument: string packageName<BR>
<BR>
Returns: string<BR>
<BR>
Usage: <TT>Read (.package.version,"aaa_base")</TT><BR>
<P>
<H3>.package.delDesc</H3>
Get the delete notify of a package.<BR>
<BR>
Argument: string packageName<BR>
<BR>
Returns: string<BR>
<BR>
Usage: <TT>Read (.package.delDesc,"aaa_base")</TT><BR>
<P>
<H3>.package.selDelDesc</H3>
Get the delete notify of a selectiongroup.<BR>
<BR>
Argument: string selectiongroup<BR>
<BR>
Returns: string<BR>
<BR>
Usage: <TT>Read (.package.selDelDesc,"default")</TT><BR>
<P>
<H3>.package.category</H3>
Get the category of a package.<BR>
<BR>
Argument: string packageName<BR>
<BR>
Returns: string<BR>
<BR>
Usage: <TT>Read (.package.category,"aaa_base")</TT><BR>
<P>
<H3>.package.copyright</H3>
Get the copyright of a package.<BR>
<BR>
Argument: string packageName<BR>
<BR>
Returns: string<BR>
<BR>
Usage: <TT>Read (.package.copyright,"aaa_base")</TT><BR>
<P>
<H3>.package.author</H3>
Get the author list of a package. The returned string contains
name and emailadress for each author on a separate line, like<BR>
<TT>"Burchard Steinbild &lt;bs@suse.de&gt;\nFlorian La Roche &lt;florian@suse.de&gt;"</TT>
<BR>
Argument: string packageName<BR>
<BR>
Returns: string<BR>
<BR>
Usage: <TT>Read (.package.author,"aaa_base")</TT><BR>
<P>
<H3>.package.sizeInK</H3>
Get the size of a package in K.<BR>
<BR>
Argument: string packageName<BR>
<BR>
Returns: integer<BR>
<BR>
Usage: <TT>Read (.package.sizeInK,"aaa_base")</TT><BR>
<P>
<H3>.package.notifyDesc</H3>
Get the notify description of a package.<BR>
<BR>
Argument: string packageName<BR>
<BR>
Returns: string<BR>
<BR>
Usage: <TT>Read (.package.notifyDesc,"aaa_base")</TT><BR>
<P>
<H3>.package.selNotifyDesc</H3>
Get the notify description of a selectiongroup.<BR>
<BR>
Argument: string selectiongroup<BR>
<BR>
Returns: string<BR>
<BR>
Usage: <TT>Read (.package.selNotifyDesc,"default")</TT><BR>
<P>
<H3>.package.dependencies</H3>
Calculates the package dependencies.<BR>
<BR>
Argument: none<BR>
<BR>
Returns: $["REQUIRE":[ $["tag":"tagname1","packages":["pack1","pack2","pack3"]],
  $["tag":"tagname2","packages":["pack4","pack5"]]],  ... ,
  "ADD":["pack6","pack8",...],
  "CONFLICT": [$["name":"pack9","packages":["pack10","pack11"]],
  $["name":"pack12","packages":["pack13"]]],
  "OBSOLETE": [ [ pack25, [], pack26, [] ], [ pack27, [], pack28, [] ] ]  ]<BR>
  Explanation: $["REQUIRE":[ $["tag":"tagname1","packages":["pack1","pack2","pack3"]],
  $["tag":"tagname2","packages":["pack4","pack5"]]],  ...
  The user have to select ONE packet of every group, e.g. from browser.
  ( pack1 or pack2 or pack3 ).<BR>
  "ADD":["pack6","pack8",...]:These packets are needed from other packages
  and are selected automatically by the dependency-check. The user does
  not select anything.<BR>
  "OBSOLETE":[ [ pack25,<version>, [], pack26,<version>, [] ],
  [ pack27,<version>, [], pack28, <version>,[] ] ]
  pack25, list with packages which require pack25, obsoletes pack26,
  list of packages which require pack26<BR>
<BR>
Usage: <TT>Read (.package.dependencies)</TT><BR>
<P>
<H3>.package.selDependencies</H3>
Calculates the selectiongroup dependencies.<BR>
<BR>
Argument: none<BR>
<BR>
Returns:  $["REQUIRE":[ $["tag":"tagname1","selections":["sel1","sel2","sel3"]],
   $["tag":"tagname2","selections":["sel4","sel5"]]],  ... ,
    "ADD":["sel6","sel8",...],
    "CONFLICT": [$["name":"sel9","selections":["sel10","sel11"]],
    $["name":"sel12","selections":["sel13"]]],..  ]<BR>
    Explanation: "REQUIRE":[ $["tag":"tagname1","selections":["sel1","sel2","sel3"]],
      $["tag":"tagname2","selections":["sel4","sel5"]]],  ...    <BR>
      The user have to select ONE selection of every group, e.g. from browser.
      ( sel1 or sel2 or sel3 ).<BR>
      "ADD":["sel6","sel8",...]:These selections are needed from other selections
       and are selected automatically by the dependency-check. The user does
        not select anything.<BR>
<BR>
Usage: <TT>Read (.package.selDependencies)</TT><BR>
<P>
<H3>.package.breakingPackageList</H3>
Simulates the delete of the package "packageName" and returns all
 selected packages, that have then unfullfilled dependencies<BR>
<BR>
Argument: string packageName<BR>
<BR>
Returns: list of packages<BR>
<BR>
Usage: <TT>Read (.package.breakingPackageList,"aaa_base")</TT><BR>
<P>
<H3>.package.updateList</H3>
Calculates the packages which have to be updated.<BR>
<BR>
Argument: none<BR>
<BR>
Returns:  $["updateBase": TRUE , "installedVersion":"SuSE 6.3",
 "updateVersion":"SuSE 6.4", "packages":$["aaa_base":"u", "xfree":"m", "xyz":"m",..] ]<BR>
Flag "m" means that the user has to decide updating the package. <BR>
<BR>
Usage: <TT>Read (.package.updateList)</TT><BR>
<P>
<H3>.package.versions</H3>
Evaluate the installed and CD-version of the distri.<BR>
<BR>
Argument: none<BR>
<BR>
Returns:  $[ "installedVersion":"SuSE 6.3", "updateVersion":"SuSE 6.4" ]<BR>
<BR>
Usage: <TT>Read (.package.versions)</TT><BR>
<P>
<H3>.package.diskSpace</H3>
Calculates the required disk space for the current selection.<BR>
<BR>
Argument: list like [$["name":"/","used":0,"free":1500],  $["name":"var",used:0,"free":100000]] <BR>
<BR>
Returns:  list like [$["name":"/","used":0,"free":1500],  $["name":"var",used:0,"free":100000]]<BR>
<BR>
Usage: <TT>Read (.package.diskSpace, [$["name":"/","used":0,"free":1500],  $["name":"var",used:0,"free":100000]])</TT><BR>
<P>
<H3>.package.neededCDs</H3>
Returns a map of installation CDs with the needed disk space of packages of each CD which have to be installed( KByte ).<BR>
<BR>
Argument: none<BR>
<BR>
Returns: map like  $[243,1500,50,0,0,0,0,0 ]<BR>
<BR>
Usage: <TT>Read (.package.neededCDs)</TT><BR>
<P>
<H3>.package.installSet</H3>
Returns the list of packages which have to be installed.<BR>
<BR>
Argument: none<BR>
<BR>
Returns: list of packages<BR>
<BR>
Usage: <TT>Read (.package.installSet)</TT><BR>
<P>
<H3>.package.installSetCD</H3>
Returns the list of packages which have to be installed and are located on the desired CD.<BR>
<BR>
Argument: CD number<BR>
<BR>
Returns: list of packages<BR>
<BR>
Usage: <TT>Read (.package.installSetCD, 1)</TT><BR>
<P>
<H3>.package.packageSelections</H3>
Reads a file which contains all selections and deselections and initialize the package agent with this selections.<BR>
<BR>
Argument: string path of the descriptionfile<BR>
<BR>
Returns: true/false<BR>
<BR>
Usage: <TT>Read (.package.packageSelections, "/tmp/packages")</TT><BR>
<P>
<H3>.package.selInstallSet</H3>
Returns the list of selectiongroups which have to be installed.<BR>
<BR>
Argument: none<BR>
<BR>
Returns: list of selectiongroups<BR>
<BR>
Usage: <TT>Read (.package.selInstallSet)</TT><BR>
<P>
<H3>.package.updateSet</H3>
Returns the list of packages which have to be updated.<BR>
<BR>
Argument: none<BR>
<BR>
Returns: list of packages<BR>
Format :[[&lt;inst-path&gt;,&lt;shortdescription&gt;,&lt;CDNr&gt;,&lt;basepackage&gt;]...]<BR>
<BR>
Usage: <TT>Read (.package.updateSet)</TT><BR>
<P>
<H3>.package.updateSetCD</H3>
Returns the list of packages which have to be updated and belongs to the certain CD.<BR>
<BR>
Argument: integer CD number<BR>
<BR>
Returns: list of packages<BR>
Format :[[&lt;inst-path&gt;,&lt;shortdescription&gt;,&lt;CDNr&gt;,&lt;basepackage&gt;]...]<BR>
<BR>
Usage: <TT>Read (.package.updateSetCD, 1)</TT><BR>
<P>
<H3>.package.updatePackageNames</H3>
Returns the list of packages which have to be updated.<BR>
<BR>
Argument: none<BR>
<BR>
Returns: list of packages<BR>
<BR>
Usage: <TT>Read (.package.updatePackageNames)</TT><BR>
<P>
<H3>.package.deleteSet</H3>
 Returns the list of packages which have to be deleted.<BR>
<BR>
Argument: none<BR>
<BR>
Returns: list of packages<BR>
<BR>
Usage: <TT>Read (.package.deleteSet)</TT><BR>
<P>
<H3>.package.isSingleSelected</H3>
Check, if there was a single selection of packages.<BR>
<BR>
Argument: none<BR>
<BR>
Returns: true/false<BR>
<BR>
Usage: <TT>Read (.package.isSingleSelected)</TT><BR>
<P>
<H3>.package.isInstallSelected</H3>
Check, if there are packages which has been selected for installation.<BR>
<BR>
Argument: none<BR>
<BR>
Returns: true/false<BR>
<BR>
Usage: <TT>Read (.package.isInstallSelected)</TT><BR>
<P>
<H3>.package.selPackages</H3>
Evaluate all packages of selected "selectiongroups"<BR>
<BR>
Argument: none<BR>
<BR>
Returns: list of needed packages<BR>
<BR>
Usage: <TT>Read (.package.selPackages)</TT><BR>
<P>
<H3>.package.selGroups</H3>
Get description of all *.sel files<BR>
<BR>
Argument: none<BR>
<BR>
Returns: list of selectiongroups; an element is list too :[&lt;name&gt;,&lt;description&gt;,&lt;kind&gt;]<BR>
<BR>
Usage: <TT>Read (.package.selGroups)</TT><BR>
<P>
<H3>.package.isCDBooted</H3>
Check, if the system has been booted from CD.<BR>
<BR>
Argument: none<BR>
<BR>
Returns: true/false<BR>
<BR>
Usage: <TT>Read (.package.isCDBooted)</TT><BR>
<P>
<H3>.package.packageVersion</H3>
Evaluate the buildtime and version of a package.<BR>
<BR>
Argument: string packagename<BR>
<BR>
Returns: list; format:[&lt;rpm-version&gt;,&lt;common.pkd-version&gt;,&lt;rpm-buildtime&gt;,
&lt;common.pkd-buildtime&gt;]<BR>
<BR>
Usage: <TT>Read (.package.packageVersion, "aaa_base")</TT><BR>
<P>
<H3>.package.changedPackageName</H3>
Returns the list of packages, which replace old packages. This packages have to be installed.<BR>
<BR>
Argument: none<BR>
<BR>
Returns: list of packages<BR>
<BR>
Usage: <TT>Read (.package.changedPackageName)</TT><BR>
<P>
<H3>.package.installSplittedPackages</H3>
 Returns the list of packages, which have to be installed, cause packages have been splitted.<BR>
<BR>
Argument: none<BR>
<BR>
Returns: list of packages : [ [&lt;splitted package1&gt;, &lt;package to have install1&gt;],
 [&lt;splitted package2&gt;, &lt;package to have install2&gt;], .... ]<BR>
<BR>
Usage: <TT>Read (.package.installSplittedPackages)</TT><BR>
<P>
<H3>.package.kernelList</H3>
Returns a map of kernels which could be installed.<BR>
<BR>
Argument: none  <BR>
<BR>
Returns: $[ &lt;kernel-name1&gt;:&lt;description1&gt;, &lt;kernel-name2&gt;:&lt;description2&gt; ]<BR>
<BR>
Usage: <TT>Read (.package.kernelList)</TT><BR>
<P>
<H3>.package.packageStatus</H3>
Get the status of a package like i,d,X....<BR>
<BR>
Argument: string packageName<BR>
<BR>
Returns: string status<BR>
<BR>
Usage: <TT>Read (.package.packageStatus, "aaa_base" )</TT><BR>
<P>
<P>
<H2>Write() commands</H2>
<P>
<H3>.package.packageSelections</H3>
Writes a file which contains all selections and deselections.<BR>
<BR>
Argument: string path of the descriptionfile<BR>
<BR>
Returns: true/false<BR>
<BR>
Usage: <TT>Write (.package.packageSelections, "/tmp/packages")</TT><BR>
<P>
</BODY>
</HTML>
