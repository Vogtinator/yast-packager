
/**
 * Module: 		inst_sw_details.ycp
 *
 * Authors:		Mathias Kettner (kettner@suse.de)
 *			Klaus Kaempf (kkaempf@suse.de) (initial)
 *			Stefan Schubert (schubi@suse.de)
 *
 * Purpose:
 * Display detailed software selection screen.
 * Show checkboxes for software categories.
 * Let the user select his software.
 *
 * user_settings read:	
 *		
 *			"install_sources"
 *
 * user_settings write: 
 *			"install_sources"
 *
 * 
 *
 *
 * $Id$
 */

{
    textdomain "packages";

    import "Arch";
    import "Mode";
    import "Installation";
    import "Storage";
    import "Packages";
    import "PackagesUI";
    import "SpaceCalculation";

    import "Wizard";
    import "X11";

    include "ui/common_popups.ycp";
    include "ui/common_messages.ycp";
    include "ui/common_functions.ycp";

    include "packages/selectionHandle.ycp";
    
    list current_sel     = SCR::Read(.package.selInstallSet);
    string actual_sel = "";
    
    list pacsels = [];

    // sort the add ons 
    pacsels = sort( `x, `y, filter(`sel,
				   SCR::Read(.package.selGroups),
				   ``(select(sel, 1, "") != "paylist")),
		    ``( select( x, 1, "") < select( y, 1, "") )
		    );

    // screen title for detailed software selection
    string title = _("Detailed Software Selection");


    // Construct Box with Checkbox for each software category

    // Title of frame around "basic software"
    term categories    = `VBox(`VSpacing(0.5));
    list baseconf  = [];

    foreach(`sel, pacsels, ``{
	string   selid   = select(sel, 0, "");
	string   group   = select(sel, 2, "");
	string   seldesc = select(sel, 1, "");

	if ( group == "addon" )
	{
	   categories = add(categories, `Left(`CheckBox(`id(selid), `opt(`notify, `autoShortcut),
			seldesc, contains(current_sel, selid))));
	}
	if ( group == "baseconf" )
	{
	   baseconf = add ( baseconf, selid );   
	}
    });
    
    // recognize the current selected baseconf ( default, Minimal, All )
    string software_group_path = "";
    list software_group = [];
    foreach(`sel, current_sel, ``{
	if ( contains ( baseconf, sel ) )
	{
		software_group_path = sel;
	}
    });    
    if ( size ( software_group_path ) > 0 )
    {
        software_group = add ( software_group, software_group_path );
    }
    y2debug( "Software_group: %1", software_group );


    categories = add(categories, `VSpacing(0.7) );
    categories = add(categories, `Left(`CheckBox(`id(`sources),`opt(`notify),
						 // Check box for installing all source code packages
						 _("&Install available sources"),    // false ) ) );
    						 Packages::install_sources ) ) );
    categories = add(categories, `VSpacing(0.5) );
    
    // Build and show dialog
    term contents = `VBox(
			  `HVCenter( `HVSquash( `Frame( _("Categories"), categories ) ) ),
			  `VStretch(),
			  `Label( `id(`free_space),
				  sformat( UI(_("%1 required disk space")),
					  SpaceCalculation::GetRequSpace( false) ) ),
			  `VStretch(),
			  `HBox(
				// Push button that branches into the commercial software dialog
				`HWeight( 1, `PushButton( `id(`sw_pay    ), `opt(`hstretch),
							  _("&Commercial software...") ) ),
				`HSpacing(`opt(`hstretch), 0.2),
						   
				// Push button that branches into the single package dialog
				`HWeight( 1, `PushButton( `id(`sw_single ), `opt(`hstretch),
							  _("Select &single packages...") ) )
				),
			  `VSpacing(0.5)
			  );

    
    // Explain additional software categories
    // (E.g. Multimedia, Games, Development, ...).
    // help part 1 of 3
    string helptext = UI(_("<p>
Select categories of software to install.
</p>

<p>
The base system will always be installed. The software categories
automatically include other system components as required.
If you select a desktop like <i>KDE</i> or <i>GNOME</i>, the X
Window System will automatically be installed.
</p>
"));
    // help part 2 of 3
    helptext = helptext + UI(_("<p>
Software categories may overlap -- there may be software packages
that belong to <i>Multimedia</i> as well as to <i>KDE</i>.
That is why the required disk space is not displayed along with the
categories. The total disk space required depends on the combination
of selected categories.
</p>
"));
     // help part 3 of 3
     helptext = helptext + UI(_("<p>
SuSE Linux comes with all the source code, so you have the option to
<b>install available sources</b> for selected components. 
Note: sources are not available for commercial software.
</p>
<br>
"));

    Wizard::SetContents(title, contents, helptext, Args(0),Args(1));
    
    any ret = nil;
    while (true)
    {

	// Saving old selections
	list old_sel = software_group;
	boolean selected = false;

	foreach(`sel, filter(`ps, pacsels,
			     ``(select(ps, 2, "") == "addon")), ``{
	    string id = select(sel, 0, "");
	    if (UI::QueryWidget(`id(id), `Value))
		old_sel = add(old_sel, id);
	});
	
	ret = Wizard::UserInput();

	if ( ret == `abort && CallFunction(`inst_confirm_abort(`painless) ) )
	    return `abort;
      
	if ( ret == `back || ret == `cancel )
	{
	    break;  
	}                  

	current_sel = software_group;

	// Query the addon checkboxes

	foreach(`sel, filter(`ps, pacsels, ``(select(ps, 2, "") == "addon")), ``{
	    string id = select(sel, 0, "");
	    if (UI::QueryWidget(`id(id), `Value))
	    {
		current_sel = add(current_sel, id);
		if ( !contains( old_sel, id ) )
		{
		    // new selection selected
		    actual_sel = id;
		    selected = true;
		}
	    }
	});

	if ( current_sel != old_sel )
	{
	    if ( selected )
	    {
		y2milestone( "Selected: %1", actual_sel );
		
		if ( SelectSel( actual_sel, false ) )
		{
		    ret = `again;
		    break;
		}
	    }
	    else
	    {
		// find the selection which has been deselected
		foreach(`sel, old_sel, ``{
		    if ( !contains ( current_sel, sel ) )
		    {
			// selection deselected
			actual_sel = sel;
			selected = false;
		    }
		});    		
		y2milestone( "Deselected: %1", actual_sel );		

		if ( DeselectSel( actual_sel ) )
		{
		    ret = `again;
		    break;
		}
	    }
	}

	// showing all selected and autoselected selections
	current_sel = SCR::Read(.package.selInstallSet);
	y2milestone( "Current selections : %1", current_sel );			
	foreach(`sel, pacsels, ``{
	    string   selid   = select(sel, 0, "");
	    string   group   = select(sel, 2, "");
	    string   seldesc = select(sel, 1, "");

	    if ( group == "addon" )
	    {
		UI::ChangeWidget(`id(selid), `Value, contains(current_sel, selid));
	    }
	});

	// .Minimal has no X11
	if (contains(current_sel, "Minimal")
	    && (!(contains(current_sel, "Kde") || contains (current_sel, "Gnome"))))
	    X11::have_x11 = false;
	else
	    X11::have_x11 = true;

	// installation of source packages ?
	Packages::install_sources = UI::QueryWidget(`id(`sources), `Value);
	SCR::Execute(.package.setSourceInstallation, Packages::install_sources );

	if ( Mode::test )
	{ 
	    // TEST MODE !!!
	    // Check, if there is a unresolved dependency
	    map    pac_depends = $[];
	    list(map) or_depends = [];
	    list(map) xor_depends = [];
	    pac_depends = SCR::Read(.package.dependencies);
	    y2debug( "TESTMODE: check-dependencies BEFORE solving" );  
	    or_depends = lookup( pac_depends, "REQUIRE", [] );
	    y2debug( "REQUIRE Dependencies: %1", or_depends );
	    xor_depends = lookup( pac_depends, "CONFLICT", [] );
	    y2debug( "CONFLICT Dependencies: %1", xor_depends );
	    list install_list =  SCR::Read(.package.installSet);
	    y2debug( "getInstallSet: %1",install_list );
	}

	if ( ret == `sw_pay )
	{
	    ret = CallFunction( `inst_sw_single( `pay, `not_only_checked ) );

	    if ( ret == `ok || ret == `cancel_single )
		ret = `again;
	    break;
	}
	else if ( ret == `sw_single )
	{
	    ret = CallFunction( `inst_sw_single( `single, `not_only_checked ) );
	   
	    if ( ret == `ok || ret == `cancel_single )
		ret = `again;
	    break;
	}
      
	// Check, if there is a unresolved dependency
	map    pac_depends = $[];
	list(map) or_depends = [];
	list(map) xor_depends = [];
	pac_depends = SCR::Read(.package.dependencies);
	   
	or_depends = lookup( pac_depends, "REQUIRE", [] );
	y2debug( "REQUIRE Dependencies: %1", or_depends );
	xor_depends = lookup( pac_depends, "CONFLICT", [] );
	y2debug( "CONFLICT Dependencies: %1", xor_depends );

	if ( or_depends != [] || xor_depends != [] )
	{
	    // There is an unresolved dependency -> call single-package-selection
	    // to solve it ( only if user did any single selection before )
	    if ( SCR::Read(.package.isSingleSelected ))
	    {
		CallFunction( `inst_sw_single( `single, `only_check ) );
	    }
	    else
	    {
		y2warning("Unresolved: REQUIRE: %1, CONFLICT: %2", or_depends, xor_depends);
	    }
	}

	if ( Mode::test )
	{
	    // TEST MODE !!!
	    // Check, if there is a unresolved dependency
	    map    pac_depends = $[];
	    list(map) or_depends = [];
	    list(map) xor_depends = [];
	    pac_depends = SCR::Read(.package.dependencies);
	    y2debug( "TESTMODE: check-dependencies AFTER solving" );  
	    or_depends = lookup( pac_depends, "REQUIRE", [] );
	    y2debug( "REQUIRE Dependencies: %1", or_depends );
	    xor_depends = lookup( pac_depends, "CONFLICT", [] );
	    y2debug( "CONFLICT Dependencies: %1", xor_depends );
	    list install_list =  SCR::Read(.package.installSet);
	    y2debug( "getInstallSet: %1",install_list );
	}
	
	// calculating size

	if ( !SpaceCalculation::ShowPartitionWarning() )
	{
	    if ( ret == `next || ret == `again )
	    {
		break;
	    }
	}
	UI::ChangeWidget( `id(`free_space),
			  `Value, sformat( UI(_("%1 required disk space")),
					   SpaceCalculation::GetRequSpace( false) ) );
			 
	
    }

    y2milestone( "inst_sw_details return: %1", ret );

    return ret;
}
