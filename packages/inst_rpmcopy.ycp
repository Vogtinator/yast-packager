/**
 * Module: 		inst_rpmcopy.ycp
 *
 * Authors:		Mathias Kettner <kettner@suse.de>
 *			Klaus Kaempf <kkaempf@suse.de> (initial)
 *			Stefan Hundhammer <sh@suse.de> (slide show)
 *
 * Purpose:
 * Install all the RPM packages the user has selected.
 * Show installation dialogue. Show progress bars.
 * Request medium change from user.
 *
 * Packages module :
 *			"installed"
 *
 *
 * $Id$
 */

{
    textdomain "packager";

    import "Arch";
    import "AutoInstall";
    import "Report";
    import "Mode";
    import "Installation";
    import "Version";
    import "Language";

    import "SpaceCalculation";
    import "PackageInstallation";
    import "InstMedia";
    import "MediaUI";
    import "Packages";

    import "SlideShow";
    import "Wizard";

    include "showlog_defines.ycp";
    include "ui/common_popups.ycp";

    boolean packager_called = false;		// is there any package installed/deleted
                                                // (only used if Mode::normal is set)



    //----------------------------------------------------------------------
    //				     MAIN
    //----------------------------------------------------------------------

    string tmpdir	= SCR::Read(.target.tmpdir);
    string language	= Language::language;

    any 	ret 		= nil;	// return value module packager
    list 	rpm_list 	= [];
    list 	descr_list 	= [];

    SlideShow::SetLanguage( language );
    SlideShow::OpenSlideShowDialog();

    if (size(WFM::Args()) >= 3 )
    {
	// third argument can be a package name or a list of packages
	if ( is(WFM::Args(2), string) )
	{
	    rpm_list = add( rpm_list, WFM::Args(2) );
	}
	else if ( is(WFM::Args(2), list) )
	{
	    rpm_list = WFM::Args(2);
	}

	if (size(WFM::Args()) == 4 )
	{
	   // forth argument is a list of package descriptions
	   if ( is(WFM::Args(3), list) )
	    {
		descr_list = WFM::Args(3);
	    }
	}
    }

    if ( Mode::cont
	 && !Mode::normal )
    {
	// initialize the package agent in continue mode
	Packages::Init( true );
	Packages::Restore();
        SCR::Execute(.target.bash, "/bin/echo "+ "'YaST2 Version " + Version::yast2 + "' > /dev/tty2");
    }

    if (Mode::initial
	&& !Mode::update)
    {
	// create new rpmdb

	Pkg::TargetInit (Installation::destdir, true);
    }
    else
    {
	// use existing rpmdb

	Pkg::TargetInit (Installation::destdir, false);
    }
    SCR::Execute(.target.mkdir, Installation::destdir+"/var/log/YaST2");
    Pkg::TargetLogfile (Installation::destdir+"/var/log/YaST2/y2logRPM");

    // Now that we know how many packages to install, we can show the dialog

    integer packages_installed = 0;

    if ( !Mode::initial)
    {
	// get the number of already installed packages
	packages_installed = Packages::installed;
    }

    // y2debug("%1 packages have been installed", packages_installed);


    // ----------------------------------------------------------------------
    // normal

    if ( size (rpm_list) > 0)
    {
	y2milestone( "Installing RPM_LIST: %1", rpm_list );

	list package_list = [];
	integer counter = 0;

	foreach( `rpm, rpm_list,
	``{
	    list package_info = [];
	    package_info = add(package_info, rpm );

	    if ( size ( descr_list ) > counter )
	    {
		package_info = add (package_info, descr_list[counter]:"" );
	    }
	    else
	    {
		package_info = add (package_info, "description" );
	    }
	    package_info = add (package_info, 1 );
	    package_info = add (package_info, false );
	    package_list = add (package_list, package_info);
	    counter = counter + 1;
	});

	ret = PackageInstallation::InstallPackages( package_list, // package_list (including absolut pathnames)
						    "",		  // source path
						    false,	  // not installing base packages
						    0 );	  // number of already installed packages

	if (ret == `cancel)
	{
	    return `abort;
	}
	else if (ret != `error &&
		 ret != `ok)
	{
	    Report::Error( _("The packager returned an unknown code") );
	}

        // close "Slide" dialog (inst_rpmcopy doesn't use the "Wizard" dialog)
        UI::CloseDialog();

	return `next;
    }

    // ----------------------------------------------------------------------
    // initial/cont

    if (Mode::initial)
    {
	// write a fake mtab to the target system since some %post scripts might need it
	string mtabname = "/etc/mtab";
	if (Mode::initial)
	{
	    string mtab = WFM::Read(.local.string, mtabname);
	    SCR::Write(.target.string, tmpdir + "/mtab", mtab);
	    SCR::Execute (.target.bash, "/bin/cat "
			+ tmpdir + "/mtab"
			+ " | /bin/sed \"s: " + Installation::destdir
			+ "/: /:\"| /bin/sed \"s: " + Installation::destdir
			+ ": /:\" > " + Installation::destdir + mtabname);
	}
	// add additional (internal) packages, like kernel etc.
	Pkg::DoProvide (Packages::ComputeSystemPackageList());
    }

    if  (Mode::autoinst
	 && Mode::cont)
    {
	// extra packages from autoinstall
	Pkg::DoProvide( AutoInstall::postPackageList());
    }

    SlideShow::InitPkgData();

    // Install the software from Medium1 to Mediummax, but not the already
    // installed base packages.
    // This part is also used for installation in running system (Mode::cont, Mode::normal)

    integer maxnumbercds = 10;
    integer current_cd_no = 1;

    if (Mode::initial)
    {
	maxnumbercds = 1; // only the first CD will be installed
    }
    else if (Mode::cont && !Mode::normal)
    {
	current_cd_no = 2; // continue with second CD but only in continue mode
    }
    // else
    // Mode::normal means start with first CD

    while (current_cd_no <= maxnumbercds)
    {
	boolean go_on = true;

	ret = PackageInstallation::InstallPackages( current_cd_no,			// media nr
						    packages_installed );		// number of packages installed

	packager_called = true;
	// FIXME diskfull, abort/cancel
	if (ret > 0)
	{
	    y2milestone ("%1 packages installed ok", ret);
	    packages_installed = packages_installed + ret;
	}
	else
	{
	    y2milestone ("%1 packages installed ok", ret);
	    y2milestone ("%1 packages failed: %2", size (PackageInstallation::error_packages), PackageInstallation::error_packages);
	    Report::Error( sformat ("Failed: %1", PackageInstallation::error_packages));
	    packages_installed = packages_installed - ret;
	}

	// break on first round with Mediums
	if (Mode::initial
	    && InstMedia::splitted
	    && !Mode::test )
	    break;

	current_cd_no = current_cd_no + 1;
    }

    if ( Mode::initial )
    {
	Packages::installed = packages_installed;
    }
    else
    {
	// Everything done, remove that thing.

	// don't remove it - keep it for debugging
	// SCR::Execute (.target.remove, Installation::yast2dir + "/pacs_to_install");
	// SCR::Execute (.target.remove, Installation::yast2dir + "/package_counter.ycp");
    }

    InstMedia::UnmountMedium();

    // close "Slide" dialog (inst_rpmcopy doesn't use the "Wizard" dialog)
    UI::CloseDialog();

    if ( Mode::normal && !packager_called )
	return `finish;
    else
	return `next;
}
