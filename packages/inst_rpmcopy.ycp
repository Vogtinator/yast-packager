/**
 * Module: 		inst_rpmcopy.ycp
 *
 * Authors:		Klaus Kaempf <kkaempf@suse.de>
 *			Stefan Hundhammer <sh@suse.de> (slide show)
 *
 * Purpose:
 * Install all the RPM packages the user has selected.
 * Show installation dialogue. Show progress bars.
 * Request medium change from user.
 *
 * Packages module :
 *			"installed"
 *
 *
 * $Id$
 */

{
    textdomain "packager";

    import "Arch";
    import "AutoInstall";
    import "Report";
    import "Mode";
    import "Installation";
    import "Version";
    import "Language";

    import "SpaceCalculation";
    import "PackageInstallation";
    import "Packages";
    import "SlideShow";
    import "Wizard";

    include "showlog_defines.ycp";
    include "ui/common_popups.ycp";

    boolean packager_called = false;		// is there any package installed/deleted
                                                // (only used if Mode::normal is set)

    //----------------------------------------------------------------------
    //				     MAIN
    //----------------------------------------------------------------------

    string tmpdir	= SCR::Read(.target.tmpdir);
    string language	= "";

    if (Mode::initial)
    {
	language = Language::language;
	Pkg::SetLocale (language);
    }
    else
    {
	language = Pkg::GetLocale ();	// language is set from $LANG environment
    }

    any		ret		= nil;	// return value module packager
    list	rpm_list	= [];
    list	descr_list	= [];

    SlideShow::SetLanguage( language );
    SlideShow::OpenSlideShowDialog();

    if (size(WFM::Args()) >= 3 )
    {
	// third argument can be a package name or a list of packages
	if ( is(WFM::Args(2), string) )
	{
	    rpm_list = add( rpm_list, WFM::Args(2) );
	}
	else if ( is(WFM::Args(2), list) )
	{
	    rpm_list = WFM::Args(2);
	}

	if (size(WFM::Args()) == 4 )
	{
	   // forth argument is a list of package descriptions
	   if ( is(WFM::Args(3), list) )
	    {
		descr_list = WFM::Args(3);
	    }
	}
    }

    if ( Mode::cont
	 && !Mode::normal )
    {
	// initialize the package agent in continue mode
	Packages::Init( true );
	Packages::Restore();
        SCR::Execute(.target.bash, "/bin/echo "+ "'YaST2 Version " + Version::yast2 + "' > /dev/tty2");
    }

    if (Mode::initial
	&& !Mode::update)
    {
	// create new rpmdb

	Pkg::TargetInit (Installation::destdir, true);
	SCR::Execute(.target.mkdir, Installation::destdir+"/etc");
	SCR::Execute(.target.mkdir, Installation::destdir+"/var/log/YaST2");

	// hack 'pre-req' cyclic dependency between bash, aaa_base, and perl
	SCR::Execute(.target.bash, "/bin/cp /etc/passwd " + Installation::destdir+"/etc");
	SCR::Execute(.target.bash, "/bin/cp /etc/group " + Installation::destdir+"/etc");

    }
    else	// run-time
    {
	// use existing rpmdb

	Pkg::TargetInit (Installation::destdir, false);

    }
    Pkg::TargetLogfile (Installation::destdir+"/var/log/YaST2/y2logRPM");

    // Now that we know how many packages to install, we can show the dialog

    integer packages_installed = 0;

    if ( !Mode::initial)
    {
	// get the number of already installed packages
	packages_installed = Packages::installed;
    }

    // y2debug("%1 packages have been installed", packages_installed);


    // ----------------------------------------------------------------------
    // normal

    if ( size (rpm_list) > 0)
    {
	y2milestone( "Installing RPM_LIST: %1", rpm_list );
	foreach (`pkg, rpm_list,
	``{
	    Pkg::PkgInstall (pkg);
	});
	Pkg::PkgSolve();
	PackageInstallation::CommitPackages (0, 0);

        // close "Slide" dialog (inst_rpmcopy doesn't use the "Wizard" dialog)
        UI::CloseDialog();

	return `next;
    }

    // ----------------------------------------------------------------------
    // initial/cont

    if (Mode::initial)
    {
	// write a fake mtab to the target system since some %post scripts might need it
	string mtabname = "/etc/mtab";
	if (Mode::initial)
	{
	    string mtab = WFM::Read(.local.string, mtabname);
	    SCR::Write(.target.string, tmpdir + "/mtab", mtab);
	    SCR::Execute (.target.bash, "/bin/cat "
			+ tmpdir + "/mtab"
			+ " | /bin/sed \"s: " + Installation::destdir
			+ "/: /:\"| /bin/sed \"s: " + Installation::destdir
			+ ": /:\" > " + Installation::destdir + mtabname);
	}
    }

    if  (Mode::autoinst
	 && Mode::cont)
    {
	// post packages from autoinstall
	Pkg::DoProvide( AutoInstall::postPackageList());
	Pkg::PkgSolve();
    }

    if (!Mode::initial)
    {
	list remaining = SCR::Read (.target.ycp, ["/var/lib/YaST2/remaining", []]);
	if (remaining == nil)
	    remaining = [];
	y2milestone ("%1 packages remaining", size (remaining));
	foreach (`pkg, remaining,
	``{
	    Pkg::PkgInstall (pkg);
	});
    }

    // Install the software from Medium1 to Mediummax, but not the already
    // installed base packages.
    // This part is also used for installation in running system (Mode::cont, Mode::normal)

    integer maxnumbercds = 10;
    integer current_cd_no = 1;

    if (Mode::initial)
    {
	maxnumbercds = 1; // only the first CD will be installed
    }
    else if (Mode::autoinst && Mode::cont && size(AutoInstall::postPackageList()) > 0)
    {
	// one more compatibility feature to old YaST, post-packages
	// Simply install a list of package after initial installation (only
	// makes sense with nfs installatons)
	maxnumbercds = 1;
    }
    else if (Mode::cont && !Mode::normal)
    {
	current_cd_no = 2; // continue with second CD but only in continue mode
    }


    // else
    // Mode::normal means start with first CD

    while (current_cd_no <= maxnumbercds)
    {
	boolean go_on = true;

	// returns [ int successful, list failed, list remaining ]
	list commit_result = PackageInstallation::CommitPackages( current_cd_no, packages_installed );

	integer count = commit_result[0]:0;
	packages_installed = packages_installed + count;
	y2milestone ("%1 packages installed", count);

	list failed = commit_result[1]:[];
	if (size (failed) > 0)
	{
	    y2milestone ("failed: %1", failed);
	    list previous_failed = SCR::Read (.target.ycp, [Installation::destdir + "/var/lib/YaST2/failed_packages", []]);
	    if (size (previous_failed) > 0)
		failed = union (previous_failed, failed);
	    SCR::Write (.target.ycp, Installation::destdir + "/var/lib/YaST2/failed_packages", failed);
	}
	list remaining = commit_result[2]:[];
	if (size (remaining) > 0)
	{
	    y2milestone ("remaining: %1", remaining);
	    SCR::Write (.target.ycp, Installation::destdir + "/var/lib/YaST2/remaining", remaining);
	}
	list srcremaining = commit_result[2]:[];
	if (size (srcremaining) > 0)
	{
	    y2milestone ("source remaining: %1", srcremaining);
	    SCR::Write (.target.ycp, Installation::destdir + "/var/lib/YaST2/srcremaining", srcremaining);
	}

	packager_called = true;

	// FIXME diskfull, abort/cancel

	// break on first round with Mediums
	if (Mode::initial && !Mode::test )
	    break;

	current_cd_no = current_cd_no + 1;
    }

    Packages::installed = packages_installed;

    // close "Slide" dialog (inst_rpmcopy doesn't use the "Wizard" dialog)
    UI::CloseDialog();

    if ( Mode::normal && !packager_called )
	return `finish;
    else
	return `next;
}
