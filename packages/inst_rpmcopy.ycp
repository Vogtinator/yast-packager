/**
 * Module: 		inst_rpmcopy.ycp
 *
 * Authors:		Klaus Kaempf <kkaempf@suse.de>
 *			Stefan Hundhammer <sh@suse.de> (slide show)
 *
 * Purpose:
 * Install all the RPM packages the user has selected.
 * Show installation dialogue. Show progress bars.
 * Request medium change from user.
 *
 * Packages module :
 *			"installed"
 *
 *
 * $Id$
 */

{
    textdomain "packager";

    import "Arch";
    import "AutoInstall";
    import "Report";
    import "Mode";
    import "Installation";
    import "Version";
    import "Language";

    import "SpaceCalculation";
    import "PackageInstallation";
    import "Packages";
    import "SlideShow";
    import "Wizard";
    import "Popup";

    import "AutoinstSoftware";


    if (Mode::initial && Mode::update)
	return `auto;


    boolean packager_called = false;		// is there any package installed/deleted
                                                // (only used if Mode::normal is set)

    //----------------------------------------------------------------------
    //				     MAIN
    //----------------------------------------------------------------------

    string tmpdir	= (string) SCR::Read(.target.tmpdir);
    string language	= "";

    language = Language::language;
    Pkg::SetLocale (language);

    any		ret		= nil;	// return value module packager
    list	rpm_list	= [];
    list	descr_list	= [];

    SlideShow::SetLanguage( language );
    SlideShow::OpenSlideShowDialog();

    if (size(WFM::Args()) >= 3 )
    {
	// third argument can be a package name or a list of packages
	if ( is(WFM::Args(2), string) )
	{
	    rpm_list = add( rpm_list, WFM::Args(2) );
	}
	else if ( is(WFM::Args(2), list) )
	{
	    rpm_list = (list) WFM::Args(2);
	}

	if (size(WFM::Args()) == 4 )
	{
	   // forth argument is a list of package descriptions
	   if ( is(WFM::Args(3), list) )
	    {
		descr_list = (list) WFM::Args(3);
	    }
	}
    }

    // start target, create new rpmdb if none is existing
    // FIXME error checking is missing all around here, initialization could actually fail!
    Pkg::TargetInit (Installation::destdir, true);

    if (Mode::initial
	&& !Mode::update)
    {
	// created new rpmdb

	SCR::Execute(.target.mkdir, Installation::destdir+"/etc");
	SCR::Execute(.target.mkdir, Installation::destdir+"/var/log/YaST2");

	// hack 'pre-req' cyclic dependency between bash, aaa_base, and perl
	SCR::Execute(.target.bash, "/bin/cp /etc/passwd " + Installation::destdir+"/etc");
	SCR::Execute(.target.bash, "/bin/cp /etc/group " + Installation::destdir+"/etc");

    }
    else if (Mode::cont)
    {
	// initialize the package agent in continue mode
	Packages::Init( true );
        SCR::Execute(.target.bash, "/bin/echo "+ "'YaST2 Version " + Version::yast2 + "' > /dev/tty2");
    }
    Pkg::TargetLogfile (Installation::destdir+"/var/log/YaST2/y2logRPM");

    // ----------------------------------------------------------------------
    // normal

    if ( size (rpm_list) > 0)
    {
	y2milestone( "Installing RPM_LIST: %1", rpm_list );
	foreach (string pkg, rpm_list,
	``{
	    Pkg::PkgInstall (pkg);
	});
	Pkg::PkgSolve(false);
	list commit_result = PackageInstallation::CommitPackages (0, 0);

        // close "Slide" dialog (inst_rpmcopy doesn't use the "Wizard" dialog)
        UI::CloseDialog();

	if (commit_result[0]:0 < 0)
	    return `abort;

	return `next;
    }

    // ----------------------------------------------------------------------
    // initial/cont

    if (Mode::initial)
    {
	// write a fake mtab to the target system since some %post scripts might need it
	string mtabname = "/etc/mtab";
	if (Mode::initial)
	{
	    string mtab = (string) WFM::Read(.local.string, mtabname);
	    SCR::Write(.target.string, tmpdir + "/mtab", mtab);
	    SCR::Execute (.target.bash, "/bin/cat "
			+ tmpdir + "/mtab"
			+ " | /bin/sed \"s: " + Installation::destdir
			+ "/: /:\"| /bin/sed \"s: " + Installation::destdir
			+ ": /:\" > " + Installation::destdir + mtabname);
	}
    }

    if  (Mode::autoinst
	 && Mode::cont)
    {
	import "AutoinstSoftware";
	// post packages from autoinstall
	Pkg::DoProvide( AutoinstSoftware::post_packages );
	Pkg::PkgSolve(false);
    }

    if (!Mode::initial)
    {
	// second stage of package installation, re-read list of remaining binary and source
	// packages

	list remaining = (list) SCR::Read (.target.ycp, ["/var/lib/YaST2/remaining", []]);
	if (remaining == nil)
	    remaining = [];

	list srcremaining = (list) SCR::Read (.target.ycp, ["/var/lib/YaST2/srcremaining", []]);
	if (srcremaining == nil)
	    srcremaining = [];

	string backupPath = (string) SCR::Read(.target.string, [Installation::destdir + "/var/lib/YaST2/backup_path", ""]);
	if ( backupPath != nil && backupPath != "")
	{
	    y2milestone("create package backups in %1",backupPath);
	    Pkg::CreateBackups (true);
	    Pkg::SetBackupPath (backupPath);
	}

	y2milestone ("%1 binary packages remaining", size (remaining));
	foreach (string pkg, remaining,
	``{
	    Pkg::PkgInstall (pkg);
	});

	y2milestone ("%1 source packages remaining", size (srcremaining));
	foreach (string pkg, srcremaining,
	``{
	    Pkg::PkgSrcInstall (pkg);
	});
    }

    // Install the software from Medium1 to Mediummax, but not the already
    // installed base packages.
    // This part is also used for installation in running system (Mode::cont, Mode::normal)

    integer maxnumbercds = 10;
    integer current_cd_no = 1;

    if (Mode::initial)
    {
	maxnumbercds = 1; // only the first CD will be installed
    }
    else if (Mode::autoinst && Mode::cont && size( AutoinstSoftware::post_packages ) > 0)
    {
	// one more compatibility feature to old YaST, post-packages
	// Simply install a list of package after initial installation (only
	// makes sense with nfs installatons)
	current_cd_no = 1;
    }
    else if (Mode::cont && !Mode::normal)
    {
	current_cd_no = 2; // continue with second CD but only in continue mode
    }

    if (Packages::metadir_used)			// all is in ramdisk, we can install all sources now
    {
	current_cd_no = 0;
	maxnumbercds = 0;
    }

    symbol result = `next;
    // else
    // Mode::normal means start with first CD

    while (current_cd_no <= maxnumbercds)
    {
	boolean go_on = true;

	// returns [ int successful, list failed, list remaining ]
	list commit_result = PackageInstallation::CommitPackages( current_cd_no, 0 );

	integer count = commit_result[0]:0;
	y2milestone ("%1 packages installed", count);

	list failed = commit_result[1]:[];
	if (size (failed) > 0)
	{
	    y2milestone ("failed: %1", failed);
	    list previous_failed = (list) SCR::Read (.target.ycp, [Installation::destdir + "/var/lib/YaST2/failed_packages", []]);
	    if (size (previous_failed) > 0)
		failed = union (previous_failed, failed);
	    SCR::Write (.target.ycp, Installation::destdir + "/var/lib/YaST2/failed_packages", failed);
	}
	list remaining = commit_result[2]:[];
	if (size (remaining) >= 0)
	{
	    y2milestone ("remaining: %1", remaining);
	    SCR::Write (.target.ycp, Installation::destdir + "/var/lib/YaST2/remaining", remaining);
	}
	list srcremaining = commit_result[3]:[];
	if (size (srcremaining) >= 0)
	{
	    y2milestone ("source remaining: %1", srcremaining);
	    SCR::Write (.target.ycp, Installation::destdir + "/var/lib/YaST2/srcremaining", srcremaining);
	}

	packager_called = true;

	if (count < 0)					// aborted by user
	{
	    result = `abort;
	    break;
	}

	// break on first round with Mediums
	if (Mode::initial && !Mode::test )
	    break;

	current_cd_no = current_cd_no + 1;
    }

    // sync package manager FIXME
    Pkg::PkgCommit (9999);

    // close "Slide" dialog (inst_rpmcopy doesn't use the "Wizard" dialog)
    UI::CloseDialog();

    if ( Mode::normal && !packager_called )
	return `finish;

    return result;
}
