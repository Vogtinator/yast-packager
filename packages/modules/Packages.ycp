/**
 * File:	Packages.ycp
 * Package:	Package selections
 * Authors:	Anas Nashif (nashif@suse.de)
 * Summary:	?
 *
 * $Id$
 */

{

    module "Packages";
    import "Mode";
    import "Product";
    import "Installation";
    import "Language";
    import "Kernel";
    import "SpaceCalculation";
    import "Report";

    textdomain "packager";

    global boolean install_sources = false; // Installing source packages ?
    global integer installed = 0;	// amount of already installed packages
    global integer timestamp = 0;	// last time of getting the target map

    global integer theSource = -1;

    // Local variables

    string tmpdir	= SCR::Read(.target.tmpdir);

    boolean init_called = false;

    /*-----------------------------------------------------------------------
     * LOCALE FUNCTIONS
     *-----------------------------------------------------------------------*/

    define void architecturePackages ()
    ``{
	list packages = [];

	// check for PCMCIA and add package
	if (Arch::has_pcmcia)
	{
	    packages = add (packages, "pcmcia");
	    packages = add (packages, "apmd");
	}


	// check for blinux and add package
	if (Mode::braille)
	{
	    packages = add (packages, "sbl");
	}

	// check for aboot or mile on alpha and add package
	if (Arch::alpha)
	{
	    if (Boot::LoaderType == "aboot")
	    {
		packages = add (packages, "aboot");
	    }
	    else if (Boot::LoaderType == "milo")
	    {
		packages = add (packages, "milo");
	    }

	}

	// remove unneeded / add needed packages for ppc
	if (Arch::ppc)
	{
	    if (Arch::board_iseries)
	    {
		packages = add (packages, "ibmsis");
		packages = add (packages, "scsi");
	    }

	    if (Arch::board_mac)
	    {
		packages = add (packages, "mouseemu");
	    }

	    if (Arch::board_mac_new
		|| Arch::board_mac_old)
	    {
		string pmac_board = "";
		list pmac_compatible = SCR::Read(.probe.cpu);
		foreach (`pmac_compatible, pmac_compatible,
		``{
		    pmac_board = pmac_compatible["system"]:"";
		});

		// install pmud on PowerBooks and iMacs
		if (issubstring (pmac_board, "PowerBook")
		    || issubstring (pmac_board, "PowerMac2,1")
		    || issubstring (pmac_board, "PowerMac2,2")
		    || issubstring (pmac_board, "PowerMac4,1")
		    || issubstring (pmac_board, "iMac,1"))
		{
		    packages = add (packages, "pmud");
		}

		// mol is fun, and needs root access to kmem
		packages = add (packages, "mol");
		packages = add (packages, "sudo");
	    }
	}

	return packages;
    }


    /**
     * graphicPackages ()
     * Compute graphic (x11) packages
     * @return list(string)	list of rpm packages needed
     *
     */

    define list graphicPackages ()
    ``{
	import "Display";

	list packages = [];

	// dont setup graphics if running via serial console

	if (Mode::serial_console)
	{
	    return packages;
	}

	packages = Display::pacs_to_install;

	y2milestone("X11 Packages to install: %1", packages);
	return packages;
    }



    /**
     * Compute packages needed for autoinstallation
     * @return list(string)
     */

    define list autoinstPackages()
	``{
	import "AutoInstall";

	map configure = AutoInstall::Profile["configure"]:$[];
	list packages = [];

	packages = union (packages, AutoInstall::packageList());

	// In autoinst mode, a kernel might be external and not available
	// in common.pkd
	if (size(AutoInstall::Kernel) == 0)
	{
	    packages = union (packages, Kernel::kernel_packages);
	}

	if (haskey(configure, "nis")) {
		map nis = configure["nis"]:$[];
		if (nis["start_nis"]:false)
			packages = add(packages, "ypbind");
		if (nis["start_autofs"]:false)
			packages = add(packages, "autofs");
	}

	if (haskey(configure, "ldap")) {
		map ldapclient = configure["ldap"]:$[];
		if (ldapclient["start_ldap"]:false)
			packages = union(packages, ["pam_ldap","nss_ldap"]);
	}


	if (haskey(configure, "inetd")) {
		map inetd = configure["inetd"]:$[];
		if (inetd["start_inetd"]:false)
			packages = add(packages, "inetd");
	}

	if (haskey(configure, "nisplus")) {
		map nisplus = configure["nisplus"]:$[];
		if (nisplus["start_nisplus"]:false)
			packages = add(packages, "nis-utils");
	}
	if (haskey(configure, "mail")) {
		map mail = configure["mail"]:$[];
		if (mail["mta"]:`other == `postfix)
		{
			packages = add(packages, "postfix");
			if (mail["use_amavis"]:false)
				packages = add(packages, "amavis-postfix");
		}
		else if (mail["mta"]:`other == `sendmail)
		{
			packages = add(packages, "sendmail");
			if (mail["use_amavis"]:false)
				packages = add(packages, "amavis-sendmail");
		}
	}
	y2milestone("package list needed for auto-installation: %1", packages);
	return packages;
    }

    /**
     * Compute special packages
     * @return list(string)
     */

    define list modePackages ()
    ``{
	list packages = [];

	if (Mode::vnc)
	{
	    packages = ["vnc", "yast2-qt", "xf86", "mesasoft"];
	}

    	return packages;
    }

    /**
     * Compute special java packages
     * @return list(string)
     */

    define list javaPackages ()
    ``{
	if (!Arch::alpha)
	    return [];

	list packages = [];

	list cpus = SCR::Read (.probe.cpu);
	string model = cpus[0, "model"]:"EV4";
	string cputype = substring (model, 2, 1);

	if ((cputype == "6") || (cputype == "7") || (cputype == "8"))
	{
	    packages = ["cpml_ev6"];
	}
	else
	{
	    packages = ["cpml_ev5"];
	}
	return packages;
    }


    /*-----------------------------------------------------------------------
     * GLOBAL FUNCTIONS
     *-----------------------------------------------------------------------*/

    /**
     * Build and return list of packages which depends on the
     * the current target system and the preselected packages
     * ( architecture, X11....)
     */

    global define list ComputeSystemPackageList ()
    ``{
	list install_list =  architecturePackages ();

	install_list = union (install_list, modePackages ());

	// Kernel is added in autoinstPackages () if autoinst is enabled
	if (Mode::autoinst)
	{
	    install_list = union (install_list, autoinstPackages ());
	}
	else
	{
	    install_list = union (install_list, Kernel::kernel_packages);
	}

	if (Pkg::IsSelected("xf86")
	    || Mode::live_eval)
	{
	    install_list = union (install_list, graphicPackages ());
	}

	if (Pkg::IsSelected("java"))
	{
	    install_list = union (install_list, javaPackages ());
	}

	install_list = toset (install_list);
	return install_list;
    }

    /**
     * Restore()
     * Restore saved package list
     * @return void
     *
     */

    global define void Restore()
    ``{
	if ( !init_called )
	{
	    Packages::Init( true );
	}

	// FIXME restore package list

	installed = SCR::Read (.target.ycp,
			       [Installation::yast2dir+"/package_counter.ycp",
			       0] );

	y2milestone("Restored install list");
	return;
    }


    /**
     * SetBaseSelection (string base name)
     */

    global define boolean SetBaseSelection (string basename)
    ``{
	list base_selections = Pkg::GetSelections (`selected, "base");
	string current_base_selection = base_selections[0]:"";
	if (current_base_selection != "")
	{
	    Pkg::ClearSelection (current_base_selection);
	}
	Pkg::SetSelection (basename);
    }

    /**
     * Proposal()
     * Make a proposal for package selection
     * @return map for the API proposal;
     *
     */

    global define void Proposal( boolean force_reset, boolean reinit )
    ``{
	map ret = $[];

	UI::OpenDialog(`opt(`decorated ),`Label(_("Evaluating package selection...")));

	Pkg::SetLocale (Language::language);

	if ( force_reset )
	{
	    Kernel::ProbeKernel();
	    Packages::Init( true );	// reintialize AND reset package selection too
	}
	else if ( reinit )
	{
	    Packages::Init( false ); 	// reinitialize but keep former selection (if possible)
	}
	else
	{
	    Packages::Init( !init_called ); // reset completely only if necessary
	}

	UI::CloseDialog();

	// start with base selections

	y2milestone ("checking selected selection");

	list base_selections = Pkg::GetSelections (`selected, "base");
	string selected_base_selection = base_selections[0]:"";

	list selected_addon_selections = Pkg::GetSelections (`selected, "");
	y2milestone ("selected base is %1, addon is %2", selected_base_selection, selected_addon_selections);

	if (selected_base_selection == ""
	    || !SpaceCalculation::CheckDiskSize() )
	{
	    // make a new proposal or change a proposal,
	    // if it does not fit on the disk anymore

	    list available_base_selections = Pkg::GetSelections (`available, "base");
	    y2milestone ("available_base_selections %1", available_base_selections);
	    boolean fit = false;
	    integer counter = 0;

	    while (!fit
		   && counter < size(available_base_selections) )
	    {
		selected_base_selection = available_base_selections[counter]:"";

		y2milestone ("Checking space for %1", selected_base_selection);
		SetBaseSelection (selected_base_selection);

		if ( !SpaceCalculation::CheckDiskSize() )
		{
		    // does not fit --> trying next
		    counter = counter +1;
		}
		else
		{
		    fit = true;
		}
	    }
	    if (!fit)
	    {
		y2warning ("No selection fits, going to default");
		selected_base_selection = "default";
		if (!contains (available_base_selections, selected_base_selection))
		{
		    // no default.sel -> fallback to UnitedLinux.sel
		    selected_base_selection = "UnitedLinux";
		    if (!contains (available_base_selections, selected_base_selection))
		    {
			// no UnitedLinux.sel, fallback to first available base selection
			selected_base_selection = available_base_selections[0]:"";
			if (selected_base_selection == "")
			{
			    // no base selections at all -> give up
			    // this error appears only if the CD mastering
			    // process failed
			    // It should never happen, *if* (:-)) CDs are
			    // tested at least once before shipping ...
			    // (not marking as translatable on purpose !)
			    return $[ "warning" : "No base selection available",
				   warning_level : `blocker ];

			}
		    }
		}
		Pkg::SetSelection (selected_base_selection);
	    }

	    y2warning ("Get suggestions for %1", selected_base_selection);

	    map base_data = Pkg::SelectionData (selected_base_selection);
	    if (base_data == nil)
	    {
		base_data = $[];
	    }
	    selected_addon_selections = base_data["recommends"]:[];
	}
	else if (Product::certify_cd)
	{
	    // certification is only possible with this selection. If it doen't
	    // fit to disk, then the disk is too small so no further logic
	    // required.
	    y2milestone("force certify selection");
	    selected_base_selection = "certify";
	    Pkg::SetSelection (selected_base_selection);
	}


	// generate user readable output for proposal
	list output = [];

	map base_data = Pkg::SelectionData (selected_base_selection);
	if (base_data == nil)
	{
	    y2error ("No data for selection '%1'", selected_base);
	    base_data = $[];
	}
	y2milestone ("Base %1: %2", selected_base_selection, base_data);
	output = add (output, base_data["summary"]:"?");

	// add on
	foreach(`sel, base_data["recommends"]:[],
	``{
	    map recommend_data = Pkg::SelectionData (sel);
	    if ((recommend_data != nil)				// skip unknown selections
		&& (recommend_data["category"]:"" != "base"))
	    {
		output = add ( output, "+  " + recommend_data["summary"]:sel);
	    }
	});

	y2milestone ("proposal %1", output);

	// check only disk space, if the selected software selection
	// fits on the disk
	if ( !SpaceCalculation::CheckDiskSize() )
	{
//	    ret = $[ "warning" : _("Software selection does not fit on disk"),
//		   warning_level : `blocker ];
	    y2warning ("Software selection does not fit on disk");
	}

	ret = add ( ret, "raw_proposal", output );

	y2milestone ("activating selections");
	boolean act_sel = Pkg::ActivateSelections ();

	y2milestone ("activating: %1, returning %2", act_sel, ret);

	return ret;
    }


    /**
     * Init()
     * Initialize package module and package agent
     * @return void;
     *
     */

    global define void Init( boolean forceInit )
    ``{
	if (init_called)
	{
	    y2warning ("Packages::Init() already called");
	    return;
	}
	//
	// Initialize package manager
	//

	// usual mountpoint for the source medium
	string base_url = "";

	if ( Mode::test )
	{
	    // Fake values for testing purposes
	    base_url = "dir:///dist/next-i386";	   
	}
	else
	{
	    base_url = InstMedia::installInf2Url ();
	}

	if (Mode::initial)
	{
	    y2milestone ("Initialize Package Manager: %1", base_url);
	    theSource = Pkg::SourceInit (base_url);
	}
	else	// cont or normal mode
	{
	    list sources = Pkg::SourceList (true);
	    if (size (sources) > 0)
	    {
		theSource = sources[0]:-1;
	    }
	    else
	    {
		y2error ("Pkg::SourceList failed");
		theSource = -1;
	    }
	}
	if (theSource >= 0)
	{
	    init_called = true;
	}
	else
	{
	    // This text should be translated after 8.0.
	    // Currently this error should only occured while developping.
	    Report::Error( _("Error while initializing package descriptions.
Check the log file /var/log/YaST2/y2log for more details.") );
	}

	return;
    }

    /**
     * Save()
     * Used in inst_finish.ycp
     *
     */

    global define void Save()
    ``{
	if ( !init_called )
	{
	    Packages::Init( true );
	}
	y2warning ("Packages::Save() TBD");
	return;
    }


    /**
     * Constructor()
     * Load saved package lists
     * @return void;
     *
     */

    global define void Packages() ``{
	return;
    }

/* EOF */
}
