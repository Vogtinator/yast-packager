/**
 * File:	Packages.ycp
 * Package:	Package selections
 * Authors:	Anas Nashif (nashif@suse.de)
 * Summary:	?
 *
 * $Id$
 */

{
    module "Packages";

    import "Mode";
    import "Product";
    import "Installation";
    import "SpaceCalculation";
    import "Report";

    textdomain "packager";

    global boolean url_rewritten = false;	// url rewritten in continue mode ? (see Init())
    global boolean install_sources = false; // Installing source packages ?
    global integer timestamp = 0;	// last time of getting the target map

    global string slidedir = Installation::sourcedir + "/suse/setup/slide";
    global string metadir = "/yast-install";
    global boolean metadir_used = false;		// true if meta data and inst-sys is in ramdisk

    global list theSources = [];		// id codes of sources in priority order
    global list theSourceDirectories = [];	// product directories on sources
    global map  theSourceOrder = $[];		// installation order

    // Local variables

    string tmpdir	= SCR::Read(.target.tmpdir);

    boolean init_called = false;

    string choosen_base_selection = "";

    /*-----------------------------------------------------------------------
     * LOCALE FUNCTIONS
     *-----------------------------------------------------------------------*/

    define void architecturePackages ()
    ``{
	list packages = [];

	// check for PCMCIA and add package
	if (Arch::has_pcmcia)
	{
	    packages = add (packages, "pcmcia");
	    packages = add (packages, "apmd");
	}


	// check for blinux and add package
	if (Mode::braille)
	{
	    packages = add (packages, "sbl");
	}

	// check for aboot or mile on alpha and add package
	if (Arch::alpha)
	{
	    if (Boot::LoaderType == "aboot")
	    {
		packages = add (packages, "aboot");
	    }
	    else if (Boot::LoaderType == "milo")
	    {
		packages = add (packages, "milo");
	    }

	}

	// remove unneeded / add needed packages for ppc
	if (Arch::ppc)
	{
	    if (Arch::board_iseries)
	    {
		packages = add (packages, "ibmsis");
		packages = add (packages, "scsi");
	    }

	    if (Arch::board_mac)
	    {
		packages = add (packages, "mouseemu");
	    }

	    if (Arch::board_mac_new
		|| Arch::board_mac_old)
	    {
		string pmac_board = "";
		list pmac_compatible = SCR::Read(.probe.cpu);
		foreach (`pmac_compatible, pmac_compatible,
		``{
		    pmac_board = pmac_compatible["system"]:"";
		});

		// install pmud on PowerBooks and iMacs
		if (issubstring (pmac_board, "PowerBook")
		    || issubstring (pmac_board, "PowerMac2,1")
		    || issubstring (pmac_board, "PowerMac2,2")
		    || issubstring (pmac_board, "PowerMac4,1")
		    || issubstring (pmac_board, "iMac,1"))
		{
		    packages = add (packages, "pmud");
		}

		// mol is fun, and needs root access to kmem
		packages = add (packages, "mol");
		packages = add (packages, "sudo");
	    }
	}

	return packages;
    }


    /**
     * graphicPackages ()
     * Compute graphic (x11) packages
     * @return list(string)	list of rpm packages needed
     *
     */

    define list graphicPackages ()
    ``{
	import "Display";

	list packages = [];

	// dont setup graphics if running via serial console

	if (Mode::serial_console)
	{
	    return packages;
	}

	packages = Display::pacs_to_install;

	y2milestone("X11 Packages to install: %1", packages);
	return packages;
    }



    /**
     * Compute packages needed for autoinstallation
     * @return list(string)
     */

    define list autoinstPackages()
	``{
	import "AutoInstall";

	map configure = AutoInstall::Profile["configure"]:$[];
	list packages = [];

	packages = union (packages, AutoInstall::packageList());

	// In autoinst mode, a kernel might be external and not available
	// in packages
	if (size(AutoInstall::Kernel) == 0)
	{
	    import "Kernel";
	    packages = union (packages, Kernel::kernel_packages);
	}
	else {
	    packages = add (packages, AutoInstall::Kernel);
	}

	if (haskey(configure, "nis")) {
		map nis = configure["nis"]:$[];
		if (nis["start_nis"]:false)
			packages = add(packages, "ypbind");
		if (nis["start_autofs"]:false)
			packages = add(packages, "autofs");
	}

	if (haskey(configure, "ldap")) {
		map ldapclient = configure["ldap"]:$[];
		if (ldapclient["start_ldap"]:false)
			packages = union(packages, ["pam_ldap","nss_ldap"]);
	}

	if (haskey(configure, "nfs_server"))
	{
	    boolean start_nfsserver = configure["nfs_server", "start_nfsserver"]:false;
	    if (start_nfsserver)
		packages = union(packages, ["yast2-nfs-server", "nfs-utils"]);
	}

	if (haskey(configure, "inetd")) {
		map inetd = configure["inetd"]:$[];
		if (inetd["start_inetd"]:false)
			packages = add(packages, "inetd");
	}

	if (haskey(configure, "nisplus")) {
		map nisplus = configure["nisplus"]:$[];
		if (nisplus["start_nisplus"]:false)
			packages = add(packages, "nis-utils");
	}
	if (haskey(configure, "mail")) {
		map mail = configure["mail"]:$[];
		if (mail["mta"]:`other == `postfix)
		{
			packages = add(packages, "postfix");
			if (mail["use_amavis"]:false)
				packages = add(packages, "amavis-postfix");
		}
		else if (mail["mta"]:`other == `sendmail)
		{
			packages = add(packages, "sendmail");
			if (mail["use_amavis"]:false)
				packages = add(packages, "amavis-sendmail");
		}
	}
	list extraPackages = AutoInstall::calcExtraPackages ();
		
	if (size(extraPackages) > 0 )
	{
	    packages = union(packages,extraPackages);
	}
	
	y2milestone("package list calculated for auto-installation: %1", packages);
	return packages;
    }

    /**
     * Compute special packages
     * @return list(string)
     */

    define list modePackages ()
    ``{
	list packages = [];

	if (Mode::vnc)
	{
	    packages = ["vnc", "yast2-qt", "xf86", "mesasoft"];
	}

    	return packages;
    }

    /**
     * Compute special java packages
     * @return list(string)
     */

    define list javaPackages ()
    ``{
	if (!Arch::alpha)
	    return [];

	list packages = [];

	list cpus = SCR::Read (.probe.cpu);
	string model = cpus[0, "model"]:"EV4";
	string cputype = substring (model, 2, 1);

	if ((cputype == "6") || (cputype == "7") || (cputype == "8"))
	{
	    packages = ["cpml_ev6"];
	}
	else
	{
	    packages = ["cpml_ev5"];
	}
	return packages;
    }


    /*-----------------------------------------------------------------------
     * GLOBAL FUNCTIONS
     *-----------------------------------------------------------------------*/

    /**
     * Build and return list of packages which depends on the
     * the current target system and the preselected packages
     * ( architecture, X11....)
     */

    global define list ComputeSystemPackageList ()
    ``{
	list install_list =  architecturePackages ();

	install_list = union (install_list, modePackages ());

	// Kernel is added in autoinstPackages () if autoinst is enabled
	if (Mode::autoinst)
	{
	    install_list = union (install_list, autoinstPackages ());
	}
	else if (!Mode::update)
	{
	    install_list = union (install_list, Kernel::kernel_packages);
	}

	if (Pkg::IsSelected("xf86")
	    || Mode::live_eval)
	{
	    install_list = union (install_list, graphicPackages ());
	}

	if (Pkg::IsSelected("java"))
	{
	    install_list = union (install_list, javaPackages ());
	}

	install_list = toset (install_list);
	y2milestone ("auto-adding packages: %1", install_list);
	return install_list;
    }

    /**
     * SetBaseSelection (string base name)
     */

    global define boolean SetBaseSelection (string basename)
    ``{
	list base_selections = Pkg::GetSelections (`selected, "base");
	string current_base_selection = base_selections[0]:"";
	if (current_base_selection != "")
	{
	    Pkg::ClearSelection (current_base_selection);
	}
	Pkg::SetSelection (basename);
	Pkg::ActivateSelections ();
	Pkg::PkgSolve();
    }

    /**
     * Proposal()
     * Make a proposal for package selection
     * @return map for the API proposal;
     *
     */

    global define void Proposal( boolean force_reset, boolean reinit )
    ``{
	import "Language";

	map ret = $[];

	UI::OpenDialog(`opt(`decorated ),`Label(_("Evaluating package selection...")));

	y2milestone ("Packages::Proposal: force_reset %1, reinit %2, lang '%3'", force_reset, reinit, Language::language);
	Pkg::SetLocale (Language::language);

	if ( force_reset )
	{
	    Kernel::ProbeKernel();
	    Packages::Init( true );	// reintialize AND reset package selection too
	}
	else if ( reinit )
	{
	    Packages::Init( false ); 	// reinitialize but keep former selection (if possible)
	}
	else
	{
	    Packages::Init( !init_called ); // reset completely only if necessary
	}

	UI::CloseDialog();

	// start with base selections

	y2milestone ("checking selected selection");

	list base_selections = Pkg::GetSelections (`selected, "base");
	string selected_base_selection = base_selections[0]:"";

	list selected_addon_selections = Pkg::GetSelections (`selected, "");
	y2milestone ("selected base is %1, addon is %2", selected_base_selection, selected_addon_selections);

	// re-set space calculation
	SpaceCalculation::GetPartitionInfo();

	// remember if we must re-do the proposal.
	// If not, there's no need to activate any selections !
	boolean redo_proposal = (choosen_base_selection == "") &&  !Mode::autoinst;

	if (redo_proposal
	    || !SpaceCalculation::CheckDiskSize() )
	{
	    // make a new proposal or change a proposal,
	    // if it does not fit on the disk anymore

	    if ( ! redo_proposal )
	    {
		ret = add( ret, "warning", _("Disk space exhausted - changing software selection") );
		ret = add( ret, "warning_level", `error );
		redo_proposal = true; // 
	    }


	    // get all base selections
	    // and sort them by reverse order
	    list available_base_selections = sort (`x, `y, Pkg::GetSelections (`available, "base"),
		``{
			map xmap = Pkg::SelectionData(x);
			map ymap = Pkg::SelectionData(y);
			return (xmap["order"]:"" >= ymap["order"]:"");
		}
	    );
	    y2milestone ("available_base_selections %1", available_base_selections);

	    boolean fit = false;
	    integer counter = 0;

	    while (!fit
		   && counter < size(available_base_selections) )
	    {
		selected_base_selection = available_base_selections[counter]:"";

		y2milestone ("Checking space for '%1'", selected_base_selection);
		SetBaseSelection (selected_base_selection);

		if ( !SpaceCalculation::CheckDiskSize() )
		{
		    // does not fit --> trying next
		    counter = counter +1;
		}
		else
		{
		    fit = true;
		}
	    }
	    if (!fit)
	    {
		y2warning ("No selection fits");
		Pkg::ClearSelection (selected_base_selection);
		return $[ "warning" : _( "Not enough disk space even for a minimal installation!" ),
			  "warning_level" : `blocker ];

	    }

	    y2warning ("Get recommendations for %1", selected_base_selection);

	    map base_data = Pkg::SelectionData (selected_base_selection);
	    if (base_data == nil)
	    {
		base_data = $[];
	    }
	    selected_addon_selections = base_data["recommends"]:[];
	}
	else if (Product::certify_cd)
	{
	    // certification is only possible with this selection. If it doen't
	    // fit to disk, then the disk is too small so no further logic
	    // required.
	    y2milestone("force certify selection");
	    selected_base_selection = "certify";
	    Pkg::SetSelection (selected_base_selection);
	}

	choosen_base_selection = selected_base_selection;

	// generate user readable output for proposal
	list output = [];

	map base_data = Pkg::SelectionData (selected_base_selection);
	if (base_data == nil)
	{
	    y2error ("No data for selection '%1'", selected_base);
	    base_data = $[];
	}
	y2milestone ("Base %1: %2", selected_base_selection, base_data);
	output = add (output, base_data["summary"]:"?");

	// add on
	foreach(`sel, selected_addon_selections,
	``{
	    map addon_data = Pkg::SelectionData (sel);
	    if ((addon_data != nil)				// skip unknown selections
		&& (addon_data["category"]:"" != "base")
		&& addon_data["visible"]:false)
	    {
		output = add ( output, "+  " + addon_data["summary"]:sel);
	    }
	});

	y2milestone ("proposal %1", output);

	// check only disk space, if the selected software selection
	// fits on the disk
	if ( !SpaceCalculation::CheckDiskSize() )
	{
//	    ret = $[ "warning" : _("Software selection does not fit on disk"),
//		   warning_level : `blocker ];
	    y2warning ("Software selection does not fit on disk");
	}

	ret = add ( ret, "raw_proposal", output );

	// we just proposed a new base selection, activate it !

	if (redo_proposal)
	{
	    y2milestone ("activating selections");
	    boolean act_sel = Pkg::ActivateSelections ();

	    // add additional (internal) packages, like kernel etc.
	    Pkg::DoProvide (Packages::ComputeSystemPackageList());
	    Pkg::PkgSolve();

	    y2milestone ("activating: %1, returning %2", act_sel, ret);
	}

	return ret;
    }


    /**
     * Init()
     * Initialize package module and package agent
     * @return integer: 0 == ok, 1 == retry, -1 == error
     *
     */

    global define void Init( boolean forceInit )
    ``{
	if (init_called)
	{
	    y2warning ("Packages::Init() already called");
	    return 0;
	}
	//
	// Initialize package manager
	//
	y2milestone ("Packages::Init(%1)", forceInit);
	// usual mountpoint for the source medium
	string base_url = "";

	if ( Mode::test )
	{
	    // Fake values for testing purposes
	    base_url = "dir:///dist/next-i386";
	}
	else
	{
	    import "InstURL";
	    base_url = InstURL::installInf2Url ("");
	}

	y2milestone ("Initialize Package Manager: %1", base_url);

	if (Mode::initial)
	{
	    Pkg::SourceStartCache (true);			// dummy, so further calls to Pkg::Pkg* don't restart it

	    Pkg::SourceSetRamCache (false);
	    integer initial_source = Pkg::SourceCreate (base_url);
	    if (initial_source == nil)
	    {
		y2error ("No source on '%1'", base_url);
		return;
	    }

	    // check for yast/order

	    string orderfile = Pkg::SourceProvideFile (initial_source, 1, "yast/order");
	    if (orderfile != nil)			// splitted source installation
	    {
		y2milestone ("orderfile '%1'", orderfile);
		string orderdata = WFM::Read(.local.string, [orderfile, ""]);		// read install/order
		if (orderdata == "")
		{
		    y2error ("Can't read '%1'", orderfile);
		    return;
		}

		string instorderfile = Pkg::SourceProvideFile (initial_source, 1, "yast/instorder");
		map instordermap = $[];	// instorder : product dir, ...
		if (instorderfile != nil)
		{
		    y2milestone ("instorder file '%1'", instorderfile);
		    string instorderdata = WFM::Read (.local.string, [instorderfile, ""]);

		    integer instorder = 1;
		    list instorderlist = splitstring (instorderdata, "\n");
		    foreach (`instorderline, instorderlist,
		    ``{
			if ((instorderline != "")
			    && (substring (instorderline, 0, 1) != "#"))
			{
			    instordermap[instorder] = instorderline;
			    instorder = instorder + 1;
			}
		    });
		}
		y2milestone ("instordermap %1", instordermap);

		// setup slidedir

		map productmap = Pkg::SourceProductData (initial_source);
		string datadir = productmap["datadir"]:"suse";
		slidedir = metadir + "/" + datadir + "/setup/slide";

		// setup meta data dir

		list orderlist = splitstring (orderdata, "\n");

		WFM::Execute (.local.mkdir, metadir);
		foreach (`orderline, orderlist,				// copy all data to ramdisk
		``{
		    if ((orderline != "")
			&& (substring (orderline, 0, 1) != "#"))
		    {
			list sourcelist = splitstring (orderline, " \t\n");
			string orderdir = sourcelist[0]:"";
			string pkgdir = sourcelist[1]:"/";

			string localdir = "/yast-install/"+orderdir;
			WFM::Execute (.local.mkdir, localdir);

			y2milestone ("Filling %1", localdir);

			// media.1

			datadir = Pkg::SourceProvideDir (initial_source, 1, orderdir+"/media.1");
			WFM::Execute (.local.mkdir, localdir+"/media.1");
			WFM::Execute (.local.bash, "/bin/cp " + datadir + "/* " + localdir+"/media.1");

			// content

			datadir = Pkg::SourceProvideFile (initial_source, 1, orderdir+"/content");
			WFM::Execute (.local.bash, "/bin/cp " + datadir + " " + localdir + "/content");

			// DESCRDIR

			WFM::Execute (.local.bash, "/bin/grep DESCRDIR " + localdir + "/content > /tmp/descrdir");
			string descrline = WFM::Read (.local.string, "/tmp/descrdir");
			list descrsplit = splitstring (descrline, " \t\n");
			string descrdir = descrsplit[1]:"";
			if (size (descrdir) > 0)
			{
			    y2milestone ("descrdir %1", descrdir);
			    WFM::Execute (.local.mkdir, localdir+"/"+descrdir);
			    datadir = Pkg::SourceProvideDir (initial_source, 1, orderdir+"/"+descrdir);
			    if (datadir != nil)
			    {
				WFM::Execute (.local.bash, "/bin/cp " + datadir + "/* " +localdir+"/"+descrdir);
			    }
			}

			// slide show

			if (size (descrdir) > 5)
			{
			    string tmp = substring (descrdir, 0, size (descrdir) - 5) + "slide";
			    WFM::Execute (.local.mkdir, localdir+"/"+tmp);
			    // FIXME: SourceProvideDir can't handle dirs with subdirs
			    // datadir = Pkg::SourceProvideDir (initial_source, 1, orderdir+"/"+tmp);
			    datadir = "/var/adm/YaST/InstSrcManager/IS_CACHE_0x00000001/MEDIA" + orderdir+"/"+tmp;
			    y2milestone ("tmp datadir %1 %2", tmp, datadir);
			    if (datadir != nil)
			    {
				y2milestone ("copy slide show %1 %2", datadir, slidedir);
				WFM::Execute (.local.bash, "/bin/cp -r " + datadir + "/* " + slidedir);
			    }
			}
		    }
		});

		// ok, all data copied from the install media, release and delete it

		Pkg::SourceDelete (initial_source);
		Pkg::SourceSetRamCache (true);

		metadir_used = true;

		// now restart the whole stuff from the metadata in the ramdisk and create
		// the *real* sources

		foreach (`orderline, orderlist,
		``{
		    if ((orderline != "")
			&& (substring (orderline, 0, 1) != "#"))
		    {
			list sourcelist = splitstring (orderline, " \t\n");
			string orderdir = sourcelist[0]:"";
			string pkgdir = sourcelist[1]:"";

			string meta_url = "dir:///yast-install/" + orderdir;
			integer order_source = Pkg::SourceCreate (meta_url);		// create and enable source
			y2milestone ("order_source %1, temp_url '%2'", order_source, meta_url);
			if (order_source != nil)
			{
			    theSources = add (theSources, order_source);
			    theSourceDirectories = add (theSourceDirectories, orderdir);

			    if (find (pkgdir, ":") > 0)					// if second column of yast/order contains ":"
			    {
				base_url = pkgdir;					// then take as URL
			    }
			    else
			    {
				base_url = InstURL::installInf2Url (pkgdir);		// else take as sub-dir
			    }
			    Pkg::SourceChangeUrl (order_source, base_url);		// rewrite URL for *real* source

			    // now find this source in the instorder map and fill
			    // the global 'theSourceOrder'

			    foreach (`key, `value, instordermap,
			    ``{
				if (value == orderdir)
				{
				    theSourceOrder[key] = order_source;
				}
			    });
			}
		    }
		});
		y2milestone ("theSourceOrder %1", theSourceOrder);
		Pkg::SourceInstallOrder (theSourceOrder);
	    }
	    else		// normal media installation
	    {
		y2milestone ("No order file, doing single source installation");
		theSources = [ initial_source ];
	    }
	}
	else	// cont or normal mode
	{
	    theSources = Pkg::SourceStartCache (true);
	    if (theSources == nil || size (theSources) <= 0)
	    {
		y2error ("Pkg::SourceStartCache failed");
		theSources = [];
	    }
	    else if (!url_rewritten				// rewrite URL if cd/dvd since ide-scsi might have changed it
		     && Mode::cont
		     && ((substring (base_url, 0, 2) == "cd")
			|| (substring (base_url, 0, 3) == "dvd")))
	    {
		foreach (`source, theSources,
		``{
		    map data = Pkg::SourceGeneralData (source);		// get source data
		    string url = data["url"]:"";
		    if ((substring (url, 0, 2) == "cd")			// source comes from cd/dvd
			|| (substring (url, 0, 3) == "dvd"))
		    {
			y2milestone ("rewrite url: '%1'->'%2'", url, base_url);
			Pkg::SourceChangeUrl (source, base_url);
		    }
		});
	    }
	}
	y2milestone ("theSources %1", theSources);
	y2milestone ("theSourceDirectories %1", theSourceDirectories);
	if (size (theSources) >= 0)
	{
	    init_called = true;
	}
	else
	{
	    import "PackageCallbacks";

	    // This text should be translated after 8.0.
	    // Currently this error should only occured while developping.
	    string errortext = _("Error while initializing package descriptions.
Check the log file /var/log/YaST2/y2log for more details.") + "\n" + Pkg::Error();
	    string result = PackageCallbacks::MediaChange (errortext, base_url, "", 0, 1);

	    if (result == "")		// retry
		return 1;
	    if (result == "I")		// ignore
		return 0;
	    if (result == "C")		// cancel
		return -1;
	    if (result == "S")		// skip
		return 1;
	    if (result == "E")		// eject
		return 1;

	}

	return;
    }

    /**
     * Constructor()
     * Load saved package lists
     * @return void;
     *
     */

    global define void Packages() ``{
	return;
    }

/* EOF */
}
