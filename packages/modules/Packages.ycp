/**
 * File:	Packages.ycp
 * Package:	Package selections
 * Authors:	Anas Nashif <nashif@suse.de>
 *
 * $Id$
 */

{
    module "Packages";

    textdomain "packager";

    import "Arch";
    import "Bootloader";
    import "Installation";
    import "InstURL";
    import "Kernel";
    import "Mode";
    import "Language";
    import "ProductFeatures";
    import "Report";
    import "SlideShow";
    import "SpaceCalculation";

    global boolean url_rewritten = false;	// url rewritten in continue mode ? (see Init())
    global boolean install_sources = false;	// Installing source packages ?
    global integer timestamp = 0;		// last time of getting the target map

    global string metadir = "/yast-install";
    global boolean metadir_used = false;	// true if meta data and inst-sys is in ramdisk

    global list<integer> theSources = [];		// id codes of sources in priority order
    global list<string> theSourceDirectories = [];	// product directories on sources
    global map<integer,integer> theSourceOrder = $[];	// installation order

    // Local variables

    boolean init_called = false;

    string choosen_base_selection = "";


    /*-----------------------------------------------------------------------
     * LOCALE FUNCTIONS
     *-----------------------------------------------------------------------*/

    /**
     * Compute architecture packages
     * @return list(string)
     */
    define list<string> architecturePackages ()
    ``{
	list<string> packages = [];

	// check for PCMCIA and add package
	if (Arch::has_pcmcia)
	{
	    packages = add (packages, "pcmcia");
	    packages = add (packages, "scpm");
	    packages = add (packages, "irda");
	}

	// check for aboot or milo on alpha and add package
	if (Arch::alpha)
	{
	    string loader_type = Bootloader::getLoaderType ();

	    if (loader_type == "aboot")
	    {
		packages = add (packages, "aboot");
	    }
	    else if (loader_type == "milo")
	    {
		packages = add (packages, "milo");
	    }
	}

	// remove unneeded / add needed packages for ppc
	if (Arch::ppc)
	{
	    if (Arch::board_iseries)
	    {
		packages = add (packages, "ibmsis");
		packages = add (packages, "scsi");
	    }

	    if (Arch::board_mac)
	    {
		packages = add (packages, "mouseemu");
	    }

	    if (Arch::board_mac_new
		|| Arch::board_mac_old)
	    {
		string pmac_board = "";
		list<map> pmac_compatible = (list<map>) SCR::Read(.probe.cpu);
		foreach (map pmac_compatible_tmp, pmac_compatible,
		``{
		    pmac_board = pmac_compatible_tmp["system"]:"";
		});

		// install pmud on PowerBooks and iMacs
		if (issubstring (pmac_board, "PowerBook")
		    || issubstring (pmac_board, "PowerMac2,1")
		    || issubstring (pmac_board, "PowerMac2,2")
		    || issubstring (pmac_board, "PowerMac4,1")
		    || issubstring (pmac_board, "iMac,1"))
		{
		    packages = add (packages, "pmud");
		}

		// mol is fun, and needs root access to kmem
		packages = add (packages, "mol");
		packages = add (packages, "sudo");
	    }

	    if (Arch::ppc64 && Arch::board_chrp)
	    {
		packages = add (packages, "ppc64-utils");
	    }
	}

	if (Arch::ia64)
	{
	    // install fpswa if the firmware has an older version
	    if (SCR::Execute(.target.bash, "/sbin/fpswa_check_version") != 0)
	    {
		packages = add (packages, "fpswa");
	    }
	}

	// add numactl on x86_64 with SMP
	if (Arch::has_smp && Arch::x86_64)
	{
	    packages = add (packages, "numactl");
	}

	return packages;
    }


    /**
     * graphicPackages ()
     * Compute graphic (x11) packages
     * @return list(string)	list of rpm packages needed
     */
    define list<string> graphicPackages ()
    ``{
	list<string> packages = [];

	// don't setup graphics if running via serial console
	if (!Mode::serial_console)
	{
	    import "Display";
	    packages = (list<string>) Display::pacs_to_install;
	}

	y2milestone ("X11 Packages to install: %1", packages);
	return packages;
    }


    /**
     * Compute special packages
     * @return list(string)
     */
    define list<string> modePackages ()
    ``{
	list<string> packages = [];

	if (Mode::vnc)
	{
	    packages = add (packages, "tightvnc");
	    packages = add (packages, "yast2-qt");
	    packages = add (packages, "XFree86");
	}

	if (Mode::braille)
	{
	    packages = add (packages, "sbl");
	}

	return packages;
    }


    /**
     * Compute special java packages
     * @return list(string)
     */
    define list<string> javaPackages ()
    ``{
	if (!Arch::alpha)
	    return [];

	list<string> packages = [];

	list cpus = (list) SCR::Read (.probe.cpu);
	string model = cpus[0, "model"]:"EV4";
	string cputype = substring (model, 2, 1);

	if ((cputype == "6") || (cputype == "7") || (cputype == "8"))
	{
	    packages = ["cpml_ev6"];
	}
	else
	{
	    packages = ["cpml_ev5"];
	}
	return packages;
    }


    /*-----------------------------------------------------------------------
     * GLOBAL FUNCTIONS
     *-----------------------------------------------------------------------*/

    /**
     * Build and return list of packages which depends on the
     * the current target system and the preselected packages
     * (architecture, X11....)
     * @return list<string> packages
     */
    global define list<string> ComputeSystemPackageList ()
    ``{
	list<string> install_list =  architecturePackages ();

	install_list = (list<string>) union (install_list, modePackages ());

	// Kernel is added in autoinstPackages () if autoinst is enabled
	if (!Mode::update ||  !Mode::autoinst)
	{
	    string the_kernel = Kernel::kernel_packages[0]:"";
	    y2milestone ("Selecting '%s' as kernel package", the_kernel);
	    while (the_kernel != ""
		   && !Pkg::IsAvailable (the_kernel))
	    {
		the_kernel = Kernel::fallbacks[the_kernel]:"";
		y2milestone ("Not available, falling back to '%s'", the_kernel);
	    }

	    if (the_kernel != "")
	    {
		install_list = (list<string>) union (install_list,
						     Kernel::kernel_packages);
	    }
	    else
	    {
		y2warning ("%1 not available, using kernel-default",
						Kernel::kernel_packages);
		install_list = add (install_list, "kernel-default");
	    }
	}

	if (Pkg::IsSelected("XFree86")
	    || Mode::live_eval)
	{
	    install_list = (list<string>) union (install_list, graphicPackages ());
	}

	if (Pkg::IsSelected("java"))
	{
	    install_list = (list<string>) union (install_list, javaPackages ());
	}

	// and the most flexible enhancement for other products
	if (ProductFeatures::packages_transmogrify != "")
	{
	    install_list = (list<string>)
		WFM::CallFunction (ProductFeatures::packages_transmogrify,
				   [ install_list ]);
	}

	install_list = toset (install_list);
	y2milestone ("auto-adding packages: %1", install_list);
	return install_list;
    }

    /**
     * SetBaseSelection (string base name)
     * @param string base selection name
     * @return boolean
     */
    global define boolean SetBaseSelection (string basename)
    ``{
	list base_selections = Pkg::GetSelections (`selected, "base");
	string current_base_selection = base_selections[0]:"";
	if (current_base_selection != "")
	{
	    Pkg::ClearSelection (current_base_selection);
	}
	Pkg::SetSelection (basename);
	Pkg::ActivateSelections ();
	Pkg::PkgSolve(false);
    }

    /**
     * Init()
     * Initialize package module and package agent
     * @return integer: 0 == ok, 1 == retry, -1 == error
     *
     */

    global define void Init( boolean forceInit )
    ``{
	if (init_called)
	{
	    y2warning ("Packages::Init() already called");
	    return;
	}

	//
	// Initialize package manager
	//
	y2milestone ("Packages::Init(%1)", forceInit);
	// usual mountpoint for the source medium
	string base_url = "";

	if ( Mode::test )
	{
	    // Fake values for testing purposes
	    base_url = "dir:///dist/next-i386";
	}
	else
	{
	    base_url = InstURL::installInf2Url ("");
	}

	// check if url contains "@" -> might be username/password, hide from logging

	string log_url = base_url;
	if (findfirstof (log_url, "@") != nil)
	{
	    // convert "xxx:://user:pass@server/blah" to "xxx:/...@server/blah"
	    log_url = substring (log_url, 0, 5) + "..." + substring (log_url, findfirstof (log_url, "@"));
	}

	y2milestone ("Initialize Package Manager: %1", log_url);

	// Set languages for packagemanager. Always set the UI language. Set
	// language for additional packages only in Mode::initial.

	Pkg::SetLocale (Language::language);

	if (Mode::initial)
	    Pkg::SetAdditionalLocales ([Language::language]);


	if (Mode::initial)
	{
	    Pkg::SourceStartCache (true);			// dummy, so further calls to Pkg::Pkg* don't restart it

	    Pkg::SourceSetRamCache (false);
	    integer initial_source = Pkg::SourceCreate (base_url, "");
	    if (initial_source == nil)
	    {
		y2error ("No source on '%1'", log_url);
		return;
	    }

	    // check for yast/order

	    string orderfile = Pkg::SourceProvideFile (initial_source, 1, "yast/order");
	    if (orderfile != nil)			// splitted source installation
	    {
		y2milestone ("orderfile '%1'", orderfile);
		string orderdata = (string) WFM::Read(.local.string, [orderfile, ""]);		// read install/order
		if (orderdata == "")
		{
		    y2error ("Can't read '%1'", orderfile);
		    return;
		}

		string instorderfile = Pkg::SourceProvideFile (initial_source, 1, "yast/instorder");
		map<integer, string > instordermap = $[];	// instorder : product dir, ...
		if (instorderfile != nil)
		{
		    y2milestone ("instorder file '%1'", instorderfile);
		    string instorderdata = (string) WFM::Read (.local.string, [instorderfile, ""]);

		    integer instorder = 1;
		    list<string> instorderlist = splitstring (instorderdata, "\n");
		    foreach (string instorderline, instorderlist,
		    ``{
			if ((instorderline != "")
			    && (substring (instorderline, 0, 1) != "#"))
			{
			    instordermap[instorder] = instorderline;
			    instorder = instorder + 1;
			}
		    });
		}
		y2milestone ("instordermap %1", instordermap);

		// setup slidedir

		map productmap = Pkg::SourceProductData (initial_source);
		string datadir = productmap["datadir"]:"suse";
		string slidedir = metadir + "/" + datadir + "/setup/slide";
		SlideShow::setSlideDir (slidedir);

		// setup meta data dir

		list<string> orderlist = splitstring (orderdata, "\n");

		WFM::Execute (.local.mkdir, metadir);
		foreach (string orderline, orderlist,				// copy all data to ramdisk
		``{
		    if ((orderline != "")
			&& (substring (orderline, 0, 1) != "#"))
		    {
			list<string> sourcelist = splitstring (orderline, " \t\n");
			string orderdir = sourcelist[0]:"";
			string pkgdir = sourcelist[1]:"/";

			string localdir = "/yast-install/"+orderdir;
			WFM::Execute (.local.mkdir, localdir);

			y2milestone ("Filling %1", localdir);

			// media.1

			datadir = Pkg::SourceProvideDir (initial_source, 1, orderdir+"/media.1");
			if (datadir != nil)
			{
			    WFM::Execute (.local.mkdir, localdir+"/media.1");
			    WFM::Execute (.local.bash, "/bin/cp " + datadir + "/* " + localdir+"/media.1");
			}
			else
			{
			    y2warning ("media doesn't provide %1", orderdir + "/media.1");
			}

			// content

			datadir = Pkg::SourceProvideFile (initial_source, 1, orderdir+"/content");
			WFM::Execute (.local.bash, "/bin/cp " + datadir + " " + localdir + "/content");

			// DESCRDIR

			WFM::Execute (.local.bash, "/bin/grep DESCRDIR " + localdir + "/content > /tmp/descrdir");
			string descrline = (string) WFM::Read (.local.string, "/tmp/descrdir");
			list<string> descrsplit = splitstring (descrline, " \t\n");
			string descrdir = descrsplit[1]:"";
			if (size (descrdir) > 0)
			{
			    y2milestone ("descrdir %1", descrdir);
			    WFM::Execute (.local.mkdir, localdir+"/"+descrdir);
			    datadir = Pkg::SourceProvideDir (initial_source, 1, orderdir+"/"+descrdir);
			    if (datadir != nil)
			    {
				WFM::Execute (.local.bash, "/bin/cp " + datadir + "/* " +localdir+"/"+descrdir);
			    }
			}

			// slide show

			if (size (descrdir) > 5)
			{
			    string tmp = substring (descrdir, 0, size (descrdir) - 5) + "slide";
			    WFM::Execute (.local.mkdir, localdir+"/"+tmp);
			    // FIXME: SourceProvideDir can't handle dirs with subdirs
			    // datadir = Pkg::SourceProvideDir (initial_source, 1, orderdir+"/"+tmp);
			    datadir = "/var/adm/YaST/InstSrcManager/IS_CACHE_0x00000001/MEDIA" + orderdir+"/"+tmp;
			    y2milestone ("tmp datadir %1 %2", tmp, datadir);
			    if (datadir != nil)
			    {
				y2milestone ("copy slide show %1 %2", datadir, slidedir);
				WFM::Execute (.local.bash, "/bin/cp -r " + datadir + "/* " + slidedir);
			    }
			}
		    }
		});

		// ok, all data copied from the install media, release and delete it

		Pkg::SourceDelete (initial_source);
		Pkg::SourceSetRamCache (true);

		metadir_used = true;

		// now restart the whole stuff from the metadata in the ramdisk and create
		// the *real* sources

		foreach (string orderline, orderlist,
		``{
		    if ((orderline != "")
			&& (substring (orderline, 0, 1) != "#"))
		    {
			list<string> sourcelist = splitstring (orderline, " \t\n");
			string orderdir = sourcelist[0]:"";
			string pkgdir = sourcelist[1]:"";

			string meta_url = "dir:///yast-install/" + orderdir;
			integer order_source = Pkg::SourceCreate (meta_url, "");		// create and enable source
			y2milestone ("order_source %1, temp_url '%2'", order_source, meta_url);
			if (order_source != nil)
			{
			    theSources = add (theSources, order_source);
			    theSourceDirectories = add (theSourceDirectories, orderdir);

			    if (find (pkgdir, ":") > 0)					// if second column of yast/order contains ":"
			    {
				base_url = pkgdir;					// then take as URL
			    }
			    else
			    {
				base_url = InstURL::installInf2Url (pkgdir);		// else take as sub-dir
			    }
			    Pkg::SourceChangeUrl (order_source, base_url);		// rewrite URL for *real* source

			    // now find this source in the instorder map and fill
			    // the global 'theSourceOrder'

			    foreach (integer key, string value, instordermap,
			    ``{
				if (value == orderdir)
				{
				    theSourceOrder[key] = order_source;
				}
			    });
			}
		    }
		});
		y2milestone ("theSourceOrder %1", theSourceOrder);
		Pkg::SourceInstallOrder (theSourceOrder);
	    }
	    else		// normal media installation
	    {
		y2milestone ("No order file, doing single source installation");
		theSources = [ initial_source ];
	    }

	    if (ProductFeatures::base_selection_choice == `fixed)
	    {
		Pkg::SetSelection (ProductFeatures::fixed_base_selection);
	    }
	}
	else	// cont or normal mode
	{
	    theSources = Pkg::SourceStartCache (true);
	    if (theSources == nil || size (theSources) <= 0)
	    {
		y2error ("Pkg::SourceStartCache failed");
		theSources = [];
	    }
	    else if (!url_rewritten				// rewrite URL if cd/dvd since ide-scsi might have changed it
		     && Mode::cont
		     && ((substring (base_url, 0, 2) == "cd")
			|| (substring (base_url, 0, 3) == "dvd")))
	    {
		foreach (integer source, theSources,
		``{
		    map data = Pkg::SourceGeneralData (source);		// get source data
		    string url = data["url"]:"";
		    if ((substring (url, 0, 2) == "cd")			// source comes from cd/dvd
			|| (substring (url, 0, 3) == "dvd"))
		    {
			y2milestone ("rewrite url: '%1'->'%2'", url, log_url);
			Pkg::SourceChangeUrl (source, base_url);
		    }
		});
	    }
	}

	y2milestone ("theSources %1", theSources);
	y2milestone ("theSourceDirectories %1", theSourceDirectories);
	if (size (theSources) >= 0)
	{
	    init_called = true;
	}
	else
	{
	    import "PackageCallbacks";
	    import "SlideShowCallbacks";

	    // an error message
	    string errortext = _("Error while initializing package descriptions.
Check the log file /var/log/YaST2/y2log for more details.") + "\n" + Pkg::LastError();
	    string result = PackageCallbacks::MediaChange (errortext, base_url, "", 0, 1, false);
	}
    }

    /**
     * Proposal()
     * Make a proposal for package selection
     * @param boolean force reset
     * @param boolean re initialize
     * @return map for the API proposal;
     */
    global define map Proposal( boolean force_reset, boolean reinit )
    ``{
	import "Language";

	map ret = $[];

	// popup label
	UI::OpenDialog(`opt(`decorated ),`Label(_("Evaluating package selection...")));

	y2milestone ("Packages::Proposal: force_reset %1, reinit %2, lang '%3'",
		     force_reset, reinit, Language::language);

	if ( force_reset )
	{
	    Kernel::ProbeKernel();
	    Pkg::PkgReset ();
	    Packages::Init( true );	// reintialize AND reset package selection too
	}
	else if ( reinit )
	{
	    Packages::Init( false );	// reinitialize but keep former selection (if possible)
	}
	else
	{
	    Packages::Init( !init_called ); // reset completely only if necessary
	}

	UI::CloseDialog();

	// start with base selections

	y2milestone ("checking selected selection");

	list base_selections = Pkg::GetSelections (`selected, "base");
	string selected_base_selection = base_selections[0]:"";

	list<string> selected_addon_selections = Pkg::GetSelections (`selected, "");
	y2milestone ("selected base is %1, addon is %2", selected_base_selection, selected_addon_selections);

	// when coming from the update branch to the install branch, we might already have
	// a choosen_base_selection but no selection in the package manager
	// this will trigger the redo_proposal below

	if (selected_base_selection == "")
	    choosen_base_selection = "";

	// re-set space calculation
	SpaceCalculation::GetPartitionInfo();

	// remember if we must re-do the proposal.
	// If not, there's no need to activate any selections !
	boolean redo_proposal = (choosen_base_selection == "") &&  !Mode::autoinst;

	if (ProductFeatures::base_selection_choice == `fixed)
	{
	    if (!SpaceCalculation::CheckDiskSize())
	    {
		ret = add( ret, "warning", _("Disk Space Exhausted") );
		ret = add( ret, "warning_level", `blocker );
	    }
	}
	else if (ProductFeatures::base_selection_choice == `auto)
	{
	    if (redo_proposal || !SpaceCalculation::CheckDiskSize())
	    {
		// make a new proposal or change a proposal,
		// if it does not fit on the disk anymore

		if ( ! redo_proposal )
		{
		    // the selected set of software packages does not fit on the harddisk
		    // error message
		    ret = add( ret, "warning", _("Disk space exhausted -- changing software selection") );
		    ret = add( ret, "warning_level", `error );
		    redo_proposal = true; //
		}

		// get all base selections, and sort them by reverse order (highest ordered first)
		list available_base_selections = sort (string x, string y, Pkg::GetSelections (`available, "base"),
						       ``{
							   map xmap = Pkg::SelectionData(x);
							   map ymap = Pkg::SelectionData(y);
							   return (xmap["order"]:"" > ymap["order"]:"");
						       }
						       );
		y2milestone ("available_base_selections %1", available_base_selections);

		if (size (available_base_selections) == 0)
		{
		    y2error ("No base selections available");
		    // Can't find any software data, probably a installation media error
		    // error message
		    return $[ "warning" : _("Cannot read package data from installation media. Media error?"),
			      "warning_level" : `blocker ];
		}

		boolean fit = false;
		integer counter = 0;

		while (!fit
		       && counter < size(available_base_selections) )
		{
		    selected_base_selection = available_base_selections[counter]:"";

		    y2milestone ("Checking space for '%1'", selected_base_selection);
		    SetBaseSelection (selected_base_selection);

		    if ( !SpaceCalculation::CheckDiskSize() )
		    {
			// does not fit --> trying next
			counter = counter +1;
		    }
		    else
		    {
			fit = true;
		    }
		}
		if (!fit)
		{
		    y2warning ("No selection fits");
		    Pkg::ClearSelection (selected_base_selection);
		    // can't find a set of software packages which fits on the harddisk
		    // error message
		    return $[ "warning" : _("Not enough disk space even for a minimal installation!"),
			      "warning_level" : `blocker ];
		}

		y2warning ("Get recommendations for %1", selected_base_selection);

		map base_data = Pkg::SelectionData (selected_base_selection);
		if (base_data == nil)
		{
		    base_data = $[];
		}
		selected_addon_selections = base_data["recommends"]:[];
	    }
	}
	else
	{
	    y2error ("unknown value %1 for ProductFeatures::base_selection_choice",
		     ProductFeatures::base_selection_choice);
	}

	choosen_base_selection = selected_base_selection;

	// generate user readable output for proposal
	list output = [];

	map base_data = Pkg::SelectionData (selected_base_selection);
	if (base_data == nil)
	{
	    y2error ("No data for selection '%1'", selected_base_selection);
	    base_data = $[];
	}
	y2milestone ("Base %1: %2", selected_base_selection, base_data);
	output = add (output, base_data["summary"]:"?");

	// add on
	foreach(string sel, selected_addon_selections,
	``{
	    map addon_data = Pkg::SelectionData (sel);
	    if ((addon_data != nil)				// skip unknown selections
		&& (addon_data["category"]:"" != "base")
		&& addon_data["visible"]:false)
	    {
		output = add ( output, "+  " + addon_data["summary"]:sel);
	    }
	});

	y2milestone ("proposal %1", output);

	// check only disk space, if the selected software selection
	// fits on the disk
	if ( !SpaceCalculation::CheckDiskSize() )
	{
//	    ret = $[ "warning" : _("Software selection does not fit on disk"),
//		   warning_level : `blocker ];
	    y2warning ("Software selection does not fit on disk");
	}

	ret = add ( ret, "raw_proposal", output );

	// we just proposed a new base selection, activate it !

	if (redo_proposal)
	{
	    y2milestone ("activating selections");
	    boolean act_sel = Pkg::ActivateSelections ();

	    // add additional (internal) packages, like kernel etc.
	    map <string, any> res = Pkg::DoProvide (Packages::ComputeSystemPackageList());
	    if (size (res) > 0)
	    {
		foreach (string s, any a, res, ``{
		    y2warning ("Pkg::DoProvide failed for %1: %2", s, a);
		});
	    }

	    Pkg::PkgSolve (false);

	    y2milestone ("activating: %1, returning %2", act_sel, ret);
	}

	return ret;
    }

/* EOF */
}
