/**
 * Module: 		PackageInstallation.ycp
 *
 * Authors:		Gabriele Strattner <gs@suse.de>
 *
 * Purpose:
 *
 *
 * $Id$
 */

{

    module "PackageInstallation";

    import "Arch";
    import "AutoInstall";
    import "Report";
    import "Mode";
    import "Installation";
    import "Version";
    import "SpaceCalculation";
    import "InstMedia";
    import "MediaUI";
    import "Packages";
    import "SlideShow";

    import "Wizard";

    include "showlog_defines.ycp";
    include "ui/common_popups.ycp";

    include "packages/installationCallback.ycp";

    textdomain "packager";


    boolean shutup = false;			// show the disk space warning popup only once


    /**
     * 	global variables
     */
    global list error_packages = [];		// list of packages which are not installed (or deleted) correctly


    /**
     * Constructor()
     * @return void;
     *
     */
    global define void PackageInstallation() ``{
	return;
    }


    /**
     *	Return: `error		-> global list 'error_packages' contains packages which are not deleted
     *          `ok		-> everything ok
     *		`cancel		-> user wants to stop the installation
     *		nil		-> invalid argument
    **/
    global define symbol DeletePackages( list delete_list ) ``{

	symbol ret = `ok;

	// Reset variables
	shutup = false;
	error_packages = [];

	if ( delete_list == [] || delete_list == nil )
	    return nil;

	SlideShow::UpdateAllCdProgress( true );		// true: deleting

	if ( !Mode::test )
	{
	    ret = WFM::CallModule("packager", ["CyclicDeletePkgCallback",
					  `remove(InstMedia::GetInstPath(), delete_list),
					  `root(Installation::destdir),
					  `number(0)]); // number of packages already deleted=0
	}
	else
	{
	    ret = FakePackager( delete_list,
				InstMedia::GetInstPath(),
				true );			// deleting packages
	}

	y2debug( "DeletePackages: WFM::CallModule(packager, ...) returns: %1", ret );

	SlideShow::UpdateAllCdProgress( false );	// false: no longer deleting

	return ret;
    };

    /**
     *	Return: < 0		-> negative number of installed packages
     *				   but some failed, global list 'error_packages' contains packages which are not installed correctly
     *          > 0		-> everything ok, number of installed packages
     *		0		-> user wants to stop the installation
     **/
    global define integer InstallPackages(integer media_number,
					  integer packages_installed)
    ``{
	integer ret = 0;

	// Reset variables
	shutup = false;
	error_packages = [];

	if ( Mode::test )
	{
	    FakePackager( [],
			InstMedia::GetInstPath(),
			false );		// not deleting packages
	    return ret;
	}

	list other_media_packages = [];		// packages on other media, pairs of [cdnr, "pack"]
	integer other_media_pos = 0;
	integer other_media_nr = 0;

	if (media_number == 1)
	{
	    // packager
	    y2milestone ("Pkg::PkgPrepareOrder()");
	    list ins_del_count = Pkg::PkgPrepareOrder();
	    y2milestone ("delete %1, install %2", ins_del_count[0]:-1, ins_del_count[1]:-1);
	}
	else
	{
	    other_media_packages = SCR::Read (.target.ycp, Installation::destdir + "/var/lib/YaST2/other_media_packages", []);
	    if (other_media_packages == nil)
		other_media_packages = [];
	    y2milestone ("%1 packages remaining", size (other_media_packages));
	    if (size (other_media_packages) == 0)
		return 0;
	}

	map product = Pkg::SourceProductData (Packages::theSource);
	string datadir = product["datadir"]:"suse";
	y2milestone ("datadir %1", datadir);
	string pkgname = "";

	if (media_number == 1)
	    pkgname = Pkg::PkgNextInstall();
	else
	{
	    other_media_nr = other_media_packages[other_media_pos,0]:0;
	    pkgname = other_media_packages[other_media_pos,1]:"";
	    other_media_pos = other_media_pos + 1;
	}

	boolean correct_media = true;			// FIXME
	boolean skip_media = false;

	// ensure correct medium and implement skipping
	while ((pkgname != nil)
	     && (pkgname != ""))
	{
	    if (other_media_nr > 0)
	    {
		if (other_media_nr != media_number)
		{
		    break;
		}
	    }
	    else if (Pkg::PkgMediaNr (pkgname) != media_number)
	    {
		break;
	    }
	    if (!correct_media)
	    {
		correct_media = true;		// only on first loop
		if (!PackageInstallation::ChangeMediumWrapper ( media_number, true ))
		{
		    skip_media = true;		// user wants to skip all packages from this media
		}
	    }
	    if (!skip_media)		// dont skip
		break;

	    // skipping, loop through all packages from this media
	}

	// exit here if all packages were skipped
	if (skip_media)
	    return 0;

	// install packages from this media

	SlideShow::StartTimer();
	UI::MessagePopup( _( "Timer started" ) );

	while ((pkgname != nil)
		&& (pkgname != ""))
	{
	    if (other_media_nr > 0)
	    {
		if (other_media_nr != media_number)
		{
		    break;
		}
	    }
	    else if (Pkg::PkgMediaNr (pkgname) != media_number)
	    {
		break;
	    }
	    y2milestone ("Installing %1", pkgname);
	    string location = Pkg::PkgLocation (pkgname);

	    if (location != nil)
	    {
		string localpath = Pkg::SourceProvide (Packages::theSource, datadir + "/" + location);
		if (localpath != nil)
		{
		    boolean ok = Pkg::TargetInstall (localpath);
		    if (!ok)
			error_packages = add (error_packages, pkgname);
		    else
			ret = ret + 1;
		    y2milestone ("install %1", ok);
		}
	    }
	    if (media_number == 1)
		pkgname = Pkg::PkgNextInstall();
	    else
	    {
		other_media_nr = other_media_packages[other_media_pos,0]:0;
		pkgname = other_media_packages[other_media_pos,1]:"";
		other_media_pos = other_media_pos + 1;
	    }
	}

	SlideShow::StopTimer();


	// write out remaining packages

	if (media_number == 1)
	{
	    while ((pkgname != nil)
		    && (pkgname != ""))
	    {
		other_media_nr = Pkg::PkgMediaNr (pkgname);
		other_media_packages = add (other_media_packages, [other_media_nr, pkgname]);
		pkgname = Pkg::PkgNextInstall();
	    }
	    y2milestone ("%1 packages on other media", size (other_media_packages));
	    SCR::Write (.target.ycp, Installation::destdir + "/var/lib/YaST2/other_media_packages", other_media_packages);
	}

	if (size (error_packages) > 0)
	{
	    list failed_packages = SCR::Read (.target.ycp, Installation::destdir + "/var/lib/YaST2/failed_packages", []);
	    if (failed_packages == nil)
		failed_packages = [];
	    failed_packages = union (failed_packages, error_packages);
	    SCR::Write (.target.ycp, Installation::destdir + "/var/lib/YaST2/failed_packages", failed_packages);
	    ret = -ret;
	}

	y2debug( "InstallPackages: WFM::CallModule(packager, ...) returns: %1", ret );

	return ret;
    };


    /**
     * Wrapper function for ChangeMedium: Update statistics along with the
     * (optional) real Medium change popup.
     * @param cd_no Number of the Medium to request (from 1 on)
     * @param show_popup false: no popup, only check for presence of this Medium
     * @return boolean - passed trough from ChangeMedium (true: OK, false: abort)
     **/
    global define boolean ChangeMediumWrapper( integer cd_no, boolean show_popup ) ``{
	// y2debug( "Requesting Medium #%1", cd_no );

	boolean ret = true;

	if ( ! Mode::test )
	{
	    ret = MediaUI::ChangeMedium( cd_no, show_popup );
	}
	else // Mode::test - do some fake
	{
	    ret = true;

	    if ( show_popup )
	    {
		// No translation, this is for testing only
		ret = UI::ContinueCancelPopup( sformat( "%1 #%2 requested (test mode).\n\n"			+
							"You don't really need a %1 - this is just a fake.\n"	+
							"You can safely just hit 'Continue'.\n"
							, InstMedia::medianame, cd_no ) );
	    }
	}

	if ( ret )
	{
	    SlideShow::SetCurrentCdNo( cd_no );
	}
	SlideShow::UpdateAllCdProgress( false );
	// y2debug( "ChangeMediumWrapper returning with %1", ret );

	return ret;
    };



    //
    // Fake progress bars for Mode::test
    //
    global define symbol FakePackager(  list packages, string inst_source, boolean deleting ) ``{
	integer disk_usage = 20;
	integer disk_capacity = 10000;
	any ret = nil;
	integer number = 0;

	y2debug( "FakePackager - handling %1 packages", size( packages ) );

	foreach( `pac, packages, ``{
	    //y2debug( "Fake installing %1 from %2", select(pac,0), inst_source );

	    string pkg_name	= pac[0]:"";

	    integer pkg_size 	= SlideShow::GetPackageSize( select(pac, 0, "") );
	    integer bytes_installed = 0;

	    if ( pkg_size < 0 )
	    {
		// pkginfo doesn't know anything about the kernel RPM, so its
		// size can't be obtained, e.g. pkg_size is -1. To make up for
		// this, let's assume a negative starting size to keep things
		// going for a while (this is test_mode only, anyway).
		bytes_installed = -857 * 1024;
	    }

	    while  ( bytes_installed < pkg_size && ret != `cancel && ret != `diskfull )
	    {
		integer percent = ( 100 * bytes_installed ) / pkg_size;
		if ( deleting )
		{
		    ret = UI::CyclicDeletePkgCallback( pkg_name,
						       pac[1]:"",
						       percent,
						       number,
						       disk_usage,
						       disk_capacity,
						       false );	// error
		}
		else
		{
		    ret = UI::CyclicInstallPkgCallback( pkg_name,
							pac[1]:"",
							percent,
							number,
							disk_usage,
							disk_capacity,
							false );	// error
		}
		sleep ( 300 ); // millisec
		bytes_installed = bytes_installed + 300 * 1024;
	    }
	    disk_usage = disk_usage+1;
	    number = number+1;

	} );

	if	( ret == `cancel || ret == `abort )	ret = `cancel;
	else if ( ret == `diskfull )			ret = `diskfull;
	else						ret = `ok;

	y2debug( "FakePackager returning with %1", ret );
	return ret;
    };



}
