/**
 * Module:		InstMedia.ycp
 *
 * Authors:		Klaus Kaempf (kkaempf@suse.de)
 *			Gabriele Strattner (gs@suse.de)
 *			Stefan Schubert (schubi@suse.de)
 *
 * Purpose:		Installation media related functions module
 *
 *
 * $Id$
 */

{
    module "InstMedia";

    import "Arch";
    import "Mode";
    import "Installation";

    textdomain "packager";


    global integer theSource = -1;

    /**
     * !local! maximum number of installation CDs
     * used in splitServerPath
     */
    integer maxnumbercds = 8;

    /**
     * list of possible media devices
     */
    global list mediadevices = [];

    /**
     * currently mounted Medium index from above list
     */
    global integer cd_current = 0;

    /**
     * is the installation medium currenty mounted
     */
    global boolean is_mounted = Mode::sourcemounted;

    /**
     * did we mount the medium (-> umount needed by us)
     */
    global boolean we_mounted = !Mode::sourcemounted;

    /**
     * flag if installation is splitted across different media
     * if yes, inst-sys is on first medium only and we must
     * start the system before installing from other medium.
     */
    global boolean splitted = true;

    /**
     * defines the installmode
     *   dvd, cd, nfs, hd, ftp, smb, http, tftp
     *
     * !! This is not the same as Mode::boot since InstMedia
     *    might be intialized differently from Mode. !!
     *
     * @see: initializeInstMedia
     */
    global string installmode = "cd";

    /**
     *   0=cd, 1=dvd, 2=nfs, 3=hd, 4=ftp, 5=smb, 6=http, 7=tftp
     */
    global integer mediatype = 0;

    /**
     * name of media
     */
    global string medianame = "CD";

    /**
     * network (nfs, smb, ...) server and directory
     */
    global string net_server = "";	// name of server, partition for Harddisk
    global string net_dir = "";		// share for SMB, dir for Harddisk
    global string net_username = "";	// SMB, FTP
    global string net_password = "";	// SMB
    global string net_proxy = "";	// FTP, HTTP
    global string net_proxyport = "";	// FTP, HTTP
    global string net_proxyproto = "";	// FTP, HTTP

    /**
     * mount data SMB
     */
    global string smb_workdomain = "";		// Workgroup or Domainname

    /**
     * defines initial boot source, /var/adm/mount for harddisk
     */
    global string boot_src = "/dev/cdrom";

    /**
     * installation media data
     */
    global integer release_no = 0;
    global string product = "";

    /**
     * get package information from source medium
     */
    global boolean source_medium = false;

    /**
     * local data !
     */
    string smb_device = "";		// constructed from above values
    string smb_options = "";		// constructed from above values

    string tmp_mount = "/tmp/mnt";	// temporary mount for hd install

    // -------------------------------------------------------------------


    /**
     *
     * get the name of current Medium device or other boot source (e.g. harddisk)
     *
     */

    global define string CurrentMediumDevice( )
    ``{
	string dev = mediadevices[cd_current]:boot_src;
	y2milestone ("CurrentMediumDevice (%1 [cd # %2])", dev, cd_current);
	return dev;
    }

    /**
     * Unmount the installation medium
     *
     */

    global define void UnmountMedium ()
    ``{
	if (we_mounted
	    && Pkg::SourceIsAttached(theSource))
	{
	    Pkg::SourceRelease (theSource, (Arch::ppc32	&& (mediatype == 0 || mediatype == 1)));

	    is_mounted = false;
	    we_mounted = false;
	}
	return;
    }


    /**
     * Change the source medium, i.e. mount the medium to Installation::sourcedir
     * (umount previous used).
     *
     * @param cdnum integer Medium number
     * @return integer 0	all ok, medium mounted<BR>
     *		> 0		wrong cd, number of current cd returned<BR>
     *		< 0		error<BR>
     *		-1		no alternatives (not remountable)<BR>
     *		-2		mount failed (no medium)<BR>
     *		-3		not an installation medium<BR>
     *
     * @example MountMedium ( 2 );
     *
     */

    global define integer MountMedium (integer cdnum)
    ``{
	y2milestone ("MountMedium (%1) type %2, mounted %3 ...", cdnum, mediatype, is_mounted);

	integer actcdnum = -2;		// assume 'no medium'

	integer actcddevicenum = -1;	// index to mediadevices for "actcdnum"

	if (is_mounted)
	{
	    if (SCR::Read (.target.string, Installation::sourcedir+"/media."+cdnum+"/media", "") != "")
	    {
		actcdnum = cdnum;
		return 0;
	    }

	    actcdnum = -3;		// not a SuSE medium
	}

	integer	current_device	= cd_current;	// start with previous device

	if ( (mediatype == 2) || (mediatype == 3))	// NFS or Harddisk
	{
	    // direct access to dir, cdnum-1 is index in list mediadevices
	    current_device = cdnum - 1;
	}

	// if list exhausted, restart at 0
	if (current_device >= size(mediadevices) )
	{
	    current_device = 0;
	}

	integer start_device = current_device;
	integer start_num = actcdnum;		// initial cd or error code

	boolean mount_result = true;

	while (true)
	{
	    // wrong number -> umount medium
	    UnmountMedium ();

	    // try to mount next from list

	    cd_current = current_device;
	    string current_cd_device = CurrentMediumDevice ();

	    is_mounted = Pkg::SourceAttach (theSource);

	    if (is_mounted)
	    {
		// ok, medium is mounted
		// try to get SuSE medium number
		if (SCR::Read (.target.string, Installation::sourcedir+"/media."+cdnum+"/media", "") != "")
		{
		    actcdnum = 0;
		    break;
		}
		else
		{
		    actcdnum = -3;
		}
	    }
	    else
	    {
		actcdnum = -2;			// mount failed
	    }

	    // wrong number, try next

	    current_device = current_device + 1;

	    if (current_device >= size(mediadevices) )
	    {
		y2milestone ("Wrap list of alternatives");
		current_device = 0;	// list exhausted, restart at 0
	    }

	    // wrap around, tried all

	    if (current_device == start_device)
	    {
		y2milestone ("Tried all alternatives");
		if (start_num > 0)
		{
		    // if found a different SuSE Medium, report this
		    actcdnum = start_num;
		}
		break;
	    }
	} // while (try_next)

	y2milestone ("... MountMedium (%1)", actcdnum);

	if (actcdnum != 0)
	{
	    // wrong number -> umount medium
	    UnmountMedium ();

	    if (actcddevicenum >= 0)	// we found another SuSE medium
	    {
		// start next mount try here,
		// eject _this_ device if triggered by user
		cd_current = actcddevicenum;
	    }
	}

	return actcdnum;
    }

    /**
     * !local! splitServerPath (string serverpath)
     * check if network install path ends in "CD1" and split it up
     * @param serverpath	path on network server (nfs, smb)
     * @return list of directories
     *
     * if serverpath ends in "/CD1", it is replicated for CD2 ... CD8
     *
     */

    define splitServerPath (string serverpath)
    ``{
	list medias = [];

	list serversplit = splitstring (serverpath, "/");

	// if directory ends in ".../CD1", assume splitted dirs

	string serverdir = serverpath;

	if ((size (serversplit) > 0)
	    && (serversplit[size (serversplit)-1]:"" == "CD1"))
	{
	    integer numcd = 1;	// use as counter, begin behind "server:"

	    // re-build path, dropping final "/CD1"

	    // start with adding up path elements.
	    serverdir = "";

	    while (numcd < size (serversplit)-1)
	    {
		serverdir = serverdir + "/" + serversplit[numcd]:"";
		numcd = numcd + 1;
	    }

	    // now pre-pend "server:"
	    serverdir = serversplit[0]:"" + serverdir;

	    // now build up server directories in medias

	    numcd = 1;			// start with CD1
	    string net_dir_path = "";
	    while (numcd <= maxnumbercds)
	    {
		net_dir_path = serverdir + "/CD" + numcd;
		medias = add (medias, net_dir_path);
		numcd = numcd + 1;
	    }

	}
	else
	{
	    medias = [ serverpath ];
	}
	return medias;
    }

    global define map installInf2installMap ( )
    ``{
	string instmode = SCR::Read (.etc.install_inf.InstMode);
	if (instmode == nil) instmode = "cd";
	string cdrom = SCR::Read (.etc.install_inf.Cdrom);
	if (cdrom == nil) cdrom = "cdrom";
	string server = SCR::Read (.etc.install_inf.Server);
	if (server == nil) server = "";
	string serverdir = SCR::Read (.etc.install_inf.Serverdir);
	if (serverdir == nil) serverdir = "";
	string username = SCR::Read (.etc.install_inf.Username);
	if (username == nil) username = "";
	string password = SCR::Read (.etc.install_inf.Password);
	if (password == nil) password = "";
	string workdomain = SCR::Read (.etc.install_inf.WorkDomain);
	if (workdomain == nil) workdomain = "";
	string proxy = SCR::Read (.etc.install_inf.Proxy);
	if (proxy == nil) proxy = "";
	string proxyport = SCR::Read (.etc.install_inf.ProxyPort);
	if (proxyport == nil) proxyport = "";
	string proxyproto = SCR::Read (.etc.install_inf.ProxyProto);
	if (proxyproto == nil) proxyproto = "";
	string proxyuser = SCR::Read (.etc.install_inf.ProxyUser);
	if (proxyuser == nil) proxyuser = "";
	string proxypassword = SCR::Read (.etc.install_inf.ProxyPassword);
	if (proxypassword == nil) proxypassword = "";

	return $[ "instmode" : instmode,
		     "cdrom" : cdrom,
		     "server" : server,
		     "serverdir" : serverdir,
		     "username" : username,
		     "password" : password,
		     "workdomain" : workdomain,
		     "proxy" : proxy,
		     "proxyport" : proxyport,
		     "proxyproto" : proxyproto,
		     "proxyuser" : proxyuser,
		     "proxypassword" : proxypassword
		];
    }

    global define string installInf2Url ( )
    ``{
	string url = SCR::Read (.etc.install_inf.InstMode);
	url = url + "://";
	string username = SCR::Read (.etc.install_inf.Username);
	if ((username != nil) && (username != ""))
	{
	    url = url + username;
	    string password = SCR::Read (.etc.install_inf.Password);
	    if ((password != nil) && (password != ""))
	    {
		url = url + ":";
		url = url + password;
	    }
	    url = url + "@";
	}
	string server = SCR::Read (.etc.install_inf.Server);
	if ((server != nil) && (server != ""))
	{
	    url = url + server;
	}
	string serverdir = SCR::Read (.etc.install_inf.Serverdir);
	if ((serverdir != nil) && (serverdir != ""))
	{
	    url = url + serverdir;
	}
	string proxy = SCR::Read (.etc.install_inf.Proxy);
	if ((proxy != nil) && (proxy != ""))
	{
	    url = url + ";proxy=" + proxy;
	}
	string proxyport = SCR::Read (.etc.install_inf.ProxyPort);
	if ((proxyport != nil) && (proxyport != ""))
	{
	    url = url + ";proxyport=" + proxyport;
	}
	string proxyproto = SCR::Read (.etc.install_inf.ProxyProto);
	if ((proxyproto != nil) && (proxyproto != ""))
	{
	    url = url + ";proxyproto=" + proxyproto;
	}
	string proxyuser = SCR::Read (.etc.install_inf.ProxyUser);
	if ((proxyuser != nil) && (proxyuser != ""))
	{
	    url = url + ";proxyuser=" + proxyuser;
	}
	string proxypassword = SCR::Read (.etc.install_inf.ProxyPassword);
	if ((proxypassword != nil) && (proxypassword != ""))
	{
	    url = url + ";proxypassword=" + proxypassword;
	}
	y2milestone ("URL %1", url);
	return url;
    }

    /**
     *
     * this initializes the module
     *
     * it is used as a run-time constructor, since we need
     * to pass different installMaps, either coming from
     *
     * linuxrc (based on /etc/install.inf) ==> installMap != $[]
     *
     * package agent (based on /var/lib/YaST/install.inf) ==> installMap == $[]
     *
     */

    global define initializeInstMedia ( map installMap )
    ``{
	y2milestone ("initializeInstMedia (%1)", installMap);

	if ( size ( installMap ) == 0 )
	{
	    installMap = Mode::installMap;
	}

	if ( size ( installMap ) == 0 )
	{
	    // fallback
	    y2warning( "UTILS *** No install-information found->take CD as default" );
	    installMap = $[ "instmode":"cd", "cdrom":"cdrom" ];
	}

	installmode = installMap["instmode"]:"cd";	// default: booting from CD

	list allowed_install_modes = [ "cd", "dvd", "nfs", "hd", "ftp", "smb", "http", "tftp"];

	if (!contains (allowed_install_modes, installmode))
	{
	    installmode = "cd";
	}

	is_mounted = Mode::initial;	// linuxrc does it

	mediadevices = [];

	if (installmode == "cd")
	{
	    mediatype = 0;
	    medianame = "CD";

	    string dev_name = installMap["cdrom"]:"cdrom";

	    // set the initial boot source
	    boot_src = "/dev/" + dev_name;

	    list cddrives = [];
	    if (Mode::initial
		|| Mode::cont)
	    {
		cddrives = SCR::Read(.probe.cdrom);
	    }
	    else
	    {
		cddrives = SCR::Read(.probe.cdrom.manual);
	    }
	    if ((cddrives == nil)
		|| (size (cddrives) == 0))
	    {
		cddrives = [$["dev_name":"/dev/cdrom"]];
	    }

	    foreach (`drive, cddrives,
	    ``{
		dev_name = drive["dev_name"]:"";
		if (!contains (mediadevices, dev_name))
		{
		    mediadevices = add (mediadevices, dev_name);
		}
	    });

	    splitted = true;
	}
	else if (installmode == "dvd")
	{
	    mediatype = 1;
	    medianame = "DVD";

	    string dev_name = installMap["cdrom"]:"dvd";

	    // set the initial boot source
	    boot_src = "/dev/" + dev_name;

	    // if its not (!) /dev/dvd, save it
	    //   /dev/dvd is always a symlink to the real
	    //   device which we'll get via .probe.cdrom anyway

	    if (dev_name != "dvd")
	    {
		mediadevices = add (mediadevices, boot_src);
	    }

	    list dvddrives = SCR::Read(.probe.cdrom.manual);

	    if ((dvddrives == nil)
		|| (size (dvddrives) == 0))
	    {
		cddrives = [$["dev_name":"/dev/dvd", "prog_if" : 3]];
	    }

	    foreach (`drive, dvddrives,
	    ``{
		// filter out DVD drives
		if (drive["prog_if"]:0 == 3)
		{
		    dev_name = drive["dev_name"]:"";
		    if (!contains (mediadevices, dev_name))
		    {
			mediadevices = add (mediadevices, dev_name);
		    }
		}
	    });

	    splitted = true;
	}
	else if (installmode == "nfs")
	{
	    mediatype = 2;
	    // check if serverdir ends in "CD1"
	    // rebuild serverdir without CD1

	    net_server  = installMap["server"]:"";
	    net_dir	= installMap["serverdir"]:"";

	    boot_src = net_server + ":" + net_dir;

	    list pathes = splitServerPath (boot_src);

	    if (size (pathes) > 1)
	    {
		splitted = true;
	    }
	    else
	    {
		splitted = false;
	    }

	    mediadevices = union (mediadevices, pathes);
	}
	else if (installmode == "hd")
	{
	    mediatype = 3;
	    integer hdcd = 1;
	    boot_src   = "/var/adm/mount";

	    net_server = installMap["partition"]:"";
	    net_dir    = installMap["serverdir"]:"";

	    // if partition given, ensure dir is rooted
	    if (net_server != "")
	    {
		if (substring (net_dir, 0, 1) != "/")
		{
		    net_dir = "/" + net_dir;
		}
	    }

	    // usually, linuxrc has already mounted it to /var/adm/mount
	    // so we don't need to do anything.
	    // However, during 2nd stage install or if linuxrc didn't mount
	    // it, 'is_mounted' is false and we must re-mount it from
	    // server.

	    list pathes = splitServerPath (net_dir);

	    if (size (pathes) > 1)
	    {
		splitted = true;
	    }
	    else
	    {
		splitted = false;
	    }

	    if (is_mounted)
	    {
		// CD1 already mounted to boot_src by linuxrc
		mediadevices = [ boot_src ];
	    }
	    else
	    {
		mediadevices = union (mediadevices, pathes);
	    }
	}
	else if (installmode == "ftp")
	{
	    mediatype = 4;
	    net_server	 = installMap["server"]:"";
	    net_dir	 = installMap["serverdir"]:"";
	    net_username = installMap["ftpuser"]:"";
	    net_password = installMap["password"]:"";
	    net_proxy	 = installMap["ftpproxy"]:"";
	    net_proxy	 = installMap["ftpproxyport"]:"";
	    splitted = true;
	}
	else if (installmode == "smb")
	{
	    mediatype = 5;

	    net_server	     = installMap["server"]:"";
	    net_dir	     = installMap["serverdir"]:"";
	    net_username     = installMap["username"]:"";
	    net_password     = installMap["password"]:"";
	    smb_workdomain   = installMap["workdomain"]:"";

	    smb_device	= "//" + net_server;
	    smb_options	= " -t smbfs";

	    if ( net_username != "" && net_password != "" )
	    {
		smb_options = smb_options + " -o ro,username=" + net_username + ",password=" + net_password + ",workgroup=" + smb_workdomain;
	    }
	    else
	    {
		smb_options = smb_options + " -o guest,ro";
	    }

	    list pathes = splitServerPath (net_dir);

	    if (size (pathes) > 1)
	    {
		splitted = true;
	    }
	    else
	    {
		splitted = false;
	    }

	    mediadevices = union (mediadevices, pathes);

	} // if "Smb"
	else if (installmode == "http")
	{
	    mediatype = 6;
	    net_server	 = installMap["server"]:"";
	    net_dir	 = installMap["serverdir"]:"";
	    net_username = installMap["username"]:"";
	    net_password = installMap["password"]:"";
	    net_proxy	 = installMap["proxy"]:"";
	    net_proxyport= installMap["proxyport"]:"";
	    net_proxyproto=installMap["proxyproto"]:"";
	    splitted = true;
	}
	else if (installmode == "tftp")
	{
	    mediatype = 7;
	    net_server	 = installMap["server"]:"";
	    net_dir	 = installMap["serverdir"]:"";
	    net_username = installMap["username"]:"";
	    net_password = installMap["password"]:"";
	    net_proxy	 = installMap["proxy"]:"";
	    net_proxyport= installMap["proxyport"]:"";
	    net_proxyproto=installMap["proxyproto"]:"";
	    splitted = true;
	}

	if (mediadevices == nil)
	{
	    mediadevices = [boot_src];
	}

	// check if mount point is in use

	if (mediatype != 3)
	{
	    foreach (`mountpoint, SCR::Read(.proc.mounts),
	    ``{
		if (mountpoint["file"]:"" == Installation::sourcedir)
		    is_mounted = true;
	    });
	}

	y2milestone ("mediadevices: %1", mediadevices);
	return;
    }

    // NO constructor

}
