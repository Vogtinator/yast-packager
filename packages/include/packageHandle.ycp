/**
 * Include:		packageHandle.ycp
 *
 * Authors:		Gabriele Strattner (gs@suse.de)
 *			Stefan Schubert (schubi@suse.de)
 *
 * Purpose:		Provides a number of functions and popups
 *			which check or show the package dependencies,
 *			inform the package agent, do selections ...
 *
 * $Id$
 */

{
    import "PackagesUI";

    textdomain "packager";

    //
    // Update all informations
    //

    global define UpdatePackageData( string package_set ) ``{

	// Update disk space information
	list new_part_input = CreatePartTable( );
	UI::ChangeWidget(`id(`part_table), `Items, new_part_input);

	UI::ChangeWidget(`id(`req_space), `Value, sformat(_("Required: %1"), SpaceCalculation::GetRequSpace( false )));

	CheckDependencies( false,	// don't show AND dependencies
			   "" );	// no certain package selected

	// call UpdateTable after CheckDependencies (the package status may have changed)
	UpdateTable( package_set );	// update the list of packages

    }

    //
    // Get all packages beloging to selected set
    //

    global define map GetSetPackages ( string package_set ) ``{
	map packages = $[];

	if ( package_set == descr_all )		// get list of all packages
	{
	    packages = SCR::Read(.package.packageList);
	}
	else if ( package_set == descr_search )
	{
	    packages = search_result;		// search already done
	}
	else
	{
	    packages = SCR::Read(.package.hierarchyInformation, $["branch":package_set, "rpmgroup":show_groups]);
	}
	y2debug("All packages of set %1: %2", package_set, packages );

	return packages;
    };

    //
    // Select all packages
    //

    global define SelectAllPackages( string package_set ) ``{

	// set global variables
	set_pacs = GetSetPackages( package_set );
	current_pac = "";

	foreach ( `pac, `value, set_pacs, ``{
	    string status =  SCR::Read(.package.packageStatus, pac );
	    if ( status == "")
	    {
		SelectPac( pac );
	    }
	});

	UpdatePackageData( package_set );

        // Warning message if free space < 0
	SpaceCalculation::ShowPartitionWarning( );

    };

    //
    // Replace all installed packages
    //

    global define ReplaceAllPackages( string package_set ) ``{

	// set global variables
	set_pacs = GetSetPackages( package_set );
	current_pac = "";

	foreach ( `pac, `value, set_pacs, ``{
	    string status =  SCR::Read(.package.packageStatus, pac );
	    if ( status == "i")
	    {
		SelectPac( pac );
	    }
	});

	UpdatePackageData( package_set );
    };

    //
    // Deselect all packages
    //

    global define DeselectAllPackages( string package_set ) ``{

	// set global variables
	set_pacs = GetSetPackages( package_set );
	current_pac = "";

	foreach ( `pac, `value, set_pacs, ``{
	    string status =  SCR::Read(.package.packageStatus, pac );
	    if ( status == "X")
	    {
		DeselectPac( pac );
	    }
	});

	UpdatePackageData( package_set );
    };

    //
    // Delete all packages
    //

    global define DeleteAllPackages( string package_set ) ``{

	// set global variables
	set_pacs = GetSetPackages( package_set );
	current_pac = "";

	foreach ( `pac, `value, set_pacs, ``{
	    string status =  SCR::Read(.package.packageStatus, pac );
	    if ( status == "i" )
	    {
		DeletePac( pac );
	    }
	});

	UpdatePackageData( package_set );
    };

    //
    // Delete replaced packages
    //

    global define DeleteReplacePackages( string package_set ) ``{

	// set global variables
	set_pacs = GetSetPackages( package_set );
	current_pac = "";

	foreach ( `pac, `value, set_pacs, ``{
	    string status =  SCR::Read(.package.packageStatus, pac );
	    if ( status == "X" )
	    {
		any r = SCR::Execute(.package.deselectInstall, pac, false );
		status =  SCR::Read(.package.packageStatus, pac );
		if ( status == "i" )
		{
		    DeletePac( pac );
		}
	    }
	});

	UpdatePackageData( package_set );
    };

    //
    // Replace packages selected to delete
    //

    global define ReplaceDeletePackages( string package_set ) ``{

	// set global variables
	set_pacs = GetSetPackages( package_set );
	current_pac = "";

	foreach ( `pac, `value, set_pacs, ``{
	    string status =  SCR::Read(.package.packageStatus, pac );
	    if ( status == "d" )
	    {
		any r = SCR::Execute(.package.deselectDelete, pac, false );
		status =  SCR::Read(.package.packageStatus, pac );
		if ( status == "i" )
		{
		    SelectPac( pac );
		}
	    }
	});

	UpdatePackageData( package_set );

        // Warning message if free space < 0
	SpaceCalculation::ShowPartitionWarning( );
    };

    //
    // DeselectDelete all packages
    //

    global define DeselectDeleteAllPackages( string package_set ) ``{

	// set global variables
	set_pacs = GetSetPackages( package_set );
	current_pac = "";

	foreach ( `pac, `value, set_pacs, ``{
	    string status =  SCR::Read(.package.packageStatus, pac );
	    if ( status == "d" )
	    {
		SCR::Execute(.package.deselectDelete, pac );
	    }
	});

	UpdatePackageData( package_set );

        // Warning message if free space < 0
	SpaceCalculation::ShowPartitionWarning( );
    };

    //
    // Select a package
    //

    global define SelectPac( string package ) ``{
	string msg = "";

	any r = SCR::Execute(.package.selectInstall, package, false);
	y2debug( "SCR::Execute(.package.selectInstall: %1, %2", package, r );

	msg = SCR::Read(.package.notifyDesc, package );
	if ( msg != "" )
	{
	    string nty_title = NotifyMsg();
	    term msg_text = `RichText( "<p>" + package + "</p>" + "<p>" + msg + "</p>" );
	    PackagesUI::DisplayHelpMsg( nty_title, msg_text, `none, 10 );
	}
    };

   //
   // Deselect a package
   //

    global define DeselectPac( string package ) ``{
	string msg = "";

	any r = SCR::Execute(.package.deselectInstall, package, false );
	y2debug( "SCR::Execute(.package.deselectInstall: %1, %2", package, r );

	string status =  SCR::Read(.package.packageStatus, package);
	if ( status == "" )
	{
	    // only show the message if the package is not installed
	    msg = SCR::Read(.package.delDesc, package );
	    if ( msg != "" )
	    {
		string wrn_title = WarningMsg();
		term msg_text = `RichText( "<p>" + package + "</p>" + "<p>" + msg + "</p>" );
		PackagesUI::DisplayHelpMsg( wrn_title, msg_text, `warncolor, 10 );
	    }
	}
    };

   //
   // Delete an installed package
   //

    global define DeletePac( string package ) ``{
	string msg = "";
	boolean ret = true;

	any r = SCR::Execute(.package.selectDelete, package );
	y2debug( "SCR::Execute(.package.selectDelete: %1", package );

	msg = SCR::Read(.package.delDesc, package );
	if ( msg != "" )
	{
	    string wrn_title = WarningMsg();
	    term msg_text = `RichText( "<p>" + package + "</p>" + "<p>" + msg + "</p>" );
	    PackagesUI::DisplayHelpMsg( wrn_title, msg_text, `warncolor, 10 );
	}

	// make sure that it isn't an automatically needed package
	map    pac_depends = $[];
	list and_depends = [];

	pac_depends = SCR::Read(.package.dependencies);
	y2debug( "SCR::Read(.package.dependencies: %1", pac_depends );

	and_depends = lookup( pac_depends, "ADD", [] );

	if ( contains( and_depends, package ) )
	{
	    ret = DisplayAddPopup( package );
	    y2debug( "DisplayAddPopup returns: %1", ret );

	    if ( ret == false )
	    {
		// do not delete the package
		SCR::Execute(.package.deselectDelete, package );
	    }
	    else
	    {
		// delete the package (AND delete the additional dependencies because
		// otherwise the package would be installed instead of deleted)
		SCR::Execute(.package.deleteAdditionalDependencies, package );
	    }
	}

	return ret;
    };

   //
   // Update installed package
   //

    global define UpdatePac( string package, boolean call_pkginfo ) ``{
	string msg = "";
	any r = true;

	if ( call_pkginfo)
	{
	    r = SCR::Execute(.package.selectUpdate, package );
	    y2debug( "SCR::Execute(.package.selectUpdate: %1 %2", package, r );
	}

	if ( r )
	{
	    maplist ( `pac, `value,  upd_pacs,
		      ``( {  if ( pac == package )
		      {
			  UI::ChangeWidget(`id(`pac_table), `Item( pac, 0 ), "u");
			  upd_pacs = add( upd_pacs, pac, [UPDATE, select(value, 1, ""), select(value,2, ""), select(value,3,"" )] );
		      }
		      })
		      );
	}
    };

   //
   // Do not update installed package
   //

    global define NoUpdatePac( string package ) ``{
	string msg = "";

	any r = SCR::Execute(.package.deselectUpdate, package );
	y2debug( "SCR::Execute(.package.deselectUpdate: %1 %2", package, r );

	// package marked to delete

	boolean ret = DeletePac(package);
	string status = "d";

	// ret == false means do not delete the package (select it for update again)
	if ( !ret )
	{
	    status = "u";
	    r = SCR::Execute(.package.selectUpdate, package );
	    y2debug( "SCR::Execute(.package.selectUpdate: %1 %2", package, r );
	}

	maplist ( `pac, `value,  upd_pacs, ``({
	    if ( pac == package )
	    {
		UI::ChangeWidget(`id(`pac_table), `Item( pac, 0 ), status);
		if ( status == "d" )
		{
		    upd_pacs = add( upd_pacs, pac,  [DELETE, select(value, 1, ""), select(value,2, ""), select(value,3, "")] );
		}
	    }
		  })
		  );
    };


    //
    // get list of packages which don't work any more
    //

    global define BreakingPackages ( string package, boolean format ) ``{
	// check which packages rely on the package
	list broken_pacs = SCR::Read(.package.breakingPackageList, package );
	y2debug("SCR::Read(.package.getBreakingPackageList( %1 ): %2", package, broken_pacs );

	string packages = "";
	integer n = 1;
	foreach ( `pac, broken_pacs, ``{
	    if ( n <= 20 )
	    {
		if ( !format || (size(packages)/n < 40) )
		{
		    if (packages != "")
		    {
			packages = packages + ", ";
		    }
		}
		else
		{
		    if (packages != "")
		    {
			packages = packages + "\n";
			n = n+1;
		    }
		}
		packages = packages + pac;
	    }
	});
	return packages;
    };


    //
    // initial check of dependencies
    //
    global define SolveDependencies( boolean check_add, string package ) ``{

	initial_checked = true;

	map deps = SCR::Read(.package.dependencies);
	y2debug( "SCR::Read(.package.getDependencies: %1", deps );

	if ( ( lookup( deps, "REQUIRE", [] ) != [] || lookup( deps, "CONFLICT", [] ) != [] ) ||
	     ( check_add && (lookup( deps, "ADD", [] ) != []) ) 			)
	{
	    // Notify popup informs the user about existing package dependencies.
	    // text part 11 is used in already installed system
	    string inst_msg =  _("Your existing installation ");
	    // text part 12 is used when doing new installation
	    string sel_msg =  _("Your current selection ");

	    // text part 2 of notify popup which informs that there are packages
	    // which conflict - or additional packages are needed. But normally
	    // this is not a problem and the user can go on with installation.
	    string msg_str = _("contains packages that
either interfere with other packages
or require the installation of additional packages.

This is usually not a serious problem.

Either continue without worrying about it
or have YaST2 display the package dependencies.
");

	    if ( update_mode || post_mode )
	    {
		msg_str = inst_msg + msg_str;
	    }
	    else
	    {
		msg_str = sel_msg + msg_str;
	    }

	    term msg = `RichText(msg_str);

	    any ret = UI::AnyQuestionPopup (NotifyMsg(), msg_str,
					    ContinueButtonLabel(), _("&Show dependencies"), `focus_yes );

	    if (!ret)
	    {
		CheckDependencies( check_add, package );	// show AND deps?
	    }
	    else		// forget about OR/XOR dependencies (ANDs will be installed)
	    {
		foreach( `pacdep, lookup( deps, "CONFLICT", [] ), ``{
		    string pac_name = lookup( pacdep, "name", "" );
		    list  pac_list = lookup( pacdep, "packages", [] );
		    foreach( `pac, pac_list, ``{
			any r =  SCR::Execute(.package.deleteConflictDependencies, pac_name, pac );
			y2debug( "SCR::Execute(.package. deleteConflictDependencies: %1 %2, %3", pac_name, pac, r );
			r =  SCR::Execute(.package.deleteConflictDependencies, pac, pac_name );
			y2debug( "SCR::Execute(.package.deleteConflictDependencies: %1 %2", pac, pac_name );
		    } );
		});
		foreach( `pacdep, lookup( deps, "REQUIRE", [] ), ``{
		    string tag_name = lookup( pacdep, "tag", "" );
		    any r =  SCR::Execute(.package.deleteUnsolvedRequirements, tag_name );
		    y2debug( "SCR::Execute(.package.deleteUnsolvedRequirements: %1, %2", tag_name, r );
		} );
	    }
	}
    };


    //
    // Get dependencies from pkginfo + display popup ADD / REQUIRE / CONFLICT / OBSOLETE dependencies.
    //
    // $["ADD": [pac1, pac2], "REQUIRE":[$["tag":"tag1", "packages":["aaa", "bbb", "ccc"]]],
    //                  	"CONFLICT": $["name":"pac1", "packages":["abc", "ddd"]],
    //			"OBSOLETE":  [ [ pac2, [], pac3, [] ]			]
    //
    // We do not show all dependency popups in one loop but only the first dependency, because
    // after a new check with getDependencies some dependencies could be resolved.
    //

    global define CheckDependencies( boolean show_and_deps, string package ) ``{

	boolean or_exist = false;
	boolean xor_exist = false;
	map    	pac_depends = $[];

	pac_depends = SCR::Read(.package.dependencies);
	y2debug( "SCR::Read(.package.Dependencies: %1", pac_depends );

	list or_depends  = lookup( pac_depends, "REQUIRE", [] );
	list xor_depends = lookup( pac_depends, "CONFLICT", [] );
	list and_depends = lookup( pac_depends, "ADD", [] );
	list obsoletes   = lookup( pac_depends, "OBSOLETE", [] );

	if ( and_depends != [] )
	{
	    deps_exist = true;
	    if ( show_and_deps )
	    {
		list items = [];
		foreach( `pac, and_depends, ``{
		    string pac_info = sformat(_("%1   ( required by: %2 )"), pac, BreakingPackages(pac, false) );
		    items = add( items, `item(`id(pac), pac_info, true));
		});

		list add_pacs = DisplayPackageList(_("Additional packages required"),
						   // The packages in the list below require to be installed, since..."
						   _("The packages in the list below require installation,
because other packages will not work without them."),
						   _("All selected packages will be installed"),
						   items,
						   false );	// don't check single

		any r = nil;
		foreach (`pac, and_depends, ``{
		    if ( !contains(add_pacs, pac) )
		    {
			// deselect all unwanted packages and delete dependency
			r = SCR::Execute(.package.deselectInstall, pac );
			y2debug( "SCR::Execute(.package.deselectInstall %1 %2", pac, r );
			r = SCR::Execute(.package.deleteAdditionalDependencies, pac );
			y2debug( "SCR::Execute(.package.deleteAdditionalDependencies %1 %2", pac, r );
		    }
		});

		// check again
		pac_depends = SCR::Read(.package.dependencies);
		y2debug( "SCR::Read(.package.Dependencies: %1", pac_depends );

		or_depends  = lookup( pac_depends, "REQUIRE", [] );
		xor_depends = lookup( pac_depends, "CONFLICT", [] );
		obsoletes   = lookup( pac_depends, "OBSOLETE", [] );
	    }
	}

	while ( or_depends != [] )
	{
	    or_exist = true;
	    deps_exist = true;
	    map first_dep = select( or_depends, 0, $[] );	// get first dependency

	    list pac_list = lookup( first_dep, "packages", [] );
	    pac_list = sort( pac_list );

	    string tag_name = lookup( first_dep, "tag", "" );

	    list or_list = [];
	    boolean first = true;
	    foreach( `pac, pac_list, ``{
		string list_entry = sformat ( "%1  ---  %2",  pac, select( SCR::Read(.package.shortDesc, pac), 0, "" ));
		if ( first )
		{
		    or_list = add( or_list, `item(`id(pac), list_entry, true ));
		    first = false;
		}
		else
		{
		    or_list = add( or_list, `item(`id(pac), list_entry, false ));
		}
	    } );

	    string msg = "";
	    if ( package != "" )
	    {
		// The selected package %1 requires  %2 (this is a name for a group of programs, e.g. browser).
		// The user have to choose an additional package from a list of packages.
		msg = sformat( _("Package \"%1\" requires \"%2\".
Select one from the list below."),
			       package, tag_name );
	    }
	    else
	    {
		// It is not clear which package requires %1.
		msg =  sformat( _("Your installation requires \"%1\".
Select one from the list below."),
				tag_name );
	    }
	    // headline of the additional package popup
	    list ret_list = DisplayPackageList( _("Additional package required"),
						msg,
						"",
						or_list,
						true );		// check single

	    // DisplayPackageList returns selected package(s)
	    if ( ret_list != [] )
	    {
		foreach ( `pac, ret_list, ``{
		    SelectPac( pac );
		});
	    }
	    else	// ret_list is empty
	    {
		// User decides to cancel that REQUIRE dependency
		any r =  SCR::Execute(.package.deleteUnsolvedRequirements, tag_name );
		y2debug( "SCR::Execute(.package.deleteUnsolvedRequirements: %1, %2", tag_name, r );
	    }

	    // check again
	    pac_depends = SCR::Read(.package.dependencies);
	    y2debug( "SCR::Read(.package.Dependencies: %1", pac_depends );

	    or_depends  = lookup( pac_depends, "REQUIRE", [] );
	    xor_depends = lookup( pac_depends, "CONFLICT", [] );
	    obsoletes   = lookup( pac_depends, "OBSOLETE", [] );

	};

	while ( xor_depends != [] )
	{
	    map first_dep = $[];
	    xor_exist = true;
	    deps_exist = true;

	    foreach ( `pac, xor_depends, ``{
		if ( lookup( pac, "name", "") == package )
		{
		    // if package is in XOR-list display that dependency first
		    first_dep = pac;
		}
	    } );

	    if ( first_dep == $[] )
	    {
		foreach ( `pac, xor_depends, ``{
		    // try to find the dependency concerning the uninstalled package
		    string status =  SCR::Read(.package.packageStatus, lookup( pac, "name", "") );
		    if ( status != "i" && status != "u" && status != "m" )
		    {
			first_dep = pac;
		    }
		} );
	    }

	    // Dependencies are not direct related to package and package is installed
	    if ( first_dep == $[] )
	    {
		first_dep = select( xor_depends, 0 , $[]); // get first
	    }

	    string pac_name = lookup( first_dep, "name", "" );
	    list pac_list = lookup( first_dep, "packages", [] );
	    y2debug( "show dependency: %1 : %2", pac_name, pac_list );

	    any ret = DisplayXorList( pac_name, pac_list, contains(lookup( pac_depends, "ADD", []), pac_name) );

	    if ( ret == `yes_install ) // install package anyway / forget dependencies
	    {
		foreach( `pac, pac_list, ``{
		    any r =  SCR::Execute(.package.deleteConflictDependencies, pac_name, pac );
		    y2debug( "SCR::Execute(.package.deleteConflictDependencies: %1 %2, %3", pac_name, pac, r );
		    r =  SCR::Execute(.package.deleteConflictDependencies, pac, pac_name );
		    y2debug( "SCR::Execute(.package.deleteConflictDependencies: %1 %2", pac, pac_name );
		} );

		string status = SCR::Read(.package.packageStatus, pac_name );
		if ( pac_name != package && status != "i" && status != "u" && status != "m" )
		{
		    SelectPac( pac_name );
		}
	    }
	    else	// ret == `no_let_it -> deselect the package
	    {
		if ( contains(lookup( pac_depends, "ADD", [] ), pac_name) )
		{
		    any r = SCR::Execute(.package.deleteAdditionalDependencies, pac_name );
		    y2debug( "SCR::Execute(.package.deleteAdditionalDependencies: %1, %2", pac_name, r );
		}
		DeselectPac( pac_name );
	    }

	    // check again
	    pac_depends = SCR::Read(.package.dependencies);
	    y2debug( "SCR::Read(.package.Dependencies: %1", pac_depends );

	    xor_depends = lookup( pac_depends, "CONFLICT", [] );
	    obsoletes   = lookup( pac_depends, "OBSOLETE", [] );

	};

	list obs_depends = GetNewObsoletes( obsoletes );

	while ( obs_depends != [] )
	{
	    string pac_name = "";
	    list pac_list = [];
	    string obs_name = "";
	    list obs_list = [];
	    list   obs_descr = [];
	    list dependency = [];

	    dependency = select( obs_depends, 0, [] );	// get first dependency

	    if ( select( dependency, 0, "" ) == package
		 || select( dependency, 3, "") == package )
	    {
		string status1 = SCR::Read(.package.packageStatus, select(dependency, 0, "") );
		string status2 = SCR::Read(.package.packageStatus, select(dependency, 3, "")  );

		y2debug ("STATUS package %1: %2, package %3: %4",
			 select(dependency, 0, ""), status1,
			 select(dependency, 3, ""), status2 );

		if ( status1 == "X" || status1 == "a" )
		{
		    pac_name = select( dependency, 0, "" );		// first package will obsolete second
		    pac_list = select( dependency, 2, [] );
		    obs_name = select( dependency, 3, "" );		// second package is obsoleted
		    obs_list = select( dependency, 5, [] );
		}
		else	 // first package is already installed so it will be obsoleted by second one
		{
		    pac_name = select( dependency, 3, "" );
		    pac_list = select( dependency, 5, [] );
		    obs_name = select( dependency, 0, "" );
		    obs_list = select( dependency, 2, [] );
		}
	    }
	    else
	    {
		ignores = add( ignores, dependency );
	    }
	    y2debug( "obsolete dependency: %1 %2 : %3 %4", pac_name, pac_list, obs_name, obs_list );

	    if ( obs_name != "" && SCR::Read(.package.shortDesc, obs_name  ) != [] &&
		 pac_name != "" && SCR::Read(.package.shortDesc, pac_name  ) != [] 	)
	    {
		any ret = UI::DisplayObsoletes( package,
						pac_name,
						pac_list,
						obs_name,
						select( SCR::Read(.package.shortDesc,obs_name), 0, "" ),
						obs_list );

		if ( ret == `no_let_it )  // do not install package
		{
		    DeselectPac( package );
		}
		else	// ignore this dependency for this installation session
		{
		    ignores = add( ignores, dependency );
		}
	    }
	    else
	    {
		// else: it is the old package name/package is not any longer in common.pkd
		ignores = add( ignores, dependency );
	    }
	    y2debug( "ignore dependencies: %1", ignores );

	    // check again
	    pac_depends = SCR::Read(.package.dependencies);
	    y2debug("SCR::Read(.package.dependencies: %1", pac_depends );

	    obsoletes = lookup( pac_depends, "OBSOLETE", [] );

	    obs_depends = GetNewObsoletes( obsoletes );

	};

	if ( !or_exist && !xor_exist && and_depends == [] )
	    return (true);
	else
	    return (false);
    };


    //
    // Get "OBSOLETE" dependencies which are not yet in list of dependencies
    // which are ignored.
    //

    global define list GetNewObsoletes( list obsoletes ) ``{

	list obs_depends = [];

	if ( obsoletes != [] )
	{
	    // ignores is a global list of dependencies which are ignored
	    if ( ignores != [] )
	    {
		foreach ( `obs, obsoletes, ``{
		    boolean addd = true;
		    // search the obsolete dependency in ignore list
		    foreach ( `ign, ignores, ``{
			if ( select( ign, 0, "" ) == select( obs, 0, "" ) &&
			     select( ign, 3, "" ) == select( obs, 3, "" )	)
			{
			    addd = false;
			}
		    });
		    if ( addd )
		    {
			obs_depends = add( obs_depends, obs );
		    }
		});
	    }
	    else
	    {
		obs_depends = obsoletes;
	    }
	}

	return obs_depends;
    };


    //
    // Popup display ADD Notify message
    //

    global define DisplayAddPopup( string pac_name ) ``{

	any r = UI::AnyQuestionPopup( NotifyMsg(), sformat(_("Package \"%1\" is required
by the following packages:
\"%2\"
These packages will not work without \"%1\".
Really deselect \"%1\"?
"), pac_name, BreakingPackages( pac_name, true)),
				      YesButtonLabel(),
				      NoButtonLabel(), `focus_no );

	y2debug( "YesOrNo %1", r );
	return r;
    };

    //
    // Popup display a package list ( ADD / OR dependencies )
    //

    global define DisplayPackageList( string heading, string labelstr, string list_header,
				      list list_contents, boolean check_single ) ``{
	UI::OpenDialog(`opt( `decorated),
		       `HBox(`VSpacing(15),
			     `VBox( `HSpacing(50),
				    `Left(`Heading( heading )),
				    `VSpacing(0.8),
				    // The packages in the list below require to be installed, since..."
				    `Left(`Label( labelstr )),
				    `VBox( `VWeight( 3, `MultiSelectionBox( `id(`add_list), `opt(`hvstretch),
									    list_header,
									    list_contents )
						     ),
					   // Button: install selected package
					   `VWeight( 1, `HCenter(`PushButton(`id(`ok), `opt(`default), OKButtonLabel())) )
					   )
				    )
			     )
		       );

	symbol r = `ok;
	list selected_items = [];

	while (true)
	{
	    r = UI::UserInput();

	    selected_items = UI::QueryWidget(`id(`add_list), `SelectedItems);

	    if ( !check_single )
		break;

	    if ( check_single )
	    {
		string message = "";

		if ( size (selected_items) == 0 )
		{
		    // this is a popup text: no package will be installed
		    message = _("No packages selected.
None of the packages will be installed.");
		}
		else if ( size( selected_items ) != 1 )
		{
		    // this is a popup text: one package is usually enough
		    message = _("Usually, it is sufficient to select only one package.
Do you really want to install several packages?");
		}
		if ( message == "" )
		    break;

		if ( message != "" )
		{
		    any ret = UI::AnyQuestionPopup( "", message, OKButtonLabel(), CancelButtonLabel(), `focus_no );

		    if ( ret )
			break;
		}
	    }
	}

	if ( r == `ok )
	{
	    UI::CloseDialog();
	    return selected_items;
	}
    };

    //
    // Popup display CONFLICT dependencies
    //

    global define DisplayXorList(string pac_name, list conflict_list, boolean add_pac ) ``{

	term button_box = `Empty();
	term option_no  = `opt();
	term option_yes = `opt();
	string info = "";
	string msg_str = "";
	string conflict = "";
	string conflict_pacs = "";

	// This is the headline of a popup which informs about conflicting packages.
	string headline = _("Package conflict");

	foreach ( `pac, conflict_list, ``{
	    conflict_pacs = conflict_pacs + sformat("<b>%1</b>", pac );
	    conflict_pacs = conflict_pacs + ", ";
	} );
	string status = SCR::Read(.package.packageStatus,pac_name );
	y2debug("SCR::Read(.package.packageStatus(%1): *%2*", pac_name, status);

	// the conflicting package is not yet installed
	if (  status == "X" || status == "a" )
	{
	    info = sformat( _("The installation of package \"%1\"
may cause a package conflict."), pac_name );

	    if ( !add_pac)
	    {
		// message to user - package %1 should not installed
		conflict = sformat( _("It is not recommended to install <b>%1</b>
because it would interfere with:<br>"), pac_name );
		conflict = conflict + conflict_pacs;
		// because there could be conflicts
		msg_str = msg_str + _("Undesired side effects may occur
 if the packages are installed together.");
		option_yes = `opt(`hstretch);
		option_no = `opt(`default, `hstretch);
	    }
	    else
	    {
		// package %1 conflicts with other packages
		conflict = sformat( _("Package <b>%1</b> interferes with:<br>"), pac_name );
		conflict = conflict + conflict_pacs;
		// the package is an automatically needed package
		msg_str = msg_str + sformat( _("but is required by:
<br><i>%2</i><br>
For the above packages to work, consider
installing the package anyway.
"), pac_name, BreakingPackages(pac_name, false) );
		option_yes = `opt(`default, `hstretch);
		option_no = `opt(`hstretch);
	    }

	    button_box = `VBox( `Left(`Label(sformat(_("Do you want to install \"%1\"?"), pac_name)) ),
				`HBox(
				      // button label: Yes, install the package
				      `HWeight( 1, `PushButton(`id(`yes_install), option_yes, _("&Install package")) ),
                                      `HSpacing(2),
				      // button label: Do not install the package
				      `HWeight( 1, `PushButton(`id(`no_let_it), option_no, _("&Don't install")) )
				      )
				);
	}
	else
	{
	    button_box = `HCenter(
				  `PushButton( `id(`yes_install),`opt(`default), OKButtonLabel() )
				  );
	    // there is an unresolved package conflict
	    info = _("This package conflict cannot be resolved
at this time.");
	    // package %1 conflicts with other packages
	    conflict = sformat( _("Package <b>%1</b> interferes with:<br>"), pac_name );
	    conflict = conflict + conflict_pacs;

	    // give some more user information
	    msg_str = _("This is usually not a serious problem,
but if you experience undesired behavior, you might need to
remove packages manually.
");
	}


	UI::OpenDialog( `opt(`decorated),
			`HBox(`VSpacing(15),
			      `VBox(`HSpacing(40),
				    `Left(`Heading(headline)),
				    `VSpacing(0.1),
				    `Left(`Label(info) ),
				    `VSpacing(0.2),
				    `RichText(conflict + "<br>" + msg_str),
				    `VSpacing(0.3),
				    button_box )
			      )
			);

	any r = UI::UserInput();
	UI::CloseDialog();
	return (r);
    };

    UI( ``{
	global define DisplayObsoletes ( string package, string pac_name, list pac_list,
					 string obs_name, string obs_descr, list obs_list ) ``{
	    integer vdim = 10;

	    string info_a = sformat( _("Installation of \"%1\" implies that
\"%2\" will become obsolete.
"), pac_name, obs_name );

	    string conflict_a = sformat( _("If package <b>%1</b> is installed, package <b>%2</b>
(%3) will be automatically removed from your system.<br>"), pac_name, obs_name, obs_descr );

	    string question = "";
	    string button_label = "";
	    if ( obs_name != package )
	    {
		question = sformat(_("Do you really want to install \"%1\"?"), package );
		button_label = _("&Install package");
	    }
	    else
	    {
		question = sformat(_("Do you really want to select \"%1\"?"), package );
		button_label = _("&Yes, select");
	    }
	    string info = sformat( _("Installation of \"%1\" means:\n"), package );

	    string conflict = sformat( _("Package <b>%2</b> (%3) will be replaced
by package <b>%1</b>.<br>"), pac_name, obs_name, obs_descr );

	    if ( pac_list != [] )
	    {
		conflict = conflict + sformat( _("<b>%1</b> is required by: %2<br>"), pac_name, pac_list );
	    }
	    if ( obs_list != [] )
	    {
		conflict = conflict + sformat( _("<b>%1</b> is required by: %2<br>"), obs_name, obs_list );
		vdim = 15;
	    }
	    OpenDialog( `opt(`decorated),
			`HBox(`VSpacing(vdim),
			      `VBox(`HSpacing(40),
				    // This is the headline of popup package1 will remove package2.
				    `Left(`Heading( _("Severe package conflict"))),
				    `VSpacing(0.1),
				    `Left(`Label(info) ),
				    `VSpacing(0.2),
				    `RichText(conflict),
				    `VSpacing(0.2),
				    `VBox( `Left(`Label( question )),
					   `HBox(
						 `HWeight( 1,`PushButton(`id(`ignore), button_label) ),
						 `HSpacing(2),
						 `HWeight( 1,`PushButton(`id(`no_let_it), `opt(`default), _("&Don't install")) )
						 )
					   )
				    )
			      ) );

	    any r = UserInput();
	    CloseDialog();
	    return (r);
	};
    });

}
